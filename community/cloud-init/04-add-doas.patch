From: Dermot Bradley <dermot_bradley@yahoo.com>
Date: Thu, 26 Aug 2021 00:58 +0100
Subject: [PATCH] cloud-init: Add doas support

Add doas support to users_groups module.

---

diff -aur a/cloudinit/config/cc_users_groups.py b/cloudinit/config/cc_users_groups.py
--- a/cloudinit/config/cc_users_groups.py
+++ b/cloudinit/config/cc_users_groups.py
@@ -55,14 +55,20 @@
     if the cloud-config can be intercepted. SSH authentication is preferred.
 
 .. note::
+    If specifying a doas rule for a user, ensure that the syntax for the rule
+    is valid, as the only checking performed by cloud-init is to ensure that
+    the user referenced in the rule is the correct user.
+
+.. note::
     If specifying a sudo rule for a user, ensure that the syntax for the rule
     is valid, as it is not checked by cloud-init.
 
 .. note::
     Most of these configuration options will not be honored if the user
     already exists. The following options are the exceptions; they are applied
-    to already-existing users: ``plain_text_passwd``, ``hashed_passwd``,
-    ``lock_passwd``, ``sudo``, ``ssh_authorized_keys``, ``ssh_redirect_user``.
+    to already-existing users: ``plain_text_passwd``, ``doas``,
+    ``hashed_passwd``, ``lock_passwd``, ``sudo``, ``ssh_authorized_keys``,
+    ``ssh_redirect_user``.
 
 The ``user`` key can be used to override the ``default_user`` configuration
 defined in ``/etc/cloud/cloud.cfg``. The ``user`` value should be a dictionary
@@ -109,6 +115,26 @@
           lock_passwd: true
           ssh_import_id:
             - lp:falcojr
+            - gh:TheRealFalcon
+        """
+        ),
+        dedent(
+            """\
+        # Skip creation of the <default> user and only create newsuper.
+        # Password-based login is rejected, but the github user TheRealFalcon
+        # and the launchpad user falcojr can SSH as newsuper. doas/opendoas
+        # is configured to permit this user to run commands as other users
+        # (without being prompted for a password) except not as root.
+        users:
+        - name: newsuper
+          gecos: Big Stuff
+          groups: users, admin
+          doas:
+            - permit nopass newsuper
+            - deny newsuper as root
+          lock_passwd: true
+          ssh_import_id:
+            - lp:falcojr
             - gh:TheRealFalcon
         """
         ),
diff -aur a/cloudinit/config/schemas/schema-cloud-config-v1.json b/cloudinit/config/schemas/schema-cloud-config-v1.json
--- a/cloudinit/config/schemas/schema-cloud-config-v1.json
+++ b/cloudinit/config/schemas/schema-cloud-config-v1.json
@@ -142,6 +142,14 @@
           "description": "The user's login name. Required otherwise user creation will be skipped for this user.",
           "type": "string"
         },
+        "doas": {
+          "description": "List of doas rules to add for a user. doas or opendoas must be installed for rules to take effect.",
+          "type": "array",
+          "items": {
+            "type": "string"
+          },
+          "minItems": 1
+        },
         "expiredate": {
           "default": null,
           "description": "Optional. Date on which the user's account will be disabled. Default: ``null``",
diff -aur a/cloudinit/distros/__init__.py b/cloudinit/distros/__init__.py
--- a/cloudinit/distros/__init__.py
+++ b/cloudinit/distros/__init__.py
@@ -93,6 +93,7 @@
     pip_package_name = "python3-pip"
     usr_lib_exec = "/usr/lib"
     hosts_fn = "/etc/hosts"
+    doas_fn = "/etc/doas.d/cloud-init.conf"
     ci_sudoers_fn = "/etc/sudoers.d/90-cloud-init-users"
     hostname_conf_fn = "/etc/hostname"
     tz_zone_dir = "/usr/share/zoneinfo"
@@ -652,6 +653,7 @@
         * ``plain_text_passwd``
         * ``hashed_passwd``
         * ``lock_passwd``
+        * ``doas``
         * ``sudo``
         * ``ssh_authorized_keys``
         * ``ssh_redirect_user``
@@ -677,6 +679,11 @@
         if kwargs.get("lock_passwd", True):
             self.lock_passwd(name)
 
+        # Configure doas access
+        if "doas" in kwargs:
+            if kwargs["doas"]:
+                self.write_doas_rules(name, kwargs["doas"])
+
         # Configure sudo access
         if "sudo" in kwargs:
             if kwargs["sudo"]:
@@ -782,6 +789,79 @@
         cmd = ["chpasswd"] + (["-e"] if hashed else [])
         subp.subp(cmd, payload)
 
+    def ensure_doas_dir(self, path):
+        # Ensure the directory actually exists
+        util.ensure_dir(path, 0o750)
+
+    def is_doas_rule_valid(self, user, rule):
+        rule_pattern = (
+            r"^(?:permit|deny)"
+            r"(?:\s+(?:nolog|nopass|persist|keepenv|setenv \{[^}]+\})+)*"
+            r"\s+([a-zA-Z0-9_]+)+"
+            r"(?:\s+as\s+[a-zA-Z0-9_]+)*"
+            r"(?:\s+cmd\s+[^\s]+(?:\s+args\s+[^\s]+(?:\s*[^\s]+)*)*)*"
+            r"\s*$"
+        )
+
+        LOG.debug(
+            "Checking if user '%s' is referenced in doas rule %r", user, rule
+        )
+
+        valid_match = re.search(rule_pattern, rule)
+        if valid_match:
+            LOG.debug(
+                "User '%s' referenced in doas rule", valid_match.group(1)
+            )
+            if valid_match.group(1) == user:
+                LOG.debug("Correct user is referenced in doas rule")
+                return True
+            else:
+                LOG.debug(
+                    "Incorrect user '%s' is referenced in doas rule",
+                    valid_match.group(1),
+                )
+                return False
+        else:
+            LOG.debug("doas rule does not appear to reference any user")
+            return False
+
+    def write_doas_rules(self, user, rules, doas_file=None):
+        if not doas_file:
+            doas_file = self.doas_fn
+
+        for rule in rules:
+            if not self.is_doas_rule_valid(user, rule):
+                msg = (
+                    "Invalid doas rule %r for user '%s',"
+                    " not writing any doas rules for user!" % (rule, user)
+                )
+                LOG.error(msg)
+                return
+
+        lines = ["", "# cloud-init User rules for %s" % user]
+        for rule in rules:
+            lines.append("%s" % rule)
+        content = "\n".join(lines)
+        content += "\n"  # trailing newline
+
+        self.ensure_doas_dir(os.path.dirname(doas_file))
+        if not os.path.exists(doas_file):
+            contents = [util.make_header(), content]
+            try:
+                util.write_file(doas_file, "\n".join(contents), mode=0o440)
+            except IOError as e:
+                util.logexc(LOG, "Failed to write doas file %s", doas_file)
+                raise e
+        else:
+            if content not in util.load_file(doas_file):
+                try:
+                    util.append_file(doas_file, content)
+                except IOError as e:
+                    util.logexc(
+                        LOG, "Failed to append to doas file %s", doas_file
+                    )
+                    raise e
+
     def ensure_sudo_dir(self, path, sudo_base="/etc/sudoers"):
         # Ensure the dir is included and that
         # it actually exists as a directory
diff -aur a/config/cloud.cfg.tmpl b/config/cloud.cfg.tmpl
--- a/config/cloud.cfg.tmpl
+++ b/config/cloud.cfg.tmpl
@@ -280,6 +280,10 @@
      lock_passwd: True
      gecos: {{ variant }} Cloud User
 {% endif %}
+{% if variant == "alpine" %}
+     doas:
+       - permit nopass alpine
+{% endif %}
 {% if variant == "suse" %}
      groups: [cdrom, users]
 {% elif variant == "gentoo" %}
@@ -287,7 +291,7 @@
      primary_group: users
      no_user_group: true
 {% elif variant == "alpine" %}
-     groups: [adm, sudo]
+     groups: [adm, sudo, wheel]
 {% elif variant == "arch" %}
      groups: [wheel, users]
 {% elif variant == "openmandriva" %}
diff -aur a/tests/unittests/distros/test__init__.py b/tests/unittests/distros/test__init__.py
--- a/tests/unittests/distros/test__init__.py
+++ b/tests/unittests/distros/test__init__.py
@@ -59,6 +59,17 @@
         self.tmp = tempfile.mkdtemp()
         self.addCleanup(shutil.rmtree, self.tmp)
 
+    def _write_load_doas(self, user, rules):
+        cls = distros.fetch("ubuntu")
+        d = cls("ubuntu", {}, None)
+        if not os.path.exists(os.path.join(self.tmp, "etc/doas.d")):
+            os.makedirs(os.path.join(self.tmp, "etc/doas.d"))
+        self.patchOS(self.tmp)
+        self.patchUtils(self.tmp)
+        d.write_doas_rules(user, rules)
+        contents = util.load_file(d.doas_fn)
+        return contents, cls, d
+
     def _write_load_sudoers(self, _user, rules):
         cls = distros.fetch("ubuntu")
         d = cls("ubuntu", {}, None)
@@ -79,6 +90,68 @@
                     found_amount += 1
         return found_amount
 
+    def test_doas_ensure_rules(self):
+        rules = ["permit nopass harlowja"]
+        contents = self._write_load_doas("harlowja", rules)[0]
+        expected = ["permit nopass harlowja"]
+        self.assertEqual(len(expected), self._count_in(expected, contents))
+
+    def test_doas_ensure_rules_list(self):
+        rules = [
+            "permit nopass harlowja cmd ls",
+            "permit nopass harlowja cmd pwd",
+            "permit nopass harlowja cmd df",
+        ]
+        contents = self._write_load_doas("harlowja", rules)[0]
+        expected = [
+            "permit nopass harlowja cmd ls",
+            "permit nopass harlowja cmd pwd",
+            "permit nopass harlowja cmd df",
+        ]
+        self.assertEqual(len(expected), self._count_in(expected, contents))
+
+    def test_doas_ensure_handle_duplicates(self):
+        rules = [
+            "permit nopass harlowja cmd ls",
+            "permit nopass harlowja cmd pwd",
+            "permit nopass harlowja cmd df",
+        ]
+        d = self._write_load_doas("harlowja", rules)[2]
+        # write to doas.conf again - should not create duplicate rules
+        d.write_doas_rules("harlowja", rules)
+        contents = util.load_file(d.doas_fn)
+        expected = [
+            "permit nopass harlowja cmd ls",
+            "permit nopass harlowja cmd pwd",
+            "permit nopass harlowja cmd df",
+        ]
+        self.assertEqual(len(expected), self._count_in(expected, contents))
+
+    def test_doas_ensure_new(self):
+        rules = [
+            "permit nopass harlowja cmd ls",
+            "permit nopass harlowja cmd pwd",
+            "permit nopass harlowja cmd df",
+        ]
+        contents = self._write_load_doas("harlowja", rules)[0]
+        self.assertIn("# Created by cloud-init v.", contents)
+        self.assertIn("harlowja", contents)
+        self.assertEqual(4, contents.count("harlowja"))
+
+    def test_doas_ensure_append(self):
+        self.patchUtils(self.tmp)
+        util.write_file("/etc/doas.d/cloud-init.conf", "# root user\npermit nopass root\n")
+        rules = [
+            "permit nopass harlowja cmd ls",
+            "permit nopass harlowja cmd pwd",
+            "permit nopass harlowja cmd df",
+        ]
+        contents = self._write_load_doas("harlowja", rules)[0]
+        self.assertIn("root", contents)
+        self.assertEqual(2, contents.count("root"))
+        self.assertIn("harlowja", contents)
+        self.assertEqual(4, contents.count("harlowja"))
+
     def test_sudoers_ensure_rules(self):
         rules = "ALL=(ALL:ALL) ALL"
         contents = self._write_load_sudoers("harlowja", rules)
