Patch-Source: https://phabricator.services.mozilla.com/D170368
--
diff --git a/browser/themes/shared/browser-shared.css b/browser/themes/shared/browser-shared.css
index ddb2ff5874..0e4ac83ebd 100644
--- a/browser/themes/shared/browser-shared.css
+++ b/browser/themes/shared/browser-shared.css
@@ -265,9 +265,10 @@ menupopup::part(drop-indicator-container) {
    * probably simplify this substantially, by making the indicator position:
    * absolute or so (which was never properly supported in XUL). The container
    * should become completely unnecessary then. */
-  -moz-box-flex: 1;
   min-width: 0;
   min-height: 0;
+  max-width: 100%;
+  max-height: 100%;
 }
 
 menupopup::part(drop-indicator-bar) {
diff --git a/dom/xul/XULPopupElement.cpp b/dom/xul/XULPopupElement.cpp
index c329526a3f..d60173900e 100644
--- a/dom/xul/XULPopupElement.cpp
+++ b/dom/xul/XULPopupElement.cpp
@@ -6,10 +6,12 @@
 
 #include "XULMenuParentElement.h"
 #include "nsCOMPtr.h"
+#include "nsICSSDeclaration.h"
 #include "nsIContent.h"
 #include "nsNameSpaceManager.h"
 #include "nsGkAtoms.h"
 #include "nsMenuPopupFrame.h"
+#include "nsStringFwd.h"
 #include "nsView.h"
 #include "mozilla/AppUnits.h"
 #include "mozilla/AsyncEventDispatcher.h"
@@ -197,8 +199,7 @@ void XULPopupElement::ActivateItem(Element& aItemElement,
 }
 
 void XULPopupElement::MoveTo(int32_t aLeft, int32_t aTop) {
-  nsMenuPopupFrame* menuPopupFrame = do_QueryFrame(GetPrimaryFrame());
-  if (menuPopupFrame) {
+  if (nsMenuPopupFrame* menuPopupFrame = do_QueryFrame(GetPrimaryFrame())) {
     menuPopupFrame->MoveTo(CSSIntPoint(aLeft, aTop), true);
   }
 }
@@ -214,20 +215,16 @@ void XULPopupElement::MoveToAnchor(Element* aAnchorElement,
 }
 
 void XULPopupElement::SizeTo(int32_t aWidth, int32_t aHeight) {
-  nsAutoString width, height;
+  nsAutoCString width;
+  nsAutoCString height;
   width.AppendInt(aWidth);
+  width.AppendLiteral("px");
   height.AppendInt(aHeight);
+  height.AppendLiteral("px");
 
-  nsCOMPtr<nsIContent> kungFuDeathGrip = this;  // keep a reference
-
-  // We only want to pass aNotify=true to SetAttr once, but must make sure
-  // we pass it when a value is being changed.  Thus, we check if the height
-  // is the same and if so, pass true when setting the width.
-  bool heightSame =
-      AttrValueIs(kNameSpaceID_None, nsGkAtoms::height, height, eCaseMatters);
-
-  SetAttr(kNameSpaceID_None, nsGkAtoms::width, width, heightSame);
-  SetAttr(kNameSpaceID_None, nsGkAtoms::height, height, true);
+  nsCOMPtr<nsICSSDeclaration> style = Style();
+  style->SetProperty("width"_ns, width, ""_ns, IgnoreErrors());
+  style->SetProperty("height"_ns, height, ""_ns, IgnoreErrors());
 
   // If the popup is open, force a reposition of the popup after resizing it
   // with notifications set to true so that the popuppositioned event is fired.
@@ -317,7 +314,7 @@ void XULPopupElement::SetConstraintRect(dom::DOMRectReadOnly& aRect) {
   nsMenuPopupFrame* menuPopupFrame =
       do_QueryFrame(GetPrimaryFrame(FlushType::Frames));
   if (menuPopupFrame) {
-    menuPopupFrame->SetOverrideConstraintRect(LayoutDeviceIntRect::Truncate(
+    menuPopupFrame->SetOverrideConstraintRect(CSSIntRect::Truncate(
         aRect.Left(), aRect.Top(), aRect.Width(), aRect.Height()));
   }
 }
diff --git a/layout/base/tests/chrome/test_bug533845.xhtml b/layout/base/tests/chrome/test_bug533845.xhtml
index e2acdd3427..3ea21cb9b7 100644
--- a/layout/base/tests/chrome/test_bug533845.xhtml
+++ b/layout/base/tests/chrome/test_bug533845.xhtml
@@ -9,7 +9,7 @@ https://bugzilla.mozilla.org/show_bug.cgi?id=533845
         xmlns="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
         onload="doTest()">
   <script src="chrome://mochikit/content/tests/SimpleTest/SimpleTest.js"></script>
-<panel id="panel" width="500" height="500">
+<panel id="panel" style="width: 500px; height: 500px">
   <iframe type="content" id="contentFrame" src="data:text/html,&lt;html&gt;&lt;body onclick='document.body.textContent=1'&gt;This is a panel!&lt;/body&gt;&lt;/html&gt;" width="500" height="500"/>
 </panel>
 <body xmlns="http://www.w3.org/1999/xhtml">
diff --git a/layout/forms/nsListControlFrame.cpp b/layout/forms/nsListControlFrame.cpp
index 267084169b..905919ac40 100644
--- a/layout/forms/nsListControlFrame.cpp
+++ b/layout/forms/nsListControlFrame.cpp
@@ -241,8 +241,7 @@ nscoord nsListControlFrame::GetPrefISize(gfxContext* aRenderingContext) {
   Maybe<nscoord> containISize = ContainIntrinsicISize();
   result = containISize ? *containISize
                         : GetScrolledFrame()->GetPrefISize(aRenderingContext);
-  LogicalMargin scrollbarSize(
-      wm, GetDesiredScrollbarSizes(PresContext(), aRenderingContext));
+  LogicalMargin scrollbarSize(wm, GetDesiredScrollbarSizes());
   result = NSCoordSaturatingAdd(result, scrollbarSize.IStartEnd(wm));
   return result;
 }
@@ -259,8 +258,7 @@ nscoord nsListControlFrame::GetMinISize(gfxContext* aRenderingContext) {
   Maybe<nscoord> containISize = ContainIntrinsicISize();
   result = containISize ? *containISize
                         : GetScrolledFrame()->GetMinISize(aRenderingContext);
-  LogicalMargin scrollbarSize(
-      wm, GetDesiredScrollbarSizes(PresContext(), aRenderingContext));
+  LogicalMargin scrollbarSize(wm, GetDesiredScrollbarSizes());
   result += scrollbarSize.IStartEnd(wm);
 
   return result;
diff --git a/layout/forms/nsTextControlFrame.cpp b/layout/forms/nsTextControlFrame.cpp
index 7656d516ba..09fb81ac47 100644
--- a/layout/forms/nsTextControlFrame.cpp
+++ b/layout/forms/nsTextControlFrame.cpp
@@ -247,12 +247,9 @@ LogicalSize nsTextControlFrame::CalcIntrinsicSize(
   if (IsTextArea()) {
     nsIScrollableFrame* scrollableFrame = GetScrollTargetFrame();
     NS_ASSERTION(scrollableFrame, "Child must be scrollable");
-
     if (scrollableFrame) {
-      LogicalMargin scrollbarSizes(
-          aWM, scrollableFrame->GetDesiredScrollbarSizes(PresContext(),
-                                                         aRenderingContext));
-
+      LogicalMargin scrollbarSizes(aWM,
+                                   scrollableFrame->GetDesiredScrollbarSizes());
       intrinsicSize.ISize(aWM) += scrollbarSizes.IStartEnd(aWM);
       intrinsicSize.BSize(aWM) += scrollbarSizes.BStartEnd(aWM);
     }
diff --git a/layout/generic/nsGfxScrollFrame.cpp b/layout/generic/nsGfxScrollFrame.cpp
index f02632b6a7..a2212b0a16 100644
--- a/layout/generic/nsGfxScrollFrame.cpp
+++ b/layout/generic/nsGfxScrollFrame.cpp
@@ -1626,34 +1626,34 @@ void nsXULScrollFrame::ScrollbarActivityStopped() const {
   }
 }
 
-nsMargin ScrollFrameHelper::GetDesiredScrollbarSizes(nsBoxLayoutState* aState) {
-  NS_ASSERTION(aState && aState->GetRenderingContext(),
-               "Must have rendering context in layout state for size "
-               "computations");
-
-  nsMargin result(0, 0, 0, 0);
-  ScrollStyles styles = GetScrollStylesFromFrame();
-
-  const auto& style = *nsLayoutUtils::StyleForScrollbar(mOuter);
-  if (style.StyleUIReset()->ScrollbarWidth() == StyleScrollbarWidth::None) {
+nsMargin ScrollFrameHelper::GetDesiredScrollbarSizes() const {
+  nsPresContext* pc = mOuter->PresContext();
+  if (pc->UseOverlayScrollbars()) {
     return {};
   }
 
-  if (mVScrollbarBox && styles.mVertical != StyleOverflow::Hidden) {
-    nsSize size = mVScrollbarBox->GetXULPrefSize(*aState);
-    nsIFrame::AddXULMargin(mVScrollbarBox, size);
-    if (IsScrollbarOnRight())
-      result.left = size.width;
-    else
-      result.right = size.width;
+  const auto& style = *nsLayoutUtils::StyleForScrollbar(mOuter);
+  const auto scrollbarWidth = style.StyleUIReset()->ScrollbarWidth();
+  if (scrollbarWidth == StyleScrollbarWidth::None) {
+    return {};
   }
 
-  if (mHScrollbarBox && styles.mHorizontal != StyleOverflow::Hidden) {
-    nsSize size = mHScrollbarBox->GetXULPrefSize(*aState);
-    nsIFrame::AddXULMargin(mHScrollbarBox, size);
+  ScrollStyles styles = GetScrollStylesFromFrame();
+  nsMargin result(0, 0, 0, 0);
+
+  auto size = pc->DevPixelsToAppUnits(
+      pc->Theme()->GetScrollbarSize(pc, scrollbarWidth, nsITheme::Overlay::No));
+  if (styles.mVertical != StyleOverflow::Hidden) {
+    if (IsScrollbarOnRight())
+      result.left = size;
+    else
+      result.right = size;
+  }
+
+  if (styles.mHorizontal != StyleOverflow::Hidden) {
     // We don't currently support any scripts that would require a scrollbar
     // at the top. (Are there any?)
-    result.bottom = size.height;
+    result.bottom = size;
   }
 
   return result;
diff --git a/layout/generic/nsGfxScrollFrame.h b/layout/generic/nsGfxScrollFrame.h
index 5fcbb0c6e4..d90ea1a409 100644
--- a/layout/generic/nsGfxScrollFrame.h
+++ b/layout/generic/nsGfxScrollFrame.h
@@ -400,7 +400,7 @@ class ScrollFrameHelper : public nsIReflowCallback {
   nsMargin GetActualScrollbarSizes(
       nsIScrollableFrame::ScrollbarSizesOptions aOptions =
           nsIScrollableFrame::ScrollbarSizesOptions::NONE) const;
-  nsMargin GetDesiredScrollbarSizes(nsBoxLayoutState* aState);
+  nsMargin GetDesiredScrollbarSizes() const;
   bool IsPhysicalLTR() const {
     return mOuter->GetWritingMode().IsPhysicalLTR();
   }
@@ -1064,13 +1064,8 @@ class nsHTMLScrollFrame : public nsContainerFrame,
           nsIScrollableFrame::ScrollbarSizesOptions::NONE) const final {
     return mHelper.GetActualScrollbarSizes(aOptions);
   }
-  nsMargin GetDesiredScrollbarSizes(nsBoxLayoutState* aState) final {
-    return mHelper.GetDesiredScrollbarSizes(aState);
-  }
-  nsMargin GetDesiredScrollbarSizes(nsPresContext* aPresContext,
-                                    gfxContext* aRC) final {
-    nsBoxLayoutState bls(aPresContext, aRC, 0);
-    return GetDesiredScrollbarSizes(&bls);
+  nsMargin GetDesiredScrollbarSizes() const final {
+    return mHelper.GetDesiredScrollbarSizes();
   }
   nsSize GetLayoutSize() const final { return mHelper.GetLayoutSize(); }
   nsRect GetScrolledRect() const final { return mHelper.GetScrolledRect(); }
@@ -1555,13 +1550,8 @@ class nsXULScrollFrame final : public nsBoxFrame,
           nsIScrollableFrame::ScrollbarSizesOptions::NONE) const final {
     return mHelper.GetActualScrollbarSizes(aOptions);
   }
-  nsMargin GetDesiredScrollbarSizes(nsBoxLayoutState* aState) final {
-    return mHelper.GetDesiredScrollbarSizes(aState);
-  }
-  nsMargin GetDesiredScrollbarSizes(nsPresContext* aPresContext,
-                                    gfxContext* aRC) final {
-    nsBoxLayoutState bls(aPresContext, aRC, 0);
-    return GetDesiredScrollbarSizes(&bls);
+  nsMargin GetDesiredScrollbarSizes() const final {
+    return mHelper.GetDesiredScrollbarSizes();
   }
   nsSize GetLayoutSize() const final { return mHelper.GetLayoutSize(); }
   nsRect GetScrolledRect() const final { return mHelper.GetScrolledRect(); }
diff --git a/layout/generic/nsIScrollableFrame.h b/layout/generic/nsIScrollableFrame.h
index 4764c9478f..87e859c5dc 100644
--- a/layout/generic/nsIScrollableFrame.h
+++ b/layout/generic/nsIScrollableFrame.h
@@ -133,14 +133,7 @@ class nsIScrollableFrame : public nsIScrollbarMediator {
    * be visible due to overflowing content, are. This can be called during
    * reflow of the scrolled contents.
    */
-  virtual nsMargin GetDesiredScrollbarSizes(nsBoxLayoutState* aState) = 0;
-  /**
-   * Return the sizes of all scrollbars assuming that any scrollbars that could
-   * be visible due to overflowing content, are. This can be called during
-   * reflow of the scrolled contents.
-   */
-  virtual nsMargin GetDesiredScrollbarSizes(nsPresContext* aPresContext,
-                                            gfxContext* aRC) = 0;
+  virtual nsMargin GetDesiredScrollbarSizes() const = 0;
   /**
    * Return the width for non-disappearing scrollbars.
    */
diff --git a/layout/xul/nsMenuPopupFrame.cpp b/layout/xul/nsMenuPopupFrame.cpp
index aed04f88ae..57ef16e99d 100644
--- a/layout/xul/nsMenuPopupFrame.cpp
+++ b/layout/xul/nsMenuPopupFrame.cpp
@@ -5,6 +5,7 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 #include "nsMenuPopupFrame.h"
+#include "LayoutConstants.h"
 #include "XULButtonElement.h"
 #include "XULPopupElement.h"
 #include "mozilla/dom/XULPopupElement.h"
@@ -81,7 +82,7 @@ extern mozilla::LazyLogModule gWidgetPopupLog;
     MOZ_LOG(gWidgetPopupLog, mozilla::LogLevel::Debug, (__VA_ARGS__))
 #else
 #  define IS_WAYLAND_DISPLAY() false
-#  define LOG_WAYLAND (...)
+#  define LOG_WAYLAND(...)
 #endif
 
 // NS_NewMenuPopupFrame
@@ -97,34 +98,14 @@ NS_IMPL_FRAMEARENA_HELPERS(nsMenuPopupFrame)
 
 NS_QUERYFRAME_HEAD(nsMenuPopupFrame)
   NS_QUERYFRAME_ENTRY(nsMenuPopupFrame)
-NS_QUERYFRAME_TAIL_INHERITING(nsBoxFrame)
+NS_QUERYFRAME_TAIL_INHERITING(nsBlockFrame)
 
 //
 // nsMenuPopupFrame ctor
 //
 nsMenuPopupFrame::nsMenuPopupFrame(ComputedStyle* aStyle,
                                    nsPresContext* aPresContext)
-    : nsBoxFrame(aStyle, aPresContext, kClassID),
-      mView(nullptr),
-      mPrefSize(-1, -1),
-      mXPos(0),
-      mYPos(0),
-      mAlignmentOffset(0),
-      mLastClientOffset(0, 0),
-      mPopupType(PopupType::Panel),
-      mPopupState(ePopupClosed),
-      mPopupAlignment(POPUPALIGNMENT_NONE),
-      mPopupAnchor(POPUPALIGNMENT_NONE),
-      mPosition(POPUPPOSITION_UNKNOWN),
-      mFlip(FlipType_Default),
-      mIsOpenChanged(false),
-      mMenuCanOverlapOSBar(false),
-      mInContentShell(true),
-      mIsOffset(false),
-      mHFlip(false),
-      mVFlip(false),
-      mPositionedOffset(0),
-      mAnchorType(MenuPopupAnchorType_Node) {
+    : nsBlockFrame(aStyle, aPresContext, kClassID) {
   // the preference name is backwards here. True means that the 'top' level is
   // the default, and false means that the 'parent' level is the default.
   if (sDefaultLevelIsTop >= 0) return;
@@ -162,12 +143,7 @@ bool nsMenuPopupFrame::ShouldCreateWidgetUpfront() const {
 
 void nsMenuPopupFrame::Init(nsIContent* aContent, nsContainerFrame* aParent,
                             nsIFrame* aPrevInFlow) {
-  nsBoxFrame::Init(aContent, aParent, aPrevInFlow);
-
-  // lookup if we're allowed to overlap the OS bar (menubar/taskbar) from the
-  // look&feel object
-  mMenuCanOverlapOSBar =
-      LookAndFeel::GetInt(LookAndFeel::IntID::MenusCanOverlapOSBar) != 0;
+  nsBlockFrame::Init(aContent, aParent, aPrevInFlow);
 
   CreatePopupView();
 
@@ -446,7 +422,7 @@ NS_IMPL_ISUPPORTS_INHERITED(nsXULPopupShownEvent, Runnable,
                             nsIDOMEventListener);
 
 void nsMenuPopupFrame::DidSetComputedStyle(ComputedStyle* aOldStyle) {
-  nsBoxFrame::DidSetComputedStyle(aOldStyle);
+  nsBlockFrame::DidSetComputedStyle(aOldStyle);
 
   if (!aOldStyle) {
     return;
@@ -476,45 +452,54 @@ void nsMenuPopupFrame::DidSetComputedStyle(ComputedStyle* aOldStyle) {
   }
 }
 
-void nsMenuPopupFrame::ConstrainSizeForWayland(nsSize& aSize) const {
-#ifdef MOZ_WAYLAND
-  if (!IS_WAYLAND_DISPLAY()) {
+void nsMenuPopupFrame::TweakMinPrefISize(nscoord& aSize) {
+  if (!ShouldExpandToInflowParentOrAnchor()) {
     return;
   }
-
-  // If the size is not a whole number in CSS pixels we need round it up to
-  // avoid reflow of the tooltips/popups and putting the text on two lines
-  // (usually happens with 200% scale factor and font scale factor <> 1) because
-  // GTK throws away the decimals.
-  int32_t appPerCSS = AppUnitsPerCSSPixel();
-  if (aSize.width % appPerCSS > 0) {
-    aSize.width += appPerCSS;
-  }
-  if (aSize.height % appPerCSS > 0) {
-    aSize.height += appPerCSS;
+  // Make sure to accommodate for our scrollbar if needed. Do it only for
+  // menulists to match previous behavior.
+  //
+  // NOTE(emilio): This is somewhat hacky. The "right" fix (which would be
+  // using scrollbar-gutter: stable on the scroller) isn't great, because even
+  // though we want a stable gutter, we want to draw on top of the gutter when
+  // there's no scrollbar, otherwise it looks rather weird.
+  //
+  // Automatically accommodating for the scrollbar otherwise would be bug
+  // 764076, but that has its own set of problems.
+  if (nsIScrollableFrame* sf = GetScrollFrame()) {
+    aSize += sf->GetDesiredScrollbarSizes().LeftRight();
   }
 
-  nsIWidget* widget = GetWidget();
-  if (!widget) {
-    return;
+  nscoord menuListOrAnchorWidth = 0;
+  if (nsIFrame* menuList = GetInFlowParent()) {
+    menuListOrAnchorWidth = menuList->GetRect().width;
   }
+  if (mAnchorType == MenuPopupAnchorType_Rect) {
+    menuListOrAnchorWidth = std::max(menuListOrAnchorWidth, mScreenRect.width);
+  }
+  // Input margin doesn't have contents, so account for it for popup sizing
+  // purposes.
+  menuListOrAnchorWidth +=
+      2 * StyleUIReset()->mMozWindowInputRegionMargin.ToAppUnits();
+  aSize = std::max(aSize, menuListOrAnchorWidth);
+}
 
-  // Shrink the popup down if it's larger than popup size received from Wayland
-  // compositor. We don't know screen size on Wayland so this is the only info
-  // we have there.
-  const nsSize waylandSize = LayoutDeviceIntRect::ToAppUnits(
-      widget->GetMoveToRectPopupSize(), PresContext()->AppUnitsPerDevPixel());
-  if (waylandSize.width > 0 && aSize.width > waylandSize.width) {
-    LOG_WAYLAND("Wayland constraint width [%p]:  %d to %d", widget, aSize.width,
-                waylandSize.width);
-    aSize.width = waylandSize.width;
-  }
-  if (waylandSize.height > 0 && aSize.height > waylandSize.height) {
-    LOG_WAYLAND("Wayland constraint height [%p]:  %d to %d", widget,
-                aSize.height, waylandSize.height);
-    aSize.height = waylandSize.height;
-  }
-#endif
+nscoord nsMenuPopupFrame::GetMinISize(gfxContext* aRC) {
+  nscoord result;
+  DISPLAY_PREF_INLINE_SIZE(this, result);
+
+  result = nsBlockFrame::GetMinISize(aRC);
+  TweakMinPrefISize(result);
+  return result;
+}
+
+nscoord nsMenuPopupFrame::GetPrefISize(gfxContext* aRC) {
+  nscoord result;
+  DISPLAY_PREF_INLINE_SIZE(this, result);
+
+  result = nsBlockFrame::GetPrefISize(aRC);
+  TweakMinPrefISize(result);
+  return result;
 }
 
 void nsMenuPopupFrame::Reflow(nsPresContext* aPresContext,
@@ -526,14 +511,13 @@ void nsMenuPopupFrame::Reflow(nsPresContext* aPresContext,
   DISPLAY_REFLOW(aPresContext, this, aReflowInput, aDesiredSize, aStatus);
   MOZ_ASSERT(aStatus.IsEmpty(), "Caller should pass a fresh reflow status!");
 
-  nsBoxLayoutState state(aPresContext, aReflowInput.mRenderingContext,
-                         &aReflowInput, aReflowInput.mReflowDepth);
-  LayoutPopup(state);
-
   const auto wm = GetWritingMode();
-  LogicalSize boxSize = GetLogicalSize(wm);
-  aDesiredSize.SetSize(wm, boxSize);
-  aDesiredSize.SetBlockStartAscent(boxSize.BSize(wm));
+  // Default to preserving our bounds.
+  aDesiredSize.SetSize(wm, GetLogicalSize(wm));
+
+  LayoutPopup(aPresContext, aDesiredSize, aReflowInput, aStatus);
+
+  aDesiredSize.SetBlockStartAscent(aDesiredSize.BSize(wm));
   aDesiredSize.SetOverflowAreasToDesiredBounds();
   FinishAndStoreOverflow(&aDesiredSize, aReflowInput.mStyleDisplay);
 }
@@ -552,30 +536,18 @@ void nsMenuPopupFrame::EnsureActiveMenuListItemIsVisible() {
       ScrollFlags::ScrollOverflowHidden | ScrollFlags::ScrollFirstAncestorOnly);
 }
 
-void nsMenuPopupFrame::LayoutPopup(nsBoxLayoutState& aState) {
+void nsMenuPopupFrame::LayoutPopup(nsPresContext* aPresContext,
+                                   ReflowOutput& aDesiredSize,
+                                   const ReflowInput& aReflowInput,
+                                   nsReflowStatus& aStatus) {
   if (IsNativeMenu()) {
     return;
   }
 
   SchedulePaint();
 
-  bool shouldPosition = [&] {
-    if (!IsAnchored()) {
-      return true;
-    }
-    if (ShouldFollowAnchor()) {
-      return true;
-    }
-    // Don't reposition anchored popups that shouldn't follow the anchor and
-    // have already been positioned.
-    return mPopupState != ePopupShown || mUsedScreenRect.IsEmpty();
-  }();
-
-  bool isOpen = IsOpen();
+  const bool isOpen = IsOpen();
   if (!isOpen) {
-    shouldPosition =
-        mPopupState == ePopupShowing || mPopupState == ePopupPositioning;
-
     // If the popup is not open, only do layout while showing or if we're a
     // menulist.
     //
@@ -584,127 +556,72 @@ void nsMenuPopupFrame::LayoutPopup(nsBoxLayoutState& aState) {
     //
     // TODO(emilio): We should consider adding a way to do that more reliably
     // instead, but this preserves existing behavior.
-    const bool needsLayout = shouldPosition || IsMenuList();
+    const bool needsLayout = mPopupState == ePopupShowing ||
+                             mPopupState == ePopupPositioning || IsMenuList();
     if (!needsLayout) {
       RemoveStateBits(NS_FRAME_FIRST_REFLOW);
       return;
     }
   }
 
-  // if the popup has just been opened, make sure the scrolled window is at 0,0
-  // Don't scroll menulists as they will scroll to their selected item on their
-  // own.
-  if (mIsOpenChanged && !IsMenuList()) {
-    nsIScrollableFrame* scrollframe =
-        do_QueryFrame(nsIFrame::GetChildXULBox(this));
-    if (scrollframe) {
-      AutoWeakFrame weakFrame(this);
-      scrollframe->ScrollTo(nsPoint(0, 0), ScrollMode::Instant);
-      if (!weakFrame.IsAlive()) {
-        return;
+  // Do a first reflow, with all our content, in order to find our preferred
+  // size. Then, we do a second reflow with the updated dimensions.
+  const bool needsPrefSize = mPrefSize == nsSize(-1, -1) || IsSubtreeDirty();
+  if (needsPrefSize) {
+    // Get the preferred, minimum and maximum size. If the menu is sized to the
+    // popup, then the popup's width is the menu's width.
+    ReflowOutput preferredSize(aReflowInput);
+    nsBlockFrame::Reflow(aPresContext, preferredSize, aReflowInput, aStatus);
+    mPrefSize = preferredSize.PhysicalSize();
+  }
+
+  // Get our desired position and final size, now that we have a preferred size.
+  auto constraints = GetRects(mPrefSize);
+  const auto finalSize = constraints.mUsedRect.Size();
+
+  // We need to do an extra reflow if we haven't reflowed, our size doesn't
+  // match with our final intended size, or our bsize is unconstrained (in which
+  // case we need to specify the final size so that percentages work).
+  const bool needDefiniteReflow =
+      aReflowInput.ComputedBSize() == NS_UNCONSTRAINEDSIZE || !needsPrefSize ||
+      finalSize != mPrefSize;
+
+  if (needDefiniteReflow) {
+    ReflowInput constrainedReflowInput(aReflowInput);
+    const auto& bp = aReflowInput.ComputedPhysicalBorderPadding();
+    // TODO: writing-mode handling not terribly correct, but it doesn't matter.
+    const nsSize finalContentSize(finalSize.width - bp.LeftRight(),
+                                  finalSize.height - bp.TopBottom());
+    constrainedReflowInput.SetComputedISize(finalContentSize.width);
+    constrainedReflowInput.SetComputedBSize(finalContentSize.height);
+    constrainedReflowInput.SetIResize(finalSize.width != mPrefSize.width);
+    constrainedReflowInput.SetBResize([&] {
+      if (finalSize.height != mPrefSize.height) {
+        return true;
       }
-    }
+      if (needsPrefSize &&
+          aReflowInput.ComputedBSize() == NS_UNCONSTRAINEDSIZE &&
+          aReflowInput.ComputedMaxBSize() == finalContentSize.height) {
+        // If we have measured, and maybe clamped our children via max-height,
+        // they might need to get percentages in the block axis re-resolved.
+        return true;
+      }
+      return false;
+    }());
+
+    aStatus.Reset();
+    nsBlockFrame::Reflow(aPresContext, aDesiredSize, constrainedReflowInput,
+                         aStatus);
   }
 
-  // Get the preferred, minimum and maximum size. If the menu is sized to the
-  // popup, then the popup's width is the menu's width.
-  nsSize prefSize = GetXULPrefSize(aState);
-  nsSize minSize = GetXULMinSize(aState);
-  nsSize maxSize = GetXULMaxSize(aState);
-  if (ShouldExpandToInflowParentOrAnchor()) {
-    // Make sure to accommodate for our scrollbar if needed. Do it only for
-    // menulists to match previous behavior.
-    //
-    // NOTE(emilio): This is somewhat hacky. The "right" fix (which would be
-    // using scrollbar-gutter: stable on the scroller) isn't great, because even
-    // though we want a stable gutter, we want to draw on top of the gutter when
-    // there's no scrollbar, otherwise it looks rather weird.
-    //
-    // Automatically accommodating for the scrollbar otherwise would be bug
-    // 764076, but that has its own set of problems.
-    if (nsIScrollableFrame* sf = GetScrollFrame(this)) {
-      prefSize.width += sf->GetDesiredScrollbarSizes(&aState).LeftRight();
-    }
+  // Set our size, since nsAbsoluteContainingBlock won't.
+  SetRect(constraints.mUsedRect);
 
-    nscoord menuListOrAnchorWidth = 0;
-    if (nsIFrame* menuList = GetInFlowParent()) {
-      menuListOrAnchorWidth = menuList->GetRect().width;
-    }
-    if (mAnchorType == MenuPopupAnchorType_Rect) {
-      menuListOrAnchorWidth =
-          std::max(menuListOrAnchorWidth, mScreenRect.width);
-    }
-    // Input margin doesn't have contents, so account for it for popup sizing
-    // purposes.
-    menuListOrAnchorWidth +=
-        2 * StyleUIReset()->mMozWindowInputRegionMargin.ToAppUnits();
-    prefSize.width = std::max(prefSize.width, menuListOrAnchorWidth);
-  }
-
-  prefSize = XULBoundsCheck(minSize, prefSize, maxSize);
-
-  ConstrainSizeForWayland(prefSize);
-
-  const bool sizeChanged = mPrefSize != prefSize;
-  // if the size changed then set the bounds to be the preferred size, and make
-  // sure we re-position the popup too (as that can shrink or resize us again).
-  if (sizeChanged) {
-    shouldPosition = true;
-    SetXULBounds(aState, nsRect(nsPoint(), prefSize), false);
-    mPrefSize = prefSize;
-  }
-
-  bool needCallback = false;
-  if (shouldPosition) {
-    SetPopupPosition(false);
-    needCallback = true;
-  }
-
-  // First do XUL layout on our contents.
-  const nsSize preLayoutSize = GetSize();
-  XULLayout(aState);
-
-  // If the width or height changed, readjust the popup position. This is a
-  // special case for tooltips where the preferred height doesn't include the
-  // real height for its inline element, but does once it is laid out.
-  // This is bug 228673 which doesn't have a simple fix.
-  // FIXME(emilio): Unclear if this is still an issue with modern flex
-  // emulation. Perhaps we should try to remove this.
-  bool rePosition = shouldPosition && (mPosition == POPUPPOSITION_SELECTION);
-  const nsSize postLayoutSize = GetSize();
-  if (postLayoutSize.width > preLayoutSize.width ||
-      postLayoutSize.height > preLayoutSize.height) {
-    // the size after layout was larger than the preferred size, so set the
-    // preferred size accordingly.
-    mPrefSize = postLayoutSize;
-    if (isOpen) {
-      rePosition = true;
-      needCallback = true;
-    }
-  }
-
-  if (rePosition) {
-    SetPopupPosition(false);
-  }
-
-  nsPresContext* pc = PresContext();
   nsView* view = GetView();
-
-  if (sizeChanged) {
-    // If the size of the popup changed, apply any size constraints.
-    nsIWidget* widget = view->GetWidget();
-    if (widget) {
-      SetSizeConstraints(pc, widget, minSize, maxSize);
-    }
-  }
-
   if (isOpen) {
     nsViewManager* viewManager = view->GetViewManager();
-    nsRect rect = GetRect();
-    rect.x = rect.y = 0;
-    rect.SizeTo(XULBoundsCheck(minSize, rect.Size(), maxSize));
-    viewManager->ResizeView(view, rect);
-
+    viewManager->ResizeView(view,
+                            nsRect(nsPoint(), constraints.mUsedRect.Size()));
     if (mPopupState == ePopupOpening) {
       mPopupState = ePopupVisible;
     }
@@ -713,6 +630,9 @@ void nsMenuPopupFrame::LayoutPopup(nsBoxLayoutState& aState) {
     SyncFrameViewProperties(view);
   }
 
+  // Perform our move now. That will position the view and so on.
+  PerformMove(constraints);
+
   // finally, if the popup just opened, send a popupshown event
   bool openChanged = mIsOpenChanged;
   if (openChanged) {
@@ -729,31 +649,19 @@ void nsMenuPopupFrame::LayoutPopup(nsBoxLayoutState& aState) {
                                            eCaseMatters) &&
         AnimationUtils::HasCurrentTransitions(mContent->AsElement(),
                                               PseudoStyleType::NotPseudo)) {
-      mPopupShownDispatcher = new nsXULPopupShownEvent(mContent, pc);
+      mPopupShownDispatcher = new nsXULPopupShownEvent(mContent, aPresContext);
       mContent->AddSystemEventListener(u"transitionend"_ns,
                                        mPopupShownDispatcher, false, false);
       return;
     }
 
     // If there are no transitions, fire the popupshown event right away.
-    nsCOMPtr<nsIRunnable> event = new nsXULPopupShownEvent(GetContent(), pc);
+    nsCOMPtr<nsIRunnable> event =
+        new nsXULPopupShownEvent(GetContent(), aPresContext);
     mContent->OwnerDoc()->Dispatch(TaskCategory::Other, event.forget());
   }
-
-  if (needCallback && !mReflowCallbackData.mPosted) {
-    pc->PresShell()->PostReflowCallback(this);
-    mReflowCallbackData.MarkPosted(openChanged);
-  }
 }
 
-bool nsMenuPopupFrame::ReflowFinished() {
-  SetPopupPosition(false);
-  mReflowCallbackData.Clear();
-  return false;
-}
-
-void nsMenuPopupFrame::ReflowCallbackCanceled() { mReflowCallbackData.Clear(); }
-
 bool nsMenuPopupFrame::IsMenuList() const {
   return PopupElement().IsInMenuList();
 }
@@ -1138,13 +1046,9 @@ void nsMenuPopupFrame::HidePopup(bool aDeselectMenu, nsPopupState aNewState,
   popup->PopupClosed(aDeselectMenu);
 }
 
-nsIFrame::ReflowChildFlags nsMenuPopupFrame::GetXULLayoutFlags() {
-  return ReflowChildFlags::NoSizeView | ReflowChildFlags::NoMoveView;
-}
-
-nsPoint nsMenuPopupFrame::AdjustPositionForAnchorAlign(nsRect& anchorRect,
-                                                       FlipStyle& aHFlip,
-                                                       FlipStyle& aVFlip) {
+nsPoint nsMenuPopupFrame::AdjustPositionForAnchorAlign(
+    nsRect& anchorRect, const nsSize& aPrefSize, FlipStyle& aHFlip,
+    FlipStyle& aVFlip) const {
   // flip the anchor and alignment for right-to-left
   int8_t popupAnchor(mPopupAnchor);
   int8_t popupAlign(mPopupAlignment);
@@ -1203,13 +1107,14 @@ nsPoint nsMenuPopupFrame::AdjustPositionForAnchorAlign(nsRect& anchorRect,
   nsMargin margin = GetMargin();
   switch (popupAlign) {
     case POPUPALIGNMENT_TOPRIGHT:
-      pnt.MoveBy(-mRect.width - margin.right, margin.top);
+      pnt.MoveBy(-aPrefSize.width - margin.right, margin.top);
       break;
     case POPUPALIGNMENT_BOTTOMLEFT:
-      pnt.MoveBy(margin.left, -mRect.height - margin.bottom);
+      pnt.MoveBy(margin.left, -aPrefSize.height - margin.bottom);
       break;
     case POPUPALIGNMENT_BOTTOMRIGHT:
-      pnt.MoveBy(-mRect.width - margin.right, -mRect.height - margin.bottom);
+      pnt.MoveBy(-aPrefSize.width - margin.right,
+                 -aPrefSize.height - margin.bottom);
       break;
     case POPUPALIGNMENT_TOPLEFT:
     default:
@@ -1229,10 +1134,34 @@ nsPoint nsMenuPopupFrame::AdjustPositionForAnchorAlign(nsRect& anchorRect,
     // Only adjust the popup if it just opened, otherwise the popup will move
     // around if its gets resized or the selection changed. Cache the value in
     // mPositionedOffset and use that instead for any future calculations.
-    if (mIsOpenChanged || mReflowCallbackData.mIsOpenChanged) {
+    if (mIsOpenChanged) {
       if (nsIFrame* selectedItemFrame = GetSelectedItemForAlignment()) {
+        const nscoord itemHeight = selectedItemFrame->GetRect().height;
+        const nscoord itemOffset =
+            selectedItemFrame->GetOffsetToIgnoringScrolling(this).y;
+        // We want to line-up the anchor rect with the selected item, but if the
+        // selected item is outside of our bounds, we don't want to shift the
+        // popup up in a way that our box would no longer intersect with the
+        // anchor.
+        nscoord maxOffset = aPrefSize.height - itemHeight;
+        if (const nsIScrollableFrame* sf = GetScrollFrame()) {
+          // HACK: We ideally would want to use the offset from the bottom
+          // bottom of our scroll-frame to the bottom of our frame (so as to
+          // ensure that the bottom of the scrollport is inside the anchor
+          // rect).
+          //
+          // But at this point of the code, the scroll frame may not be laid out
+          // with a definite size (might be overflowing us).
+          //
+          // So, we assume the offset from the bottom is symmetric to the offset
+          // from the top. This holds for all the popups where this matters
+          // (menulists on macOS, effectively), and seems better than somehow
+          // moving the popup after the fact as we used to do.
+          const nsIFrame* f = do_QueryFrame(sf);
+          maxOffset -= f->GetOffsetTo(this).y;
+        }
         mPositionedOffset =
-            originalAnchorRect.height + selectedItemFrame->GetOffsetTo(this).y;
+            originalAnchorRect.height + std::min(itemOffset, maxOffset);
       }
     }
 
@@ -1281,7 +1210,7 @@ nsPoint nsMenuPopupFrame::AdjustPositionForAnchorAlign(nsRect& anchorRect,
   return pnt;
 }
 
-nsIFrame* nsMenuPopupFrame::GetSelectedItemForAlignment() {
+nsIFrame* nsMenuPopupFrame::GetSelectedItemForAlignment() const {
   // This method adjusts a menulist's popup such that the selected item is under
   // the cursor, aligned with the menulist label.
   nsCOMPtr<nsIDOMXULSelectControlElement> select;
@@ -1304,7 +1233,8 @@ nsIFrame* nsMenuPopupFrame::GetSelectedItemForAlignment() {
 
 nscoord nsMenuPopupFrame::SlideOrResize(nscoord& aScreenPoint, nscoord aSize,
                                         nscoord aScreenBegin,
-                                        nscoord aScreenEnd, nscoord* aOffset) {
+                                        nscoord aScreenEnd,
+                                        nscoord* aOffset) const {
   // The popup may be positioned such that either the left/top or bottom/right
   // is outside the screen - but never both.
   nscoord newPos =
@@ -1319,7 +1249,7 @@ nscoord nsMenuPopupFrame::FlipOrResize(nscoord& aScreenPoint, nscoord aSize,
                                        nscoord aAnchorBegin, nscoord aAnchorEnd,
                                        nscoord aMarginBegin, nscoord aMarginEnd,
                                        FlipStyle aFlip, bool aEndAligned,
-                                       bool* aFlipSide) {
+                                       bool* aFlipSide) const {
   // The flip side argument will be set to true if there wasn't room and we
   // flipped to the opposite side.
   *aFlipSide = false;
@@ -1421,7 +1351,7 @@ nscoord nsMenuPopupFrame::FlipOrResize(nscoord& aScreenPoint, nscoord aSize,
 }
 
 nsRect nsMenuPopupFrame::ComputeAnchorRect(nsPresContext* aRootPresContext,
-                                           nsIFrame* aAnchorFrame) {
+                                           nsIFrame* aAnchorFrame) const {
   // Get the root frame for a reference
   nsIFrame* rootFrame = aRootPresContext->PresShell()->GetRootFrame();
 
@@ -1456,68 +1386,20 @@ static nsIFrame* MaybeDelegatedAnchorFrame(nsIFrame* aFrame) {
   return aFrame;
 }
 
-nsresult nsMenuPopupFrame::SetPopupPosition(bool aIsMove) {
-  // If this is due to a move, return early if the popup hasn't been laid out
-  // yet. On Windows, this can happen when using a drag popup before it opens.
-  if (aIsMove && (mPrefSize.width == -1 || mPrefSize.height == -1)) {
-    return NS_OK;
+auto nsMenuPopupFrame::GetRects(const nsSize& aPrefSize) const -> Rects {
+  if (NS_WARN_IF(aPrefSize == nsSize(-1, -1))) {
+    // Return early if the popup hasn't been laid out yet. On Windows, this can
+    // happen when using a drag popup before it opens.
+    return {};
   }
 
-  nsPresContext* presContext = PresContext();
-  nsIFrame* rootFrame = presContext->PresShell()->GetRootFrame();
+  nsPresContext* pc = PresContext();
+  nsIFrame* rootFrame = pc->PresShell()->GetRootFrame();
   NS_ASSERTION(rootFrame->GetView() && GetView() &&
                    rootFrame->GetView() == GetView()->GetParent(),
                "rootFrame's view is not our view's parent???");
 
-  // For anchored popups, the anchor rectangle. For non-anchored popups, the
-  // size will be 0.
-  nsRect anchorRect;
-
-  bool anchored = IsAnchored();
-  if (anchored) {
-    // In order to deal with transforms, we need the root prescontext:
-    nsPresContext* rootPresContext = presContext->GetRootPresContext();
-
-    // If we can't reach a root pres context, don't bother continuing:
-    if (!rootPresContext) {
-      return NS_OK;
-    }
-
-    // If anchored to a rectangle, use that rectangle. Otherwise, determine the
-    // rectangle from the anchor.
-    if (mAnchorType == MenuPopupAnchorType_Rect) {
-      anchorRect = mScreenRect;
-    } else {
-      // if the frame is not specified, use the anchor node passed to OpenPopup.
-      // If that wasn't specified either, use the root frame. Note that
-      // mAnchorContent might be a different document so its presshell must be
-      // used.
-      nsIFrame* anchorFrame = GetAnchorFrame();
-      if (!anchorFrame) {
-        anchorFrame = rootFrame;
-        if (!anchorFrame) {
-          return NS_OK;
-        }
-      }
-
-      anchorRect = ComputeAnchorRect(rootPresContext, anchorFrame);
-    }
-  }
-
-  // Set the popup's size to the preferred size. Below, this size will be
-  // adjusted to fit on the screen or within the content area. If the anchor
-  // is sized to the popup, use the anchor's width instead of the preferred
-  // width. The preferred size should already be set by the parent frame.
-  {
-    NS_ASSERTION(mPrefSize.width >= 0 || mPrefSize.height >= 0,
-                 "preferred size of popup not set");
-    mRect.SizeTo(mPrefSize);
-  }
-
-  // the screen position in app units where the popup should appear
-  nsPoint screenPoint;
-
-  // indicators of whether the popup should be flipped or resized.
+  // Indicators of whether the popup should be flipped or resized.
   FlipStyle hFlip = FlipStyle_None, vFlip = FlipStyle_None;
 
   const nsMargin margin = GetMargin();
@@ -1525,10 +1407,41 @@ nsresult nsMenuPopupFrame::SetPopupPosition(bool aIsMove) {
   // the screen rectangle of the root frame, in dev pixels.
   nsRect rootScreenRect = rootFrame->GetScreenRectInAppUnits();
 
-  bool isNoAutoHide = IsNoAutoHide();
-  PopupLevel popupLevel = GetPopupLevel(isNoAutoHide);
+  const bool isNoAutoHide = IsNoAutoHide();
+  const PopupLevel popupLevel = GetPopupLevel(isNoAutoHide);
 
+  Rects result;
+
+  // Set the popup's size to the preferred size. Below, this size will be
+  // adjusted to fit on the screen or within the content area. If the anchor is
+  // sized to the popup, use the anchor's width instead of the preferred width.
+  result.mUsedRect = nsRect(nsPoint(), aPrefSize);
+
+  const bool anchored = IsAnchored();
   if (anchored) {
+    // In order to deal with transforms, we need the root prescontext:
+    nsPresContext* rootPc = pc->GetRootPresContext();
+    if (NS_WARN_IF(!rootPc)) {
+      // If we can't reach a root pres context, don't bother continuing.
+      return result;
+    }
+    // If anchored to a rectangle, use that rectangle. Otherwise, determine the
+    // rectangle from the anchor.
+    if (mAnchorType == MenuPopupAnchorType_Rect) {
+      result.mAnchorRect = mScreenRect;
+    } else {
+      // if the frame is not specified, use the anchor node passed to OpenPopup.
+      // If that wasn't specified either, use the root frame. Note that
+      // mAnchorContent might be a different document so its presshell must be
+      // used.
+      nsIFrame* anchorFrame = GetAnchorFrame();
+      if (!anchorFrame) {
+        result.mAnchorRect = result.mUntransformedAnchorRect = rootScreenRect;
+      } else {
+        result.mAnchorRect = result.mUntransformedAnchorRect =
+            ComputeAnchorRect(rootPc, anchorFrame);
+      }
+    }
     // if we are anchored, there are certain things we don't want to do when
     // repositioning the popup to fit on the screen, such as end up positioned
     // over the anchor, for instance a popup appearing over the menu label.
@@ -1540,17 +1453,12 @@ nsresult nsMenuPopupFrame::SetPopupPosition(bool aIsMove) {
       // tell us which axis the popup is flush against in case we have to move
       // it around later. The AdjustPositionForAnchorAlign method accounts for
       // the popup's margin.
-      if (!mPositionedByMoveToRect) {
-        mUntransformedAnchorRect = anchorRect;
-      }
-      screenPoint = AdjustPositionForAnchorAlign(anchorRect, hFlip, vFlip);
+      result.mUsedRect.MoveTo(AdjustPositionForAnchorAlign(
+          result.mAnchorRect, aPrefSize, hFlip, vFlip));
     } else {
-      // with no anchor, the popup is positioned relative to the root frame
-      anchorRect = rootScreenRect;
-      if (!mPositionedByMoveToRect) {
-        mUntransformedAnchorRect = anchorRect;
-      }
-      screenPoint = anchorRect.TopLeft() + nsPoint(margin.left, margin.top);
+      // With no anchor, the popup is positioned relative to the root frame.
+      result.mUsedRect.MoveTo(result.mAnchorRect.TopLeft() +
+                              nsPoint(margin.left, margin.top));
     }
 
     // mXPos and mYPos specify an additional offset passed to OpenPopup that
@@ -1558,47 +1466,28 @@ nsresult nsMenuPopupFrame::SetPopupPosition(bool aIsMove) {
     // pos so a later flip/resize takes the offset into account.
     // FIXME(emilio): Wayland doesn't seem to be accounting for this offset
     // anywhere, and it probably should.
-    nscoord anchorXOffset = CSSPixel::ToAppUnits(mXPos);
-    if (IsDirectionRTL()) {
-      screenPoint.x -= anchorXOffset;
-      anchorRect.x -= anchorXOffset;
-    } else {
-      screenPoint.x += anchorXOffset;
-      anchorRect.x += anchorXOffset;
-    }
-    nscoord anchorYOffset = CSSPixel::ToAppUnits(mYPos);
-    screenPoint.y += anchorYOffset;
-    anchorRect.y += anchorYOffset;
-
-    // If this is a noautohide popup, set the screen coordinates of the popup.
-    // This way, the popup stays at the location where it was opened even when
-    // the window is moved. Popups at the parent level follow the parent
-    // window as it is moved and remained anchored, so we want to maintain the
-    // anchoring instead.
-    if (isNoAutoHide && (popupLevel != PopupLevel::Parent ||
-                         mAnchorType == MenuPopupAnchorType_Rect)) {
-      // Account for the margin that will end up being added to the screen
-      // coordinate the next time SetPopupPosition is called.
-      mAnchorType = MenuPopupAnchorType_Point;
-      mScreenRect.x = screenPoint.x - margin.left;
-      mScreenRect.y = screenPoint.y - margin.top;
+    {
+      nsPoint offset(CSSPixel::ToAppUnits(mXPos), CSSPixel::ToAppUnits(mYPos));
+      if (IsDirectionRTL()) {
+        offset.x = -offset.x;
+      }
+      result.mUsedRect.MoveBy(offset);
+      result.mAnchorRect.MoveBy(offset);
     }
   } else {
-    screenPoint = mScreenRect.TopLeft();
-    anchorRect = nsRect(screenPoint, nsSize());
-    if (!mPositionedByMoveToRect) {
-      mUntransformedAnchorRect = anchorRect;
-    }
+    // Not anchored, use mScreenRect
+    result.mUsedRect.MoveTo(mScreenRect.TopLeft());
+    result.mAnchorRect = result.mUntransformedAnchorRect =
+        nsRect(mScreenRect.TopLeft(), nsSize());
 
     // Right-align RTL context menus, and apply margin and offsets as per the
     // platform conventions.
     if (mIsContextMenu && IsDirectionRTL()) {
-      screenPoint.x -= mRect.Width();
-      screenPoint.MoveBy(-margin.right, margin.top);
+      result.mUsedRect.x -= aPrefSize.Width();
+      result.mUsedRect.MoveBy(-margin.right, margin.top);
     } else {
-      screenPoint.MoveBy(margin.left, margin.top);
+      result.mUsedRect.MoveBy(margin.left, margin.top);
     }
-
 #ifdef XP_MACOSX
     // OSX tooltips follow standard flip rule but other popups flip horizontally
     // not vertically
@@ -1614,26 +1503,45 @@ nsresult nsMenuPopupFrame::SetPopupPosition(bool aIsMove) {
 #endif  // #ifdef XP_MACOSX
   }
 
-  nscoord oldAlignmentOffset = mAlignmentOffset;
+  const int32_t a2d = pc->AppUnitsPerDevPixel();
 
-  // If a panel is being moved or has flip="none", don't constrain or flip it,
-  // in order to avoid visual noise when moving windows between screens.
-  // However, if a panel is already constrained or flipped (mIsOffset), then we
-  // want to continue to calculate this. Also, always do this for content
-  // shells, so that the popup doesn't extend outside the containing frame.
-  if (!IS_WAYLAND_DISPLAY() &&
-      (mInContentShell ||
-       (mFlip != FlipType_None &&
-        (!aIsMove || mIsOffset || mPopupType != PopupType::Panel)))) {
+  nsView* view = GetView();
+  NS_ASSERTION(view, "popup with no view");
+
+  nsIWidget* widget = view->GetWidget();
+
+  // If a panel has flip="none", don't constrain or flip it.
+  // Also, always do this for content shells, so that the popup doesn't extend
+  // outside the containing frame.
+  if (IS_WAYLAND_DISPLAY()) {
+    if (widget) {
+      // Shrink the popup down if it's larger than popup size received from
+      // Wayland compositor. We don't know screen size on Wayland so this is the
+      // only info we have there.
+      const nsSize waylandSize = LayoutDeviceIntRect::ToAppUnits(
+          widget->GetMoveToRectPopupSize(), a2d);
+      if (waylandSize.width > 0 && result.mUsedRect.width > waylandSize.width) {
+        LOG_WAYLAND("Wayland constraint width [%p]:  %d to %d", widget,
+                    result.mUsedRect.width, waylandSize.width);
+        result.mUsedRect.width = waylandSize.width;
+      }
+      if (waylandSize.height > 0 &&
+          result.mUsedRect.height > waylandSize.height) {
+        LOG_WAYLAND("Wayland constraint height [%p]:  %d to %d", widget,
+                    result.mUsedRect.height, waylandSize.height);
+        result.mUsedRect.height = waylandSize.height;
+      }
+    }
+  } else if (mInContentShell || mFlip != FlipType_None) {
     const nsRect screenRect = [&] {
-      int32_t appPerDev = presContext->AppUnitsPerDevPixel();
       auto anchorRectDevPix =
-          LayoutDeviceIntRect::FromAppUnitsToNearest(anchorRect, appPerDev);
+          LayoutDeviceIntRect::FromAppUnitsToNearest(result.mAnchorRect, a2d);
       auto rootScreenRectDevPix =
-          LayoutDeviceIntRect::FromAppUnitsToNearest(rootScreenRect, appPerDev);
+          LayoutDeviceIntRect::FromAppUnitsToNearest(rootScreenRect, a2d);
       auto screenRectDevPix =
           GetConstraintRect(anchorRectDevPix, rootScreenRectDevPix, popupLevel);
-      nsRect sr = LayoutDeviceIntRect::ToAppUnits(screenRectDevPix, appPerDev);
+
+      nsRect sr = LayoutDeviceIntRect::ToAppUnits(screenRectDevPix, a2d);
 
       // Expand the allowable screen rect by the input margin (which can't be
       // interacted with).
@@ -1644,14 +1552,14 @@ nsresult nsMenuPopupFrame::SetPopupPosition(bool aIsMove) {
     }();
 
     // Ensure that anchorRect is on screen.
-    anchorRect = anchorRect.Intersect(screenRect);
+    result.mAnchorRect = result.mAnchorRect.Intersect(screenRect);
 
-    // Shrink the the popup down if it is larger than the screen size
-    if (mRect.width > screenRect.width) {
-      mRect.width = screenRect.width;
+    // Shrink the popup down if it is larger than the screen size
+    if (result.mUsedRect.width > screenRect.width) {
+      result.mUsedRect.width = screenRect.width;
     }
-    if (mRect.height > screenRect.height) {
-      mRect.height = screenRect.height;
+    if (result.mUsedRect.height > screenRect.height) {
+      result.mUsedRect.height = screenRect.height;
     }
 
     // At this point the anchor (anchorRect) is within the available screen
@@ -1673,84 +1581,142 @@ nsresult nsMenuPopupFrame::SetPopupPosition(bool aIsMove) {
     // Next, check if there is enough space to show the popup at full size
     // when positioned at screenPoint. If not, flip the popups to the opposite
     // side of their anchor point, or resize them as necessary.
-    const nsPoint preOffsetScreenPoint = screenPoint;
     if (slideHorizontal) {
-      mRect.width = SlideOrResize(screenPoint.x, mRect.width, screenRect.x,
-                                  screenRect.XMost(), &mAlignmentOffset);
+      result.mUsedRect.width = SlideOrResize(
+          result.mUsedRect.x, result.mUsedRect.width, screenRect.x,
+          screenRect.XMost(), &result.mAlignmentOffset);
     } else {
-      bool endAligned = IsDirectionRTL()
-                            ? mPopupAlignment == POPUPALIGNMENT_TOPLEFT ||
-                                  mPopupAlignment == POPUPALIGNMENT_BOTTOMLEFT
-                            : mPopupAlignment == POPUPALIGNMENT_TOPRIGHT ||
-                                  mPopupAlignment == POPUPALIGNMENT_BOTTOMRIGHT;
-      mRect.width =
-          FlipOrResize(screenPoint.x, mRect.width, screenRect.x,
-                       screenRect.XMost(), anchorRect.x, anchorRect.XMost(),
-                       margin.left, margin.right, hFlip, endAligned, &mHFlip);
+      const bool endAligned =
+          IsDirectionRTL() ? mPopupAlignment == POPUPALIGNMENT_TOPLEFT ||
+                                 mPopupAlignment == POPUPALIGNMENT_BOTTOMLEFT
+                           : mPopupAlignment == POPUPALIGNMENT_TOPRIGHT ||
+                                 mPopupAlignment == POPUPALIGNMENT_BOTTOMRIGHT;
+      result.mUsedRect.width = FlipOrResize(
+          result.mUsedRect.x, result.mUsedRect.width, screenRect.x,
+          screenRect.XMost(), result.mAnchorRect.x, result.mAnchorRect.XMost(),
+          margin.left, margin.right, hFlip, endAligned, &result.mHFlip);
     }
     if (slideVertical) {
-      mRect.height = SlideOrResize(screenPoint.y, mRect.height, screenRect.y,
-                                   screenRect.YMost(), &mAlignmentOffset);
+      result.mUsedRect.height = SlideOrResize(
+          result.mUsedRect.y, result.mUsedRect.height, screenRect.y,
+          screenRect.YMost(), &result.mAlignmentOffset);
     } else {
       bool endAligned = mPopupAlignment == POPUPALIGNMENT_BOTTOMLEFT ||
                         mPopupAlignment == POPUPALIGNMENT_BOTTOMRIGHT;
-      mRect.height =
-          FlipOrResize(screenPoint.y, mRect.height, screenRect.y,
-                       screenRect.YMost(), anchorRect.y, anchorRect.YMost(),
-                       margin.top, margin.bottom, vFlip, endAligned, &mVFlip);
+      result.mUsedRect.height = FlipOrResize(
+          result.mUsedRect.y, result.mUsedRect.height, screenRect.y,
+          screenRect.YMost(), result.mAnchorRect.y, result.mAnchorRect.YMost(),
+          margin.top, margin.bottom, vFlip, endAligned, &result.mVFlip);
     }
-    mIsOffset = preOffsetScreenPoint != screenPoint;
 
-    NS_ASSERTION(screenPoint.x >= screenRect.x, "Popup is offscreen (x start)");
-    NS_ASSERTION(screenPoint.y >= screenRect.y, "Popup is offscreen (y start)");
-    NS_ASSERTION(screenPoint.x + mRect.width <= screenRect.XMost(),
-                 "Popup is offscreen (x end)");
-    NS_ASSERTION(screenPoint.y + mRect.height <= screenRect.YMost(),
-                 "Popup is offscreen (y end)");
+#ifdef DEBUG
+    NS_ASSERTION(screenRect.Contains(result.mUsedRect), "Popup is offscreen");
+    if (!screenRect.Contains(result.mUsedRect)) {
+      NS_WARNING(nsPrintfCString("Popup is offscreen (%s vs. %s)",
+                                 ToString(screenRect).c_str(),
+                                 ToString(result.mUsedRect).c_str())
+                     .get());
+    }
+#endif
   }
-
-  // snap the popup's position in screen coordinates to device pixels,
-  // see bug 622507, bug 961431
-  screenPoint.x = presContext->RoundAppUnitsToNearestDevPixels(screenPoint.x);
-  screenPoint.y = presContext->RoundAppUnitsToNearestDevPixels(screenPoint.y);
+  // snap the popup's position in screen coordinates to device pixels, see
+  // bug 622507, bug 961431
+  result.mUsedRect.x = pc->RoundAppUnitsToNearestDevPixels(result.mUsedRect.x);
+  result.mUsedRect.y = pc->RoundAppUnitsToNearestDevPixels(result.mUsedRect.y);
 
   // determine the x and y position of the view by subtracting the desired
   // screen position from the screen position of the root frame.
-  nsPoint viewPoint = screenPoint - rootScreenRect.TopLeft();
-
-  nsView* view = GetView();
-  NS_ASSERTION(view, "popup with no view");
+  result.mViewPoint = result.mUsedRect.TopLeft() - rootScreenRect.TopLeft();
 
   // Offset the position by the width and height of the borders and titlebar.
-  // Even though GetClientOffset should return (0, 0) when there is no
-  // titlebar or borders, we skip these calculations anyway for non-panels
-  // to save time since they will never have a titlebar.
-  nsIWidget* widget = view->GetWidget();
+  // Even though GetClientOffset should return (0, 0) when there is no titlebar
+  // or borders, we skip these calculations anyway for non-panels to save time
+  // since they will never have a titlebar.
   if (mPopupType == PopupType::Panel && widget) {
-    mLastClientOffset = widget->GetClientOffset();
-    viewPoint.x += presContext->DevPixelsToAppUnits(mLastClientOffset.x);
-    viewPoint.y += presContext->DevPixelsToAppUnits(mLastClientOffset.y);
+    result.mClientOffset = widget->GetClientOffset();
+    result.mViewPoint +=
+        LayoutDeviceIntPoint::ToAppUnits(result.mClientOffset, a2d);
   }
 
-  presContext->GetPresShell()->GetViewManager()->MoveViewTo(view, viewPoint.x,
-                                                            viewPoint.y);
+  return result;
+}
+
+void nsMenuPopupFrame::SetPopupPosition(bool aIsMove) {
+  if (aIsMove && (mPrefSize.width == -1 || mPrefSize.height == -1)) {
+    return;
+  }
+
+  auto rects = GetRects(mPrefSize);
+  if (rects.mUsedRect.Size() != mRect.Size()) {
+    MOZ_ASSERT(!HasAnyStateBits(NS_FRAME_IN_REFLOW));
+    // We need to resize on top of moving, trigger an actual reflow.
+    PresShell()->FrameNeedsReflow(this, IntrinsicDirty::FrameAndAncestors,
+                                  NS_FRAME_IS_DIRTY);
+    return;
+  }
+  PerformMove(rects);
+}
+
+void nsMenuPopupFrame::PerformMove(const Rects& aRects) {
+  auto* ps = PresShell();
+
+  // We're just moving, sync frame position and offset as needed.
+  ps->GetViewManager()->MoveViewTo(GetView(), aRects.mViewPoint.x,
+                                   aRects.mViewPoint.y);
 
   // Now that we've positioned the view, sync up the frame's origin.
-  nsBoxFrame::SetPosition(viewPoint - GetParent()->GetOffsetTo(rootFrame));
+  nsBlockFrame::SetPosition(aRects.mViewPoint -
+                            GetParent()->GetOffsetTo(ps->GetRootFrame()));
 
   // If the popup is in the positioned state or if it is shown and the position
   // or size changed, dispatch a popuppositioned event if the popup wants it.
-  nsIntRect newRect(screenPoint.x, screenPoint.y, mRect.width, mRect.height);
   if (mPopupState == ePopupPositioning ||
-      (mPopupState == ePopupShown && !newRect.IsEqualEdges(mUsedScreenRect)) ||
-      (mPopupState == ePopupShown && oldAlignmentOffset != mAlignmentOffset)) {
-    mUsedScreenRect = newRect;
+      (mPopupState == ePopupShown &&
+       !aRects.mUsedRect.IsEqualEdges(mUsedScreenRect)) ||
+      (mPopupState == ePopupShown &&
+       aRects.mAlignmentOffset != mAlignmentOffset)) {
+    mUsedScreenRect = aRects.mUsedRect;
     if (!HasAnyStateBits(NS_FRAME_FIRST_REFLOW) && !mPendingPositionedEvent) {
       mPendingPositionedEvent =
           nsXULPopupPositionedEvent::DispatchIfNeeded(mContent);
     }
   }
 
+  if (!mPositionedByMoveToRect) {
+    mUntransformedAnchorRect = aRects.mUntransformedAnchorRect;
+  }
+
+  mAlignmentOffset = aRects.mAlignmentOffset;
+  mLastClientOffset = aRects.mClientOffset;
+  mHFlip = aRects.mHFlip;
+  mVFlip = aRects.mVFlip;
+
+  // If this is a noautohide popup, set the screen coordinates of the popup.
+  // This way, the popup stays at the location where it was opened even when the
+  // window is moved. Popups at the parent level follow the parent window as it
+  // is moved and remained anchored, so we want to maintain the anchoring
+  // instead.
+  const bool fixPosition = [&] {
+    if (IsNoAutoHide() && (GetPopupLevel() != PopupLevel::Parent ||
+                           mAnchorType == MenuPopupAnchorType_Rect)) {
+      return true;
+    }
+    // Don't reposition anchored popups that shouldn't follow the anchor.
+    if (IsAnchored() && !ShouldFollowAnchor() && !mUsedScreenRect.IsEmpty()) {
+      return true;
+    }
+    return false;
+  }();
+
+  if (fixPosition) {
+    // Account for the margin that will end up being added to the screen
+    // coordinate the next time SetPopupPosition is called.
+    const auto& margin = GetMargin();
+    mAnchorType = MenuPopupAnchorType_Point;
+    mScreenRect.x = aRects.mUsedRect.x - margin.left;
+    mScreenRect.y = aRects.mUsedRect.y - margin.top;
+  }
+
   // NOTE(emilio): This call below is kind of a workaround, but we need to do
   // this here because some position changes don't go through the
   // view system -> popup manager, like:
@@ -1765,8 +1731,6 @@ nsresult nsMenuPopupFrame::SetPopupPosition(bool aIsMove) {
   // usually don't have all that much content, this is probably an ok
   // workaround.
   WidgetPositionOrSizeDidChange();
-
-  return NS_OK;
 }
 
 void nsMenuPopupFrame::WidgetPositionOrSizeDidChange() {
@@ -1791,9 +1755,7 @@ void nsMenuPopupFrame::WidgetPositionOrSizeDidChange() {
 
 LayoutDeviceIntRect nsMenuPopupFrame::GetConstraintRect(
     const LayoutDeviceIntRect& aAnchorRect,
-    const LayoutDeviceIntRect& aRootScreenRect, PopupLevel aPopupLevel) {
-  LayoutDeviceIntRect screenRectPixels;
-
+    const LayoutDeviceIntRect& aRootScreenRect, PopupLevel aPopupLevel) const {
   // GetConstraintRect() does not work on Wayland as we can't get absolute
   // window position there.
   MOZ_ASSERT(!IS_WAYLAND_DISPLAY(),
@@ -1802,7 +1764,7 @@ LayoutDeviceIntRect nsMenuPopupFrame::GetConstraintRect(
   // determine the available screen space. It will be reduced by the OS chrome
   // such as menubars. It addition, for content shells, it will be the area of
   // the content rather than the screen.
-  nsCOMPtr<nsIScreen> screen;
+  LayoutDeviceIntRect screenRectPixels;
   nsCOMPtr<nsIScreenManager> sm(
       do_GetService("@mozilla.org/gfx/screenmanager;1"));
   if (sm) {
@@ -1816,18 +1778,18 @@ LayoutDeviceIntRect nsMenuPopupFrame::GetConstraintRect(
         (mInContentShell ? aRootScreenRect : aAnchorRect) / scale;
     int32_t width = std::max(1, NSToIntRound(rect.width));
     int32_t height = std::max(1, NSToIntRound(rect.height));
+    nsCOMPtr<nsIScreen> screen;
     sm->ScreenForRect(rect.x, rect.y, width, height, getter_AddRefs(screen));
     if (screen) {
-      // Non-top-level popups (which will always be panels)
-      // should never overlap the OS bar:
-      bool dontOverlapOSBar = aPopupLevel != PopupLevel::Top;
-      // get the total screen area if the popup is allowed to overlap it.
-      if (!dontOverlapOSBar && mMenuCanOverlapOSBar && !mInContentShell)
-        screen->GetRect(&screenRectPixels.x, &screenRectPixels.y,
-                        &screenRectPixels.width, &screenRectPixels.height);
-      else
-        screen->GetAvailRect(&screenRectPixels.x, &screenRectPixels.y,
-                             &screenRectPixels.width, &screenRectPixels.height);
+      // Non-top-level popups (which will always be panels) should never overlap
+      // the OS bar.
+      const bool canOverlapOSBar =
+          aPopupLevel == PopupLevel::Top &&
+          LookAndFeel::GetInt(LookAndFeel::IntID::MenusCanOverlapOSBar) &&
+          !mInContentShell;
+      // Get the total screen area if the popup is allowed to overlap it.
+      screenRectPixels =
+          canOverlapOSBar ? screen->GetRect() : screen->GetAvailRect();
     }
   }
 
@@ -1835,9 +1797,8 @@ LayoutDeviceIntRect nsMenuPopupFrame::GetConstraintRect(
     // for content shells, clip to the client area rather than the screen area
     screenRectPixels.IntersectRect(screenRectPixels, aRootScreenRect);
   } else if (!mOverrideConstraintRect.IsEmpty()) {
-    LayoutDeviceIntRect overrideConstrainRect =
-        LayoutDeviceIntRect::FromAppUnitsToNearest(
-            mOverrideConstraintRect, PresContext()->AppUnitsPerDevPixel());
+    auto overrideConstrainRect = LayoutDeviceIntRect::FromAppUnitsToNearest(
+        mOverrideConstraintRect, PresContext()->AppUnitsPerDevPixel());
     // This is currently only used for <select> elements where we want to
     // constrain vertically to the screen but not horizontally, so do the
     // intersection and then reset the horizontal values.
@@ -1849,38 +1810,6 @@ LayoutDeviceIntRect nsMenuPopupFrame::GetConstraintRect(
   return screenRectPixels;
 }
 
-void nsMenuPopupFrame::CanAdjustEdges(Side aHorizontalSide, Side aVerticalSide,
-                                      LayoutDeviceIntPoint& aChange) {
-  int8_t popupAlign(mPopupAlignment);
-  if (IsDirectionRTL()) {
-    popupAlign = -popupAlign;
-  }
-
-  if (aHorizontalSide == (mHFlip ? eSideRight : eSideLeft)) {
-    if (popupAlign == POPUPALIGNMENT_TOPLEFT ||
-        popupAlign == POPUPALIGNMENT_BOTTOMLEFT) {
-      aChange.x = 0;
-    }
-  } else if (aHorizontalSide == (mHFlip ? eSideLeft : eSideRight)) {
-    if (popupAlign == POPUPALIGNMENT_TOPRIGHT ||
-        popupAlign == POPUPALIGNMENT_BOTTOMRIGHT) {
-      aChange.x = 0;
-    }
-  }
-
-  if (aVerticalSide == (mVFlip ? eSideBottom : eSideTop)) {
-    if (popupAlign == POPUPALIGNMENT_TOPLEFT ||
-        popupAlign == POPUPALIGNMENT_TOPRIGHT) {
-      aChange.y = 0;
-    }
-  } else if (aVerticalSide == (mVFlip ? eSideTop : eSideBottom)) {
-    if (popupAlign == POPUPALIGNMENT_BOTTOMLEFT ||
-        popupAlign == POPUPALIGNMENT_BOTTOMRIGHT) {
-      aChange.y = 0;
-    }
-  }
-}
-
 ConsumeOutsideClicksResult nsMenuPopupFrame::ConsumeOutsideClicks() {
   if (mContent->AsElement()->AttrValueIs(kNameSpaceID_None,
                                          nsGkAtoms::consumeoutsideclicks,
@@ -1922,29 +1851,22 @@ ConsumeOutsideClicksResult nsMenuPopupFrame::ConsumeOutsideClicks() {
   return ConsumeOutsideClicks_True;
 }
 
+static nsIScrollableFrame* DoGetScrollFrame(const nsIFrame* aFrame) {
+  if (const nsIScrollableFrame* sf = do_QueryFrame(aFrame)) {
+    return const_cast<nsIScrollableFrame*>(sf);
+  }
+  for (nsIFrame* childFrame : aFrame->PrincipalChildList()) {
+    if (auto* sf = DoGetScrollFrame(childFrame)) {
+      return sf;
+    }
+  }
+  return nullptr;
+}
+
 // XXXroc this is megalame. Fossicking around for a frame of the right
 // type is a recipe for disaster in the long term.
-nsIScrollableFrame* nsMenuPopupFrame::GetScrollFrame(nsIFrame* aStart) {
-  if (!aStart) return nullptr;
-
-  // try start frame and siblings
-  nsIFrame* currFrame = aStart;
-  do {
-    nsIScrollableFrame* sf = do_QueryFrame(currFrame);
-    if (sf) return sf;
-    currFrame = currFrame->GetNextSibling();
-  } while (currFrame);
-
-  // try children
-  currFrame = aStart;
-  do {
-    nsIFrame* childFrame = currFrame->PrincipalChildList().FirstChild();
-    nsIScrollableFrame* sf = GetScrollFrame(childFrame);
-    if (sf) return sf;
-    currFrame = currFrame->GetNextSibling();
-  } while (currFrame);
-
-  return nullptr;
+nsIScrollableFrame* nsMenuPopupFrame::GetScrollFrame() const {
+  return DoGetScrollFrame(this);
 }
 
 void nsMenuPopupFrame::ChangeByPage(bool aIsUp) {
@@ -1953,7 +1875,7 @@ void nsMenuPopupFrame::ChangeByPage(bool aIsUp) {
     return;
   }
 
-  nsIScrollableFrame* scrollframe = GetScrollFrame(this);
+  nsIScrollableFrame* scrollframe = GetScrollFrame();
 
   RefPtr popup = &PopupElement();
   XULButtonElement* currentMenu = popup->GetActiveMenuChild();
@@ -2116,7 +2038,7 @@ nsresult nsMenuPopupFrame::AttributeChanged(int32_t aNameSpaceID,
 
 {
   nsresult rv =
-      nsBoxFrame::AttributeChanged(aNameSpaceID, aAttribute, aModType);
+      nsBlockFrame::AttributeChanged(aNameSpaceID, aAttribute, aModType);
 
   if (aAttribute == nsGkAtoms::left || aAttribute == nsGkAtoms::top) {
     MoveToAttributePosition();
@@ -2130,8 +2052,7 @@ nsresult nsMenuPopupFrame::AttributeChanged(int32_t aNameSpaceID,
   }
 
   if (aAttribute == nsGkAtoms::followanchor) {
-    nsXULPopupManager* pm = nsXULPopupManager::GetInstance();
-    if (pm) {
+    if (nsXULPopupManager* pm = nsXULPopupManager::GetInstance()) {
       pm->UpdateFollowAnchor(this);
     }
   }
@@ -2182,11 +2103,6 @@ void nsMenuPopupFrame::MoveToAttributePosition() {
 
 void nsMenuPopupFrame::DestroyFrom(nsIFrame* aDestructRoot,
                                    PostDestroyData& aPostDestroyData) {
-  if (mReflowCallbackData.mPosted) {
-    PresShell()->CancelReflowCallback(this);
-    mReflowCallbackData.Clear();
-  }
-
   // XXX: Currently we don't fire popuphidden for these popups, that seems wrong
   // but alas, also pre-existing.
   HidePopup(/* aDeselectMenu = */ false, ePopupClosed,
@@ -2196,7 +2112,7 @@ void nsMenuPopupFrame::DestroyFrom(nsIFrame* aDestructRoot,
     pm->PopupDestroyed(this);
   }
 
-  nsBoxFrame::DestroyFrom(aDestructRoot, aPostDestroyData);
+  nsBlockFrame::DestroyFrom(aDestructRoot, aPostDestroyData);
 }
 
 nsMargin nsMenuPopupFrame::GetMargin() const {
@@ -2236,7 +2152,7 @@ void nsMenuPopupFrame::MoveTo(const CSSPoint& aPos, bool aUpdateAttrs,
     appUnitsPos.y -= margin.top;
   }
 
-  if ((mScreenRect.x == appUnitsPos.x && mScreenRect.y == appUnitsPos.y) &&
+  if (mScreenRect.TopLeft() == appUnitsPos &&
       (!widget || widget->GetClientOffset() == mLastClientOffset)) {
     return;
   }
@@ -2366,7 +2282,7 @@ void nsMenuPopupFrame::CreatePopupView() {
       ("nsMenuPopupFrame::CreatePopupView: frame=%p view=%p", this, view));
 }
 
-bool nsMenuPopupFrame::ShouldFollowAnchor() {
+bool nsMenuPopupFrame::ShouldFollowAnchor() const {
   if (mAnchorType != MenuPopupAnchorType_Node || !mAnchorContent) {
     return false;
   }
diff --git a/layout/xul/nsMenuPopupFrame.h b/layout/xul/nsMenuPopupFrame.h
index c2ce54ff6c..9c42e7e741 100644
--- a/layout/xul/nsMenuPopupFrame.h
+++ b/layout/xul/nsMenuPopupFrame.h
@@ -19,10 +19,9 @@
 #include "nsGkAtoms.h"
 #include "nsCOMPtr.h"
 #include "nsIDOMEventListener.h"
-#include "nsIReflowCallback.h"
 #include "nsXULPopupManager.h"
 
-#include "nsBoxFrame.h"
+#include "nsBlockFrame.h"
 
 #include "Units.h"
 
@@ -130,7 +129,7 @@ class nsXULPopupShownEvent final : public mozilla::Runnable,
   const RefPtr<nsPresContext> mPresContext;
 };
 
-class nsMenuPopupFrame final : public nsBoxFrame, public nsIReflowCallback {
+class nsMenuPopupFrame final : public nsBlockFrame {
   using PopupLevel = mozilla::widget::PopupLevel;
   using PopupType = mozilla::widget::PopupType;
 
@@ -143,7 +142,7 @@ class nsMenuPopupFrame final : public nsBoxFrame, public nsIReflowCallback {
 
   // as popups are opened asynchronously, the popup pending state is used to
   // prevent multiple requests from attempting to open the same popup twice
-  nsPopupState PopupState() { return mPopupState; }
+  nsPopupState PopupState() const { return mPopupState; }
   void SetPopupState(nsPopupState);
 
   /*
@@ -166,6 +165,8 @@ class nsMenuPopupFrame final : public nsBoxFrame, public nsIReflowCallback {
 
   mozilla::dom::XULPopupElement& PopupElement() const;
 
+  nscoord GetPrefISize(gfxContext*) final;
+  nscoord GetMinISize(gfxContext*) final;
   void Reflow(nsPresContext* aPresContext, ReflowOutput& aDesiredSize,
               const ReflowInput& aReflowInput,
               nsReflowStatus& aStatus) override;
@@ -173,11 +174,11 @@ class nsMenuPopupFrame final : public nsBoxFrame, public nsIReflowCallback {
   nsIWidget* GetWidget() const;
 
   // Overridden methods
-  virtual void Init(nsIContent* aContent, nsContainerFrame* aParent,
-                    nsIFrame* aPrevInFlow) override;
+  void Init(nsIContent* aContent, nsContainerFrame* aParent,
+            nsIFrame* aPrevInFlow) override;
 
-  virtual nsresult AttributeChanged(int32_t aNameSpaceID, nsAtom* aAttribute,
-                                    int32_t aModType) override;
+  nsresult AttributeChanged(int32_t aNameSpaceID, nsAtom* aAttribute,
+                            int32_t aModType) override;
 
   // FIXME: This shouldn't run script (this can end up calling HidePopup).
   MOZ_CAN_RUN_SCRIPT_BOUNDARY void DestroyFrom(
@@ -211,13 +212,14 @@ class nsMenuPopupFrame final : public nsBoxFrame, public nsIReflowCallback {
 
   // layout, position and display the popup as needed
   MOZ_CAN_RUN_SCRIPT_BOUNDARY
-  void LayoutPopup(nsBoxLayoutState& aState);
+  void LayoutPopup(nsPresContext*, ReflowOutput&, const ReflowInput&,
+                   nsReflowStatus&);
 
   // Set the position of the popup relative to the anchor content, anchored at a
   // rectangle, or at a specific point if a screen position is set. The popup
   // will be adjusted so that it is on screen. If aIsMove is true, then the
   // popup is being moved, and should not be flipped.
-  nsresult SetPopupPosition(bool aIsMove);
+  void SetPopupPosition(bool aIsMove);
 
   // Called when the Enter key is pressed while the popup is open. This will
   // just pass the call down to the current menu, if any.
@@ -266,7 +268,7 @@ class nsMenuPopupFrame final : public nsBoxFrame, public nsIReflowCallback {
 
   // returns true if the popup is in a content shell, or false for a popup in
   // a chrome shell
-  bool IsInContentShell() { return mInContentShell; }
+  bool IsInContentShell() const { return mInContentShell; }
 
   // the Initialize methods are used to set the anchor position for
   // each way of opening a popup.
@@ -323,38 +325,46 @@ class nsMenuPopupFrame final : public nsBoxFrame, public nsIReflowCallback {
   void MoveToAnchor(nsIContent* aAnchorContent, const nsAString& aPosition,
                     int32_t aXPos, int32_t aYPos, bool aAttributesOverride);
 
-  nsIScrollableFrame* GetScrollFrame(nsIFrame* aStart);
+  nsIScrollableFrame* GetScrollFrame() const;
 
-  void SetOverrideConstraintRect(mozilla::LayoutDeviceIntRect aRect) {
-    mOverrideConstraintRect = ToAppUnits(aRect, mozilla::AppUnitsPerCSSPixel());
+  void SetOverrideConstraintRect(const mozilla::CSSIntRect& aRect) {
+    mOverrideConstraintRect = mozilla::CSSIntRect::ToAppUnits(aRect);
   }
 
-  // For a popup that should appear anchored at the given rect, determine
-  // the screen area that it is constrained by. This will be the available
-  // area of the screen the popup should be displayed on. Content popups,
-  // however, will also be constrained by the content area, given by
-  // aRootScreenRect. All coordinates are in app units.
+  struct Rects {
+    // For anchored popups, the anchor rectangle. For non-anchored popups, the
+    // size will be 0.
+    nsRect mAnchorRect;
+    // mAnchorRect before accounting for flipping / resizing / intersecting with
+    // the screen. This is needed for Wayland, which flips / resizes at the
+    // widget level.
+    nsRect mUntransformedAnchorRect;
+    // The final used rect we want to occupy.
+    nsRect mUsedRect;
+    // The alignment offset for sliding the panel, see
+    // nsMenuPopupFrame::mAlignmentOffset.
+    nscoord mAlignmentOffset = 0;
+    bool mHFlip = false;
+    bool mVFlip = false;
+    // The client offset of our widget.
+    mozilla::LayoutDeviceIntPoint mClientOffset;
+    nsPoint mViewPoint;
+  };
+
+  // For a popup that should appear anchored at the given rect, gets the anchor
+  // and constraint rects for that popup.
+  // This will be the available area of the screen the popup should be displayed
+  // on. Content popups, however, will also be constrained by the content area.
+  //
   // For non-toplevel popups (which will always be panels), we will also
   // constrain them to the available screen rect, ie they will not fall
   // underneath the taskbar, dock or other fixed OS elements.
-  // This operates in device pixels.
+  Rects GetRects(const nsSize& aPrefSize) const;
   mozilla::LayoutDeviceIntRect GetConstraintRect(
       const mozilla::LayoutDeviceIntRect& aAnchorRect,
       const mozilla::LayoutDeviceIntRect& aRootScreenRect,
-      PopupLevel aPopupLevel);
-
-  // Determines whether the given edges of the popup may be moved, where
-  // aHorizontalSide and aVerticalSide are one of the enum Side constants.
-  // aChange is the distance to move on those sides. If will be reset to 0
-  // if the side cannot be adjusted at all in that direction. For example, a
-  // popup cannot be moved if it is anchored on a particular side.
-  //
-  // Later, when bug 357725 is implemented, we can make this adjust aChange by
-  // the amount that the side can be resized, so that minimums and maximums
-  // can be taken into account.
-  void CanAdjustEdges(mozilla::Side aHorizontalSide,
-                      mozilla::Side aVerticalSide,
-                      mozilla::LayoutDeviceIntPoint& aChange);
+      PopupLevel aPopupLevel) const;
+  void PerformMove(const Rects&);
 
   // Return true if the popup is positioned relative to an anchor.
   bool IsAnchored() const { return mAnchorType != MenuPopupAnchorType_Point; }
@@ -401,18 +411,10 @@ class nsMenuPopupFrame final : public nsBoxFrame, public nsIReflowCallback {
 
   void WillDispatchPopupPositioned() { mPendingPositionedEvent = false; }
 
-  // nsIReflowCallback
-  virtual bool ReflowFinished() override;
-  virtual void ReflowCallbackCanceled() override;
-
  protected:
   // returns the popup's level.
   PopupLevel GetPopupLevel(bool aIsNoAutoHide) const;
-
-  void ConstrainSizeForWayland(nsSize&) const;
-
-  // redefine to tell the box system not to move the views.
-  ReflowChildFlags GetXULLayoutFlags() override;
+  void TweakMinPrefISize(nscoord&);
 
   void InitPositionFromAnchorAlign(const nsAString& aAnchor,
                                    const nsAString& aAlign);
@@ -420,12 +422,14 @@ class nsMenuPopupFrame final : public nsBoxFrame, public nsIReflowCallback {
   // return the position where the popup should be, when it should be
   // anchored at anchorRect. aHFlip and aVFlip will be set if the popup may be
   // flipped in that direction if there is not enough space available.
-  nsPoint AdjustPositionForAnchorAlign(nsRect& anchorRect, FlipStyle& aHFlip,
-                                       FlipStyle& aVFlip);
+  nsPoint AdjustPositionForAnchorAlign(nsRect& aAnchorRect,
+                                       const nsSize& aPrefSize,
+                                       FlipStyle& aHFlip,
+                                       FlipStyle& aVFlip) const;
 
   // For popups that are going to align to their selected item, get the frame of
   // the selected item.
-  nsIFrame* GetSelectedItemForAlignment();
+  nsIFrame* GetSelectedItemForAlignment() const;
 
   // check if the popup will fit into the available space and resize it. This
   // method handles only one axis at a time so is called twice, once for
@@ -445,7 +449,7 @@ class nsMenuPopupFrame final : public nsBoxFrame, public nsIReflowCallback {
                        nscoord aScreenBegin, nscoord aScreenEnd,
                        nscoord aAnchorBegin, nscoord aAnchorEnd,
                        nscoord aMarginBegin, nscoord aMarginEnd,
-                       FlipStyle aFlip, bool aIsOnEnd, bool* aFlipSide);
+                       FlipStyle aFlip, bool aIsOnEnd, bool* aFlipSide) const;
 
   // check if the popup can fit into the available space by "sliding" (i.e.,
   // by having the anchor arrow slide along one axis and only resizing if that
@@ -463,12 +467,12 @@ class nsMenuPopupFrame final : public nsBoxFrame, public nsIReflowCallback {
   // as aSize, unless aSize is greater than the screen width/height.
   nscoord SlideOrResize(nscoord& aScreenPoint, nscoord aSize,
                         nscoord aScreenBegin, nscoord aScreenEnd,
-                        nscoord* aOffset);
+                        nscoord* aOffset) const;
 
   // Given an anchor frame, compute the anchor rectangle relative to the screen,
   // using the popup frame's app units, and taking into account transforms.
   nsRect ComputeAnchorRect(nsPresContext* aRootPresContext,
-                           nsIFrame* aAnchorFrame);
+                           nsIFrame* aAnchorFrame) const;
 
   // Move the popup to the position specified in its |left| and |top|
   // attributes.
@@ -487,7 +491,7 @@ class nsMenuPopupFrame final : public nsBoxFrame, public nsIReflowCallback {
   // is no longer visible, or a parent deck page is changed, the popup hides
   // as well. The second variation also sets the anchor rectangle, relative to
   // the popup frame.
-  bool ShouldFollowAnchor();
+  bool ShouldFollowAnchor() const;
 
   nsIFrame* GetAnchorFrame() const;
 
@@ -533,24 +537,24 @@ class nsMenuPopupFrame final : public nsBoxFrame, public nsIReflowCallback {
   // was clicked. It will be cleared when the popup is hidden.
   nsCOMPtr<nsIContent> mTriggerContent;
 
-  nsView* mView;
+  nsView* mView = nullptr;
 
   RefPtr<nsXULPopupShownEvent> mPopupShownDispatcher;
 
   // The popup's screen rectangle in app units.
-  nsIntRect mUsedScreenRect;
+  nsRect mUsedScreenRect;
 
   // A popup's preferred size may be different than its actual size stored in
   // mRect in the case where the popup was resized because it was too large
   // for the screen. The preferred size mPrefSize holds the full size the popup
   // would be before resizing. Computations are performed using this size.
-  nsSize mPrefSize;
+  nsSize mPrefSize{-1, -1};
 
   // The position of the popup, in CSS pixels.
   // The screen coordinates, if set to values other than -1,
   // override mXPos and mYPos.
-  int32_t mXPos;
-  int32_t mYPos;
+  int32_t mXPos = 0;
+  int32_t mYPos = 0;
   nsRect mScreenRect;
   // Used for store rectangle which the popup is going to be anchored to, we
   // need that for Wayland. It's important that this rect is unflipped, and
@@ -558,60 +562,41 @@ class nsMenuPopupFrame final : public nsBoxFrame, public nsIReflowCallback {
   // flip etc. on Wayland.
   nsRect mUntransformedAnchorRect;
 
-  // Whether we were moved by the move-to-rect Wayland callback. In that case,
-  // we stop updating the anchor so that we can end up with a stable position.
-  bool mPositionedByMoveToRect = false;
-
   // If the panel prefers to "slide" rather than resize, then the arrow gets
   // positioned at this offset (along either the x or y axis, depending on
   // mPosition)
-  nscoord mAlignmentOffset;
+  nscoord mAlignmentOffset = 0;
 
   // The value of the client offset of our widget the last time we positioned
   // ourselves. We store this so that we can detect when it changes but the
   // position of our widget didn't change.
   mozilla::LayoutDeviceIntPoint mLastClientOffset;
 
-  PopupType mPopupType;      // type of popup
-  nsPopupState mPopupState;  // open state of the popup
+  PopupType mPopupType = PopupType::Panel;  // type of popup
+  nsPopupState mPopupState = ePopupClosed;  // open state of the popup
 
   // popup alignment relative to the anchor node
-  int8_t mPopupAlignment;
-  int8_t mPopupAnchor;
-  int8_t mPosition;
+  int8_t mPopupAlignment = POPUPALIGNMENT_NONE;
+  int8_t mPopupAnchor = POPUPALIGNMENT_NONE;
+  int8_t mPosition = POPUPPOSITION_UNKNOWN;
 
-  FlipType mFlip;  // Whether to flip
+  FlipType mFlip = FlipType_Default;  // Whether to flip
 
-  struct ReflowCallbackData {
-    ReflowCallbackData() = default;
-    void MarkPosted(bool aIsOpenChanged) {
-      mPosted = true;
-      mIsOpenChanged = aIsOpenChanged;
-    }
-    void Clear() {
-      mPosted = false;
-      mIsOpenChanged = false;
-    }
-    bool mPosted = false;
-    bool mIsOpenChanged = false;
-  };
-  ReflowCallbackData mReflowCallbackData;
+  // Whether we were moved by the move-to-rect Wayland callback. In that case,
+  // we stop updating the anchor so that we can end up with a stable position.
+  bool mPositionedByMoveToRect = false;
+  // true if the open state changed since the last layout.
+  bool mIsOpenChanged = false;
+  // true for context menus and their submenus.
+  bool mIsContextMenu = false;
+  // true for the topmost context menu.
+  bool mIsTopLevelContextMenu = false;
+  // true if the popup is in a content shell.
+  bool mInContentShell = true;
 
-  bool mIsOpenChanged;  // true if the open state changed since the last layout
-  bool mIsContextMenu = false;  // true for context menus and their submenus.
-  bool mIsTopLevelContextMenu = false;  // true for the topmost context menu.
-
-  bool mMenuCanOverlapOSBar;  // can we appear over the taskbar/menubar?
-  bool mInContentShell;       // True if the popup is in a content shell
-
-  // True if this popup has been offset due to moving off / near the edge of the
-  // screen. (This is useful for ensuring that a move, which can't offset the
-  // popup, doesn't undo a previously set offset.)
-  bool mIsOffset;
-
-  // the flip modes that were used when the popup was opened
-  bool mHFlip;
-  bool mVFlip;
+  // The flip modes that were used when the popup was opened
+  bool mHFlip = false;
+  bool mVFlip = false;
 
   // Whether the most recent initialization of this menupopup happened via
   // InitializePopupAsNativeContextMenu.
@@ -628,10 +613,11 @@ class nsMenuPopupFrame final : public nsBoxFrame, public nsIReflowCallback {
   // that the original selected item was. This needs to be used in case the
   // popup gets changed so that we can keep the popup at the same vertical
   // offset.
-  nscoord mPositionedOffset;
+  // TODO(emilio): try to make this not mutable.
+  mutable nscoord mPositionedOffset = 0;
 
   // How the popup is anchored.
-  MenuPopupAnchorType mAnchorType;
+  MenuPopupAnchorType mAnchorType = MenuPopupAnchorType_Node;
 
   nsRect mOverrideConstraintRect;
 
diff --git a/toolkit/content/tests/chrome/window_largemenu.xhtml b/toolkit/content/tests/chrome/window_largemenu.xhtml
index e0e31fcc07..d84b045e78 100644
--- a/toolkit/content/tests/chrome/window_largemenu.xhtml
+++ b/toolkit/content/tests/chrome/window_largemenu.xhtml
@@ -335,7 +335,8 @@ function testPopupMovement()
   var marginLeft = parseFloat(getComputedStyle(popup).marginLeft);
   var marginTop = parseFloat(getComputedStyle(popup).marginTop);
 
-  var overlapOSChrome = !platformIsMac();
+  var panelIsTop = SpecialPowers.getBoolPref("ui.panel.default_level_parent");
+  var overlapOSChrome = !platformIsMac() && (!isPanelTest || panelIsTop);
   popup.moveTo(1, 1);
   [screenX, screenY] = getScreenXY(popup);
 
@@ -348,28 +349,16 @@ function testPopupMovement()
   is(screenY, expectedy, gTests[gTestIndex] + " (1, 1) y");
 
   popup.moveTo(100, 8000);
-  if (isPanelTest) {
-    expectedy = 8000;
-  }
-  else {
-    expectedy = (overlapOSChrome ? screen.height + screen.top : screen.availHeight + screen.availTop) -
-                Math.round(rect.height) - marginBottom;
-  }
-
+  expectedy = (overlapOSChrome ? screen.height + screen.top : screen.availHeight + screen.availTop) -
+              Math.round(rect.height) - marginBottom;
   [screenX, screenY] = getScreenXY(popup);
   is(screenX, 100, gTests[gTestIndex] + " (100, 8000) x");
   is(screenY, expectedy, gTests[gTestIndex] + " (100, 8000) y");
 
   popup.moveTo(6000, 100);
 
-  if (isPanelTest) {
-    expectedx = 6000;
-  }
-  else {
-    expectedx = (overlapOSChrome ? screen.width + screen.left : screen.availWidth + screen.availLeft) -
+  expectedx = (overlapOSChrome ? screen.width + screen.left : screen.availWidth + screen.availLeft) -
                 Math.round(rect.width) - marginLeft;
-  }
-
   [screenX, screenY] = getScreenXY(popup);
   is(screenX, expectedx, gTests[gTestIndex] + " (6000, 100) x");
   is(screenY, 100, gTests[gTestIndex] + " (6000, 100) y");
diff --git a/toolkit/content/tests/chrome/window_panel_anchoradjust.xhtml b/toolkit/content/tests/chrome/window_panel_anchoradjust.xhtml
index 3ca9bdfc07..735ecf26b6 100644
--- a/toolkit/content/tests/chrome/window_panel_anchoradjust.xhtml
+++ b/toolkit/content/tests/chrome/window_panel_anchoradjust.xhtml
@@ -30,7 +30,7 @@
   <menuitem label="Three"/>
 </menupopup>
 
-<script type="application/javascript"><![CDATA[
+<script><![CDATA[
 
 
 SimpleTest.waitForExplicitFinish();
diff --git a/toolkit/content/xul.css b/toolkit/content/xul.css
index 7af73d05e5..e8c724b19d 100644
--- a/toolkit/content/xul.css
+++ b/toolkit/content/xul.css
@@ -363,6 +363,8 @@ panel,
 tooltip {
   position: fixed;
   -moz-top-layer: top;
+  width: fit-content;
+  height: fit-content;
   /* Popups can't have overflow */
   contain: paint;
   z-index: 2147483647;
@@ -374,7 +376,6 @@ tooltip {
   -moz-default-appearance: tooltip;
   -moz-font-smoothing-background-color: -moz-mac-tooltip;
 
-  -moz-box-orient: vertical;
   white-space: pre-wrap;
 
   background-color: InfoBackground;
diff --git a/toolkit/themes/linux/global/popup.css b/toolkit/themes/linux/global/popup.css
index 61483db4a2..a8b2240886 100644
--- a/toolkit/themes/linux/global/popup.css
+++ b/toolkit/themes/linux/global/popup.css
@@ -37,8 +37,7 @@ menupopup > menu > menupopup {
 }
 
 :is(panel, menupopup)::part(content) {
-  display: -moz-box;
-  -moz-box-flex: 1;
+  display: flex;
   padding: var(--panel-padding);
   color: var(--panel-color);
   background: var(--panel-background);
@@ -48,6 +47,10 @@ menupopup > menu > menupopup {
   min-width: 0;
   min-height: 0;
 
+  /* Makes popup constraints work */
+  max-height: calc(100% - 2 * var(--panel-shadow-margin));
+  max-width: calc(100% - 2 * var(--panel-shadow-margin));
+
   box-shadow: var(--panel-shadow);
   margin: var(--panel-shadow-margin);
 }
diff --git a/toolkit/themes/osx/global/popup.css b/toolkit/themes/osx/global/popup.css
index 7b8440490e..8f82b05fb3 100644
--- a/toolkit/themes/osx/global/popup.css
+++ b/toolkit/themes/osx/global/popup.css
@@ -45,18 +45,22 @@ panel[titlebar] {
 }
 
 :is(panel, menupopup)::part(content) {
-  display: -moz-box;
-  -moz-box-flex: 1;
+  display: flex;
   -moz-font-smoothing-background-color: var(--panel-background, -moz-mac-menupopup);
   background: var(--panel-background);
   color: var(--panel-color);
-  border-radius: var(--panel-border-radius);
   box-shadow: var(--panel-shadow);
   padding: var(--panel-padding);
   width: var(--panel-width);
+  border-radius: var(--panel-border-radius);
+  border: 1px solid var(--panel-border-color);
+
   min-width: 0;
   min-height: 0;
-  border: 1px solid var(--panel-border-color);
+
+  /* Makes popup constraints work */
+  max-height: calc(100% - 2 * var(--panel-shadow-margin));
+  max-width: calc(100% - 2 * var(--panel-shadow-margin));
 }
 
 :is(panel, menupopup)[orient=vertical]::part(content) {
diff --git a/toolkit/themes/windows/global/popup.css b/toolkit/themes/windows/global/popup.css
index e54ced7e9c..efb650197a 100644
--- a/toolkit/themes/windows/global/popup.css
+++ b/toolkit/themes/windows/global/popup.css
@@ -77,8 +77,7 @@ menupopup > menu > menupopup {
 }
 
 :is(panel, menupopup)::part(content) {
-  display: -moz-box;
-  -moz-box-flex: 1;
+  display: flex;
   padding: var(--panel-padding);
   margin: var(--panel-shadow-margin);
   box-shadow: var(--panel-shadow);
@@ -89,6 +88,10 @@ menupopup > menu > menupopup {
   width: var(--panel-width);
   min-width: 0;
   min-height: 0;
+
+  /* Makes popup constraints work */
+  max-height: calc(100% - 2 * var(--panel-shadow-margin));
+  max-width: calc(100% - 2 * var(--panel-shadow-margin));
 }
 
 :is(panel, menupopup)[orient=vertical]::part(content) {
diff --git a/widget/tests/test_panel_mouse_coords.xhtml b/widget/tests/test_panel_mouse_coords.xhtml
index 8d85a3196a..43c4e10249 100644
--- a/widget/tests/test_panel_mouse_coords.xhtml
+++ b/widget/tests/test_panel_mouse_coords.xhtml
@@ -13,7 +13,7 @@ https://bugzilla.mozilla.org/show_bug.cgi?id=835044
 <panel id="thepanel" level="parent"
        onpopupshown="sendMouseEvent();"
        onmousemove="checkCoords(event);"
-       width="80" height="80">
+       style="width: 80px; height: 80px">
 </panel>
 
   <!-- test results are displayed in the html:body -->
