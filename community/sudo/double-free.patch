Patch-Source: https://github.com/sudo-project/sudo/commit/87ce69246869d9b9d69be278e29e0fc6a3cabdb9
--
From 87ce69246869d9b9d69be278e29e0fc6a3cabdb9 Mon Sep 17 00:00:00 2001
From: "Todd C. Miller" <Todd.Miller@sudo.ws>
Date: Tue, 21 Feb 2023 20:01:13 -0700
Subject: [PATCH] Fix potential double free for rules that include a CHROOT=
 option. If a rule with a CHROOT= option matches the user, host and runas, the
 user_cmnd variable could be freed twice.

---
 MANIFEST                                      |  2 ++
 plugins/sudoers/match_command.c               |  6 +++++-
 plugins/sudoers/regress/fuzz/fuzz_sudoers.c   | 17 ++++++++++++----
 .../sudoers/regress/testsudoers/test20.out.ok | 15 ++++++++++++++
 plugins/sudoers/regress/testsudoers/test20.sh | 18 +++++++++++++++++
 plugins/sudoers/testsudoers.c                 | 20 ++++++++++++++-----
 plugins/sudoers/visudo.c                      |  4 +++-
 7 files changed, 71 insertions(+), 11 deletions(-)
 create mode 100644 plugins/sudoers/regress/testsudoers/test20.out.ok
 create mode 100644 plugins/sudoers/regress/testsudoers/test20.sh

diff --git a/plugins/sudoers/match_command.c b/plugins/sudoers/match_command.c
index 37d376d..bda7082 100644
--- a/plugins/sudoers/match_command.c
+++ b/plugins/sudoers/match_command.c
@@ -818,12 +818,16 @@ command_matches(const char *sudoers_cmnd, const char *sudoers_args,
 	/* Rule-specific runchroot, reset user_cmnd and user_stat. */
 	int status;
 
+	/* Save old user_cmnd first, set_cmnd_path() will free it. */
 	saved_user_cmnd = user_cmnd;
+	user_cmnd = NULL;
 	if (user_stat != NULL)
 	    saved_user_stat = *user_stat;
 	status = set_cmnd_path(runchroot);
-	if (status != FOUND)
+	if (status != FOUND) {
+	    user_cmnd = saved_user_cmnd;
 	    saved_user_cmnd = NULL;
+	}
 	if (info != NULL)
 	    info->status = status;
     }
diff --git a/plugins/sudoers/regress/fuzz/fuzz_sudoers.c b/plugins/sudoers/regress/fuzz/fuzz_sudoers.c
index 2ce2f87..6b8903f 100644
--- a/plugins/sudoers/regress/fuzz/fuzz_sudoers.c
+++ b/plugins/sudoers/regress/fuzz/fuzz_sudoers.c
@@ -45,6 +45,9 @@ static int fuzz_conversation(int num_msgs, const struct sudo_conv_message msgs[]
 static int fuzz_printf(int msg_type, const char *fmt, ...);
 int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size);
 
+/* For set_cmnd_path() */
+static const char *orig_cmnd;
+
 /* Required to link with parser. */
 struct sudo_user sudo_user;
 struct passwd *list_pw;
@@ -105,8 +108,13 @@ init_envtables(void)
 int
 set_cmnd_path(const char *runchroot)
 {
-    /* Cannot return FOUND without also setting user_cmnd to a new value. */
-    return NOT_FOUND;
+    /* Reallocate user_cmnd to catch bugs in command_matches(). */
+    char *new_cmnd = strdup(orig_cmnd);
+    if (new_cmnd == NULL)
+        return NOT_FOUND_ERROR;
+    free(user_cmnd);
+    user_cmnd = new_cmnd;
+    return FOUND;
 }
 
 /* STUB */
@@ -278,11 +286,12 @@ LLVMFuzzerTestOneInput(const uint8_t *data, size_t size)
 
     /* The minimum needed to perform matching (user_cmnd must be dynamic). */
     user_host = user_shost = user_runhost = user_srunhost = (char *)"localhost";
-    user_cmnd = strdup("/usr/bin/id");
+    orig_cmnd = (char *)"/usr/bin/id";
+    user_cmnd = strdup(orig_cmnd);
     if (user_cmnd == NULL)
 	goto done;
     user_args = (char *)"-u";
-    user_base = (char *)"id";
+    user_base = sudo_basename(user_cmnd);
 
     /* Add a fake network interfaces. */
     interfaces = get_interfaces();
diff --git a/plugins/sudoers/testsudoers.c b/plugins/sudoers/testsudoers.c
index 3af5636..2caf7cf 100644
--- a/plugins/sudoers/testsudoers.c
+++ b/plugins/sudoers/testsudoers.c
@@ -82,6 +82,7 @@ extern int (*trace_print)(const char *msg);
  */
 struct sudo_user sudo_user;
 struct passwd *list_pw;
+static const char *orig_cmnd;
 static char *runas_group, *runas_user;
 
 #if defined(SUDO_DEVEL) && defined(__OpenBSD__)
@@ -203,14 +204,18 @@ main(int argc, char *argv[])
 	if (!dflag)
 	    usage();
 	user_name = argc ? *argv++ : (char *)"root";
-	user_cmnd = user_base = (char *)"true";
+	orig_cmnd = "true";
 	argc = 0;
     } else {
 	user_name = *argv++;
-	user_cmnd = *argv++;
-	user_base = sudo_basename(user_cmnd);
+	orig_cmnd = *argv++;
 	argc -= 2;
     }
+    user_cmnd = strdup(orig_cmnd);
+    if (user_cmnd == NULL)
+	sudo_fatalx(U_("%s: %s"), __func__, U_("unable to allocate memory"));
+    user_base = sudo_basename(user_cmnd);
+
     if ((sudo_user.pw = sudo_getpwnam(user_name)) == NULL)
 	sudo_fatalx(U_("unknown user %s"), user_name);
 
@@ -509,8 +514,13 @@ init_eventlog_config(void)
 int
 set_cmnd_path(const char *runchroot)
 {
-    /* Cannot return FOUND without also setting user_cmnd to a new value. */
-    return NOT_FOUND;
+    /* Reallocate user_cmnd to catch bugs in command_matches(). */
+    char *new_cmnd = strdup(orig_cmnd);
+    if (new_cmnd == NULL)
+	return NOT_FOUND_ERROR;
+    free(user_cmnd);
+    user_cmnd = new_cmnd;
+    return FOUND;
 }
 
 static bool
diff --git a/plugins/sudoers/visudo.c b/plugins/sudoers/visudo.c
index 3f43382..ec8deab 100644
--- a/plugins/sudoers/visudo.c
+++ b/plugins/sudoers/visudo.c
@@ -260,7 +260,9 @@ main(int argc, char *argv[])
     }
 
     /* Mock up a fake sudo_user struct. */
-    user_cmnd = user_base = (char *)"";
+    user_cmnd = user_base = strdup("true");
+    if (user_cmnd == NULL)
+	sudo_fatalx(U_("%s: %s"), __func__, U_("unable to allocate memory"));
     if (geteuid() == 0) {
 	const char *user = getenv("SUDO_USER");
 	if (user != NULL && *user != '\0')
