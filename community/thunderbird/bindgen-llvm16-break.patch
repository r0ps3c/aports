Patch-Source: https://phabricator.services.mozilla.com/D178247
https://bugzilla.mozilla.org/show_bug.cgi?id=1831242
--
diff --git a/Cargo.lock b/Cargo.lock
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -392,12 +392,10 @@
 ]
 
 [[package]]
 name = "bindgen"
 version = "0.56.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "2da379dbebc0b76ef63ca68d8fc6e71c0f13e59432e0987e508c1820e6ab5239"
 dependencies = [
  "bitflags",
  "cexpr",
  "clang-sys",
  "lazy_static",
diff --git a/Cargo.toml b/Cargo.toml
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -104,10 +104,13 @@
 web-sys = { path = "build/rust/dummy-web/web-sys" }
 
 # Overrides to allow easier use of common internal crates.
 moz_asserts = { path = "mozglue/static/rust/moz_asserts" }
 
+# Patch bindgen to work around issues with some unsound transmutes when compiling with LLVM 16+.
+bindgen = { path = "third_party/rust/bindgen" }
+
 # Other overrides
 async-task = { git = "https://github.com/smol-rs/async-task", rev="f6488e35beccb26eb6e85847b02aa78a42cd3d0e" }
 chardetng = { git = "https://github.com/hsivonen/chardetng", rev="3484d3e3ebdc8931493aa5df4d7ee9360a90e76b" }
 chardetng_c = { git = "https://github.com/hsivonen/chardetng_c", rev="ed8a4c6f900a90d4dbc1d64b856e61490a1c3570" }
 coremidi = { git = "https://github.com/chris-zen/coremidi.git", rev="fc68464b5445caf111e41f643a2e69ccce0b4f83" }
diff --git a/third_party/rust/bindgen/src/codegen/mod.rs b/third_party/rust/bindgen/src/codegen/mod.rs
--- a/third_party/rust/bindgen/src/codegen/mod.rs
+++ b/third_party/rust/bindgen/src/codegen/mod.rs
@@ -109,11 +109,11 @@
         const PARTIAL_EQ  = 1 << 7;
         const EQ          = 1 << 8;
     }
 }
 
-fn derives_of_item(item: &Item, ctx: &BindgenContext) -> DerivableTraits {
+fn derives_of_item(item: &Item, ctx: &BindgenContext, forward_decl: bool) -> DerivableTraits {
     let mut derivable_traits = DerivableTraits::empty();
 
     if item.can_derive_debug(ctx) && !item.annotations().disallow_debug() {
         derivable_traits |= DerivableTraits::DEBUG;
     }
@@ -122,11 +122,11 @@
         derivable_traits |= DerivableTraits::DEFAULT;
     }
 
     let all_template_params = item.all_template_params(ctx);
 
-    if item.can_derive_copy(ctx) && !item.annotations().disallow_copy() {
+    if item.can_derive_copy(ctx) && !item.annotations().disallow_copy() && !forward_decl {
         derivable_traits |= DerivableTraits::COPY;
 
         if ctx.options().rust_features().builtin_clone_impls ||
             !all_template_params.is_empty()
         {
@@ -889,11 +889,11 @@
                             alias_style
                         );
 
                         let mut attributes =
                             vec![attributes::repr("transparent")];
-                        let derivable_traits = derives_of_item(item, ctx);
+                        let derivable_traits = derives_of_item(item, ctx, false);
                         if !derivable_traits.is_empty() {
                             let derives: Vec<_> = derivable_traits.into();
                             attributes.push(attributes::derives(&derives))
                         }
 
@@ -1811,12 +1811,13 @@
         // Just get the layout, and assume C++ if not.
         //
         // NOTE: This check is conveniently here to avoid the dummy fields we
         // may add for unused template parameters.
         if self.is_forward_declaration() {
+            let prefix = ctx.trait_prefix();
             fields.push(quote! {
-                _unused: [u8; 0],
+                _unused: ::#prefix::cell::UnsafeCell<[u8; 0]>,
             });
         } else if item.is_zero_sized(ctx) {
             let has_address = if is_opaque {
                 // Generate the address field if it's an opaque type and
                 // couldn't determine the layout of the blob.
@@ -1889,11 +1890,11 @@
                     #[repr(align(#explicit))]
                 });
             }
         }
 
-        let derivable_traits = derives_of_item(item, ctx);
+        let derivable_traits = derives_of_item(item, ctx, self.is_forward_declaration());
         if !derivable_traits.contains(DerivableTraits::DEBUG) {
             needs_debug_impl = ctx.options().derive_debug &&
                 ctx.options().impl_debug &&
                 !ctx.no_debug_by_name(item) &&
                 !item.annotations().disallow_debug();
@@ -2848,11 +2849,11 @@
         if let Some(comment) = item.comment(ctx) {
             attrs.push(attributes::doc(comment));
         }
 
         if !variation.is_const() {
-            let mut derives = derives_of_item(item, ctx);
+            let mut derives = derives_of_item(item, ctx, false);
             // For backwards compat, enums always derive Clone/Eq/PartialEq/Hash, even
             // if we don't generate those by default.
             derives.insert(
                 DerivableTraits::CLONE |
                     DerivableTraits::COPY |

