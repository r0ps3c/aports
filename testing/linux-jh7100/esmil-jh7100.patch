From 6a95dfda8e032015c20ceb3ddfe47e60f73b8149 Mon Sep 17 00:00:00 2001
From: William Qiu <william.qiu@starfivetech.com>
Date: Mon, 6 Jan 2025 18:35:40 +0800
Subject: [PATCH 02/31] pwm: opencores: Add PWM driver support

Add driver for OpenCores PWM Controller. And add compatibility code
which based on StarFive SoC.

Co-developed-by: Hal Feng <hal.feng@starfivetech.com>
Signed-off-by: Hal Feng <hal.feng@starfivetech.com>
Signed-off-by: William Qiu <william.qiu@starfivetech.com>
Tested-by: Maud Spierings <maud_spierings@hotmail.com>
Link: https://lore.kernel.org/r/20250106103540.10079-1-william.qiu@starfivetech.com
Signed-off-by: Emil Renner Berthing <emil.renner.berthing@canonical.com>
---
 MAINTAINERS              |   7 ++
 drivers/pwm/Kconfig      |  12 ++
 drivers/pwm/Makefile     |   1 +
 drivers/pwm/pwm-ocores.c | 238 +++++++++++++++++++++++++++++++++++++++
 4 files changed, 258 insertions(+)
 create mode 100644 drivers/pwm/pwm-ocores.c

diff --git a/MAINTAINERS b/MAINTAINERS
index efee40ea58..f398bfae65 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -17731,6 +17731,13 @@ F:	Documentation/i2c/busses/i2c-ocores.rst
 F:	drivers/i2c/busses/i2c-ocores.c
 F:	include/linux/platform_data/i2c-ocores.h
 
+OPENCORES PWM DRIVER
+M:	William Qiu <william.qiu@starfivetech.com>
+M:	Hal Feng <hal.feng@starfivetech.com>
+S:	Supported
+F:	Documentation/devicetree/bindings/pwm/opencores,pwm.yaml
+F:	drivers/pwm/pwm-ocores.c
+
 OPENRISC ARCHITECTURE
 M:	Jonas Bonn <jonas@southpole.se>
 M:	Stefan Kristiansson <stefan.kristiansson@saunalahti.fi>
diff --git a/drivers/pwm/Kconfig b/drivers/pwm/Kconfig
index 0915c1e7df..33819cb585 100644
--- a/drivers/pwm/Kconfig
+++ b/drivers/pwm/Kconfig
@@ -471,6 +471,18 @@ config PWM_NTXEC
 	  controller found in certain e-book readers designed by the original
 	  design manufacturer Netronix.
 
+config PWM_OCORES
+	tristate "OpenCores PTC PWM support"
+	depends on HAS_IOMEM && OF
+	depends on COMMON_CLK
+	depends on ARCH_STARFIVE || COMPILE_TEST
+	help
+	  If you say yes to this option, support will be included for the
+	  OpenCores PWM. For details see https://opencores.org/projects/ptc.
+
+	  To compile this driver as a module, choose M here: the module
+	  will be called pwm-ocores.
+
 config PWM_OMAP_DMTIMER
 	tristate "OMAP Dual-Mode Timer PWM support"
 	depends on OF
diff --git a/drivers/pwm/Makefile b/drivers/pwm/Makefile
index 9081e0c0e9..e55997490d 100644
--- a/drivers/pwm/Makefile
+++ b/drivers/pwm/Makefile
@@ -42,6 +42,7 @@ obj-$(CONFIG_PWM_MICROCHIP_CORE)	+= pwm-microchip-core.o
 obj-$(CONFIG_PWM_MTK_DISP)	+= pwm-mtk-disp.o
 obj-$(CONFIG_PWM_MXS)		+= pwm-mxs.o
 obj-$(CONFIG_PWM_NTXEC)		+= pwm-ntxec.o
+obj-$(CONFIG_PWM_OCORES)	+= pwm-ocores.o
 obj-$(CONFIG_PWM_OMAP_DMTIMER)	+= pwm-omap-dmtimer.o
 obj-$(CONFIG_PWM_PCA9685)	+= pwm-pca9685.o
 obj-$(CONFIG_PWM_PXA)		+= pwm-pxa.o
diff --git a/drivers/pwm/pwm-ocores.c b/drivers/pwm/pwm-ocores.c
new file mode 100644
index 0000000000..bc95783001
--- /dev/null
+++ b/drivers/pwm/pwm-ocores.c
@@ -0,0 +1,238 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * OpenCores PWM Driver
+ *
+ * https://opencores.org/projects/ptc
+ *
+ * Copyright (C) 2018-2023 StarFive Technology Co., Ltd.
+ *
+ * Limitations:
+ * - The hardware only supports inverted polarity.
+ * - The hardware minimum period / duty_cycle is (1 / pwm_apb clock frequency).
+ * - The hardware maximum period / duty_cycle is (U32_MAX / pwm_apb clock frequency).
+ * - The output is set to a low level immediately when disabled.
+ * - When configuration changes are done, they get active immediately without resetting
+ *   the counter. This might result in one period affected by both old and new settings.
+ */
+
+#include <linux/clk.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/pwm.h>
+#include <linux/reset.h>
+#include <linux/slab.h>
+
+/* OpenCores Register offsets */
+#define REG_OCPWM_CNTR    0x0
+#define REG_OCPWM_HRC     0x4
+#define REG_OCPWM_LRC     0x8
+#define REG_OCPWM_CTRL    0xC
+
+/* OCPWM_CTRL register bits*/
+#define REG_OCPWM_CNTR_EN      BIT(0)
+#define REG_OCPWM_CNTR_ECLK    BIT(1)
+#define REG_OCPWM_CNTR_NEC     BIT(2)
+#define REG_OCPWM_CNTR_OE      BIT(3)
+#define REG_OCPWM_CNTR_SIGNLE  BIT(4)
+#define REG_OCPWM_CNTR_INTE    BIT(5)
+#define REG_OCPWM_CNTR_INT     BIT(6)
+#define REG_OCPWM_CNTR_RST     BIT(7)
+#define REG_OCPWM_CNTR_CAPTE   BIT(8)
+
+struct ocores_pwm_data {
+	void __iomem *(*get_ch_base)(void __iomem *base, unsigned int channel);
+};
+
+struct ocores_pwm_device {
+	const struct ocores_pwm_data *data;
+	void __iomem *regs;
+	u32 clk_rate; /* PWM APB clock frequency */
+};
+
+static inline u32 ocores_pwm_readl(struct ocores_pwm_device *ddata,
+				   unsigned int channel,
+				   unsigned int offset)
+{
+	void __iomem *base = ddata->data->get_ch_base ?
+			     ddata->data->get_ch_base(ddata->regs, channel) : ddata->regs;
+
+	return readl(base + offset);
+}
+
+static inline void ocores_pwm_writel(struct ocores_pwm_device *ddata,
+				     unsigned int channel,
+				     unsigned int offset, u32 val)
+{
+	void __iomem *base = ddata->data->get_ch_base ?
+			     ddata->data->get_ch_base(ddata->regs, channel) : ddata->regs;
+
+	writel(val, base + offset);
+}
+
+static inline struct ocores_pwm_device *chip_to_ocores(struct pwm_chip *chip)
+{
+	return pwmchip_get_drvdata(chip);
+}
+
+static void __iomem *ocores_pwm_get_ch_base(void __iomem *base,
+					    unsigned int channel)
+{
+	unsigned int offset = (channel & 4) << 13 | (channel & 3) << 4;
+
+	return base + offset;
+}
+
+static int ocores_pwm_get_state(struct pwm_chip *chip,
+				struct pwm_device *pwm,
+				struct pwm_state *state)
+{
+	struct ocores_pwm_device *ddata = chip_to_ocores(chip);
+	u32 period_data, duty_data, ctrl_data;
+
+	period_data = ocores_pwm_readl(ddata, pwm->hwpwm, REG_OCPWM_LRC);
+	duty_data = ocores_pwm_readl(ddata, pwm->hwpwm, REG_OCPWM_HRC);
+	ctrl_data = ocores_pwm_readl(ddata, pwm->hwpwm, REG_OCPWM_CTRL);
+
+	state->period = DIV_ROUND_UP_ULL((u64)period_data * NSEC_PER_SEC, ddata->clk_rate);
+	state->duty_cycle = DIV_ROUND_UP_ULL((u64)duty_data * NSEC_PER_SEC, ddata->clk_rate);
+	state->polarity = PWM_POLARITY_INVERSED;
+	state->enabled = (ctrl_data & REG_OCPWM_CNTR_EN) ? true : false;
+
+	return 0;
+}
+
+static int ocores_pwm_apply(struct pwm_chip *chip,
+			    struct pwm_device *pwm,
+			    const struct pwm_state *state)
+{
+	struct ocores_pwm_device *ddata = chip_to_ocores(chip);
+	u32 ctrl_data = 0;
+	u64 period_data, duty_data;
+
+	if (state->polarity != PWM_POLARITY_INVERSED)
+		return -EINVAL;
+
+	period_data = mul_u64_u32_div(state->period, ddata->clk_rate, NSEC_PER_SEC);
+	if (!period_data)
+		return -EINVAL;
+
+	if (period_data > U32_MAX)
+		period_data = U32_MAX;
+
+	ocores_pwm_writel(ddata, pwm->hwpwm, REG_OCPWM_LRC, period_data);
+
+	duty_data = mul_u64_u32_div(state->duty_cycle, ddata->clk_rate, NSEC_PER_SEC);
+	if (duty_data > U32_MAX)
+		duty_data = U32_MAX;
+
+	ocores_pwm_writel(ddata, pwm->hwpwm, REG_OCPWM_HRC, duty_data);
+
+	ctrl_data = ocores_pwm_readl(ddata, pwm->hwpwm, REG_OCPWM_CTRL);
+	if (state->enabled)
+		ocores_pwm_writel(ddata, pwm->hwpwm, REG_OCPWM_CTRL,
+				  ctrl_data | REG_OCPWM_CNTR_EN | REG_OCPWM_CNTR_OE);
+	else
+		ocores_pwm_writel(ddata, pwm->hwpwm, REG_OCPWM_CTRL,
+				  ctrl_data & ~(REG_OCPWM_CNTR_EN | REG_OCPWM_CNTR_OE));
+
+	return 0;
+}
+
+static const struct pwm_ops ocores_pwm_ops = {
+	.get_state = ocores_pwm_get_state,
+	.apply = ocores_pwm_apply,
+};
+
+static const struct ocores_pwm_data starfive_pwm_data = {
+	.get_ch_base = ocores_pwm_get_ch_base,
+};
+
+static const struct of_device_id ocores_pwm_of_match[] = {
+	{ .compatible = "opencores,pwm-v1" },
+	{ .compatible = "starfive,jh7100-pwm", .data = &starfive_pwm_data},
+	{ .compatible = "starfive,jh7110-pwm", .data = &starfive_pwm_data},
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, ocores_pwm_of_match);
+
+static void ocores_pwm_reset_control_assert(void *data)
+{
+	reset_control_assert(data);
+}
+
+static int ocores_pwm_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct ocores_pwm_device *ddata;
+	struct pwm_chip *chip;
+	struct clk *clk;
+	struct reset_control *rst;
+	int ret;
+
+	chip = devm_pwmchip_alloc(&pdev->dev, 8, sizeof(*ddata));
+	if (IS_ERR(chip))
+		return -ENOMEM;
+
+	ddata = chip_to_ocores(chip);
+	ddata->data = device_get_match_data(&pdev->dev);
+	chip->ops = &ocores_pwm_ops;
+
+	ddata->regs = devm_platform_ioremap_resource(pdev, 0);
+	if (IS_ERR(ddata->regs))
+		return dev_err_probe(dev, PTR_ERR(ddata->regs),
+				     "Failed to map IO resources\n");
+
+	clk = devm_clk_get_enabled(dev, NULL);
+	if (IS_ERR(clk))
+		return dev_err_probe(dev, PTR_ERR(clk),
+				     "Failed to get pwm's clock\n");
+
+	ret = devm_clk_rate_exclusive_get(dev, clk);
+	if (ret)
+		return dev_err_probe(dev, ret,
+				     "Failed to lock clock rate\n");
+
+	rst = devm_reset_control_get_optional_exclusive(dev, NULL);
+	if (IS_ERR(rst))
+		return dev_err_probe(dev, PTR_ERR(rst),
+				     "Failed to get pwm's reset\n");
+
+	ret = reset_control_deassert(rst);
+	if (ret) {
+		dev_err(dev, "Failed to deassert pwm's reset\n");
+		return ret;
+	}
+
+	ret = devm_add_action_or_reset(dev, ocores_pwm_reset_control_assert, rst);
+	if (ret) {
+		dev_err(dev, "Failed to register assert devm action\n");
+		return ret;
+	}
+
+	ddata->clk_rate = clk_get_rate(clk);
+	if (ddata->clk_rate > NSEC_PER_SEC) {
+		dev_err(dev, "Failed to get clock frequency\n");
+		return -EINVAL;
+	}
+
+	ret = devm_pwmchip_add(dev, chip);
+	if (ret < 0)
+		return dev_err_probe(dev, ret, "Could not register PWM chip\n");
+
+	return 0;
+}
+
+static struct platform_driver ocores_pwm_driver = {
+	.probe = ocores_pwm_probe,
+	.driver = {
+		.name = "ocores-pwm",
+		.of_match_table = ocores_pwm_of_match,
+	},
+};
+module_platform_driver(ocores_pwm_driver);
+
+MODULE_AUTHOR("Jieqin Chen");
+MODULE_AUTHOR("Hal Feng <hal.feng@starfivetech.com>");
+MODULE_DESCRIPTION("OpenCores PTC PWM driver");
+MODULE_LICENSE("GPL");
-- 
2.49.0


From 1ba1f551aa9fe0bd84cbb637c452f8a4c38b29f1 Mon Sep 17 00:00:00 2001
From: Emil Renner Berthing <kernel@esmil.dk>
Date: Sun, 31 Oct 2021 17:15:58 +0100
Subject: [PATCH 03/31] riscv: dts: starfive: Add JH7100 high speed UARTs

Add missing device tree nodes for UART0 and UART1 on the StarFive JH7100
SoC. UART0 is used for Bluetooth on the BeagleV Starlight and StarFive
VisionFive V1 boards.

Signed-off-by: Emil Renner Berthing <kernel@esmil.dk>
---
 arch/riscv/boot/dts/starfive/jh7100.dtsi | 26 ++++++++++++++++++++++++
 1 file changed, 26 insertions(+)

diff --git a/arch/riscv/boot/dts/starfive/jh7100.dtsi b/arch/riscv/boot/dts/starfive/jh7100.dtsi
index 7de0732b8e..aecb73d25a 100644
--- a/arch/riscv/boot/dts/starfive/jh7100.dtsi
+++ b/arch/riscv/boot/dts/starfive/jh7100.dtsi
@@ -258,6 +258,32 @@ sysmain: syscon@11850000 {
 			reg = <0x0 0x11850000 0x0 0x10000>;
 		};
 
+		uart0: serial@11870000 {
+			compatible = "starfive,jh7100-hsuart", "snps,dw-apb-uart";
+			reg = <0x0 0x11870000 0x0 0x10000>;
+			clocks = <&clkgen JH7100_CLK_UART0_CORE>,
+				 <&clkgen JH7100_CLK_UART0_APB>;
+			clock-names = "baudclk", "apb_pclk";
+			resets = <&rstgen JH7100_RSTN_UART0_APB>;
+			interrupts = <92>;
+			reg-io-width = <4>;
+			reg-shift = <2>;
+			status = "disabled";
+		};
+
+		uart1: serial@11880000 {
+			compatible = "starfive,jh7100-hsuart", "snps,dw-apb-uart";
+			reg = <0x0 0x11880000 0x0 0x10000>;
+			clocks = <&clkgen JH7100_CLK_UART1_CORE>,
+				 <&clkgen JH7100_CLK_UART1_APB>;
+			clock-names = "baudclk", "apb_pclk";
+			resets = <&rstgen JH7100_RSTN_UART1_APB>;
+			interrupts = <93>;
+			reg-io-width = <4>;
+			reg-shift = <2>;
+			status = "disabled";
+		};
+
 		i2c0: i2c@118b0000 {
 			compatible = "snps,designware-i2c";
 			reg = <0x0 0x118b0000 0x0 0x10000>;
-- 
2.49.0


From d0816d175340d715842b507690551ed3d2fa3249 Mon Sep 17 00:00:00 2001
From: Emil Renner Berthing <kernel@esmil.dk>
Date: Mon, 13 Sep 2021 01:18:01 +0200
Subject: [PATCH 04/31] riscv: dts: starfive: Enable Bluetooth on JH7100 boards

Add pinctrl and UART nodes for the Broadcom Wifi/Bluetooth module on the
BeagleV Starlight and StarFive VisionFive V1 boards.

Signed-off-by: Emil Renner Berthing <kernel@esmil.dk>
---
 .../boot/dts/starfive/jh7100-common.dtsi      | 49 +++++++++++++++++++
 1 file changed, 49 insertions(+)

diff --git a/arch/riscv/boot/dts/starfive/jh7100-common.dtsi b/arch/riscv/boot/dts/starfive/jh7100-common.dtsi
index ae1a6aeb0a..1f79481bfd 100644
--- a/arch/riscv/boot/dts/starfive/jh7100-common.dtsi
+++ b/arch/riscv/boot/dts/starfive/jh7100-common.dtsi
@@ -289,6 +289,41 @@ GPO_SDIO1_PAD_CDATA_OEN_BIT3,
 		};
 	};
 
+	uart0_pins: uart0-0 {
+		rx-pins {
+			pinmux = <GPIOMUX(40, GPO_LOW, GPO_DISABLE,
+				  GPI_UART0_PAD_SIN)>;
+			bias-pull-up;
+			drive-strength = <14>;
+			input-enable;
+			input-schmitt-enable;
+		};
+		tx-pins {
+			pinmux = <GPIOMUX(41, GPO_UART0_PAD_SOUT,
+				  GPO_ENABLE, GPI_NONE)>;
+			bias-disable;
+			drive-strength = <35>;
+			input-disable;
+			input-schmitt-disable;
+		};
+		cts-pins {
+			pinmux = <GPIOMUX(39, GPO_LOW, GPO_DISABLE,
+				  GPI_UART0_PAD_CTSN)>;
+			bias-pull-down;
+			drive-strength = <14>;
+			input-enable;
+			input-schmitt-enable;
+		};
+		rts-pins {
+			pinmux = <GPIOMUX(42, GPO_UART0_PAD_RTSN,
+				  GPO_ENABLE, GPI_NONE)>;
+			bias-disable;
+			drive-strength = <35>;
+			input-disable;
+			input-schmitt-disable;
+		};
+	};
+
 	uart3_pins: uart3-0 {
 		rx-pins {
 			pinmux = <GPIOMUX(13, GPO_LOW, GPO_DISABLE,
@@ -393,6 +428,20 @@ wifi@1 {
 	};
 };
 
+&uart0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&uart0_pins>;
+	uart-has-rtscts;
+	status = "okay";
+
+	bluetooth {
+		compatible = "brcm,bcm4330-bt";
+		max-speed = <4000000>;
+		device-wakeup-gpios = <&gpio 38 GPIO_ACTIVE_HIGH>;
+		reset-gpios = <&gpio 35 GPIO_ACTIVE_LOW>;
+	};
+};
+
 &uart3 {
 	pinctrl-names = "default";
 	pinctrl-0 = <&uart3_pins>;
-- 
2.49.0


From 82f18943c0aa3d799edf9295c980b760ae8fb135 Mon Sep 17 00:00:00 2001
From: Emil Renner Berthing <kernel@esmil.dk>
Date: Sat, 20 Nov 2021 17:13:22 +0100
Subject: [PATCH 05/31] riscv: dts: starfive: Add StarFive JH7100 audio clock
 node

Add device tree node for the audio clocks on the StarFive JH7100 RISC-V
SoC.

Signed-off-by: Emil Renner Berthing <kernel@esmil.dk>
---
 arch/riscv/boot/dts/starfive/jh7100.dtsi | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/arch/riscv/boot/dts/starfive/jh7100.dtsi b/arch/riscv/boot/dts/starfive/jh7100.dtsi
index aecb73d25a..f260c00053 100644
--- a/arch/riscv/boot/dts/starfive/jh7100.dtsi
+++ b/arch/riscv/boot/dts/starfive/jh7100.dtsi
@@ -239,6 +239,16 @@ stmmac_axi_setup: stmmac-axi-config {
 			};
 		};
 
+		audclk: clock-controller@10480000 {
+			compatible = "starfive,jh7100-audclk";
+			reg = <0x0 0x10480000 0x0 0x10000>;
+			clocks = <&clkgen JH7100_CLK_AUDIO_SRC>,
+				 <&clkgen JH7100_CLK_AUDIO_12288>,
+				 <&clkgen JH7100_CLK_DOM7AHB_BUS>;
+			clock-names = "audio_src", "audio_12288", "dom7ahb_bus";
+			#clock-cells = <1>;
+		};
+
 		clkgen: clock-controller@11800000 {
 			compatible = "starfive,jh7100-clkgen";
 			reg = <0x0 0x11800000 0x0 0x10000>;
-- 
2.49.0


From c7309e73d326b3d992356c000859057b6116df79 Mon Sep 17 00:00:00 2001
From: Emil Renner Berthing <kernel@esmil.dk>
Date: Sat, 20 Nov 2021 19:29:25 +0100
Subject: [PATCH 06/31] dt-bindings: reset: Add StarFive JH7100 audio reset
 definitions

Add all resets for the StarFive JH7100 audio reset controller.

Signed-off-by: Emil Renner Berthing <kernel@esmil.dk>
---
 .../dt-bindings/reset/starfive-jh7100-audio.h | 31 +++++++++++++++++++
 1 file changed, 31 insertions(+)
 create mode 100644 include/dt-bindings/reset/starfive-jh7100-audio.h

diff --git a/include/dt-bindings/reset/starfive-jh7100-audio.h b/include/dt-bindings/reset/starfive-jh7100-audio.h
new file mode 100644
index 0000000000..30e3d4cf06
--- /dev/null
+++ b/include/dt-bindings/reset/starfive-jh7100-audio.h
@@ -0,0 +1,31 @@
+/* SPDX-License-Identifier: GPL-2.0 OR MIT */
+/*
+ * Copyright (C) 2021 Emil Renner Berthing
+ */
+
+#ifndef __DT_BINDINGS_RESET_STARFIVE_JH7100_AUDIO_H__
+#define __DT_BINDINGS_RESET_STARFIVE_JH7100_AUDIO_H__
+
+#define JH7100_AUDRSTN_APB_BUS		0
+#define JH7100_AUDRSTN_I2SADC_APB	1
+#define JH7100_AUDRSTN_I2SADC_SRST	2
+#define JH7100_AUDRSTN_PDM_APB		3
+#define JH7100_AUDRSTN_I2SVAD_APB	4
+#define JH7100_AUDRSTN_I2SVAD_SRST	5
+#define JH7100_AUDRSTN_SPDIF_APB	6
+#define JH7100_AUDRSTN_PWMDAC_APB	7
+#define JH7100_AUDRSTN_I2SDAC_APB	8
+#define JH7100_AUDRSTN_I2SDAC_SRST	9
+#define JH7100_AUDRSTN_I2S1_APB		10
+#define JH7100_AUDRSTN_I2S1_SRST	11
+#define JH7100_AUDRSTN_I2SDAC16K_APB	12
+#define JH7100_AUDRSTN_I2SDAC16K_SRST	13
+#define JH7100_AUDRSTN_DMA1P_AHB	14
+#define JH7100_AUDRSTN_USB_APB		15
+#define JH7100_AUDRST_USB_AXI		16
+#define JH7100_AUDRST_USB_PWRUP_RST_N	17
+#define JH7100_AUDRST_USB_PONRST	18
+
+#define JH7100_AUDRSTN_END		19
+
+#endif /* __DT_BINDINGS_RESET_STARFIVE_JH7100_AUDIO_H__ */
-- 
2.49.0


From 760f5248a9d845045cbd66ef94d5512eb5598d16 Mon Sep 17 00:00:00 2001
From: Emil Renner Berthing <kernel@esmil.dk>
Date: Tue, 7 Dec 2021 21:48:51 +0100
Subject: [PATCH 07/31] dt-bindings: reset: Add starfive,jh7100-audrst bindings

Add bindings for the audio reset controller on the StarFive JH7100
RISC-V SoC.

Signed-off-by: Emil Renner Berthing <kernel@esmil.dk>
---
 .../reset/starfive,jh7100-audrst.yaml         | 38 +++++++++++++++++++
 1 file changed, 38 insertions(+)
 create mode 100644 Documentation/devicetree/bindings/reset/starfive,jh7100-audrst.yaml

diff --git a/Documentation/devicetree/bindings/reset/starfive,jh7100-audrst.yaml b/Documentation/devicetree/bindings/reset/starfive,jh7100-audrst.yaml
new file mode 100644
index 0000000000..32797802c1
--- /dev/null
+++ b/Documentation/devicetree/bindings/reset/starfive,jh7100-audrst.yaml
@@ -0,0 +1,38 @@
+# SPDX-License-Identifier: GPL-2.0-only OR BSD-2-Clause
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/reset/starfive,jh7100-audrst.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: StarFive JH7100 SoC Audio Reset Controller
+
+maintainers:
+  - Emil Renner Berthing <kernel@esmil.dk>
+
+properties:
+  compatible:
+    enum:
+      - starfive,jh7100-audrst
+
+  reg:
+    maxItems: 1
+
+  "#reset-cells":
+    const: 1
+
+required:
+  - compatible
+  - reg
+  - "#reset-cells"
+
+additionalProperties: false
+
+examples:
+  - |
+    reset-controller@10490000 {
+        compatible = "starfive,jh7100-audrst";
+        reg = <0x10490000 0x10000>;
+        #reset-cells = <1>;
+    };
+
+...
-- 
2.49.0


From 3f013c34d3173e53b56d7be82197830fb68b12e6 Mon Sep 17 00:00:00 2001
From: Emil Renner Berthing <kernel@esmil.dk>
Date: Sat, 20 Nov 2021 19:30:49 +0100
Subject: [PATCH 08/31] reset: starfive: Add JH7100 audio reset driver

The audio resets are almost identical to the system resets, there are
just fewer of them. So factor out and export a generic probe function,
so most of the reset controller implementation can be shared.

Signed-off-by: Emil Renner Berthing <kernel@esmil.dk>
---
 MAINTAINERS                                   |  2 +-
 drivers/reset/starfive/Kconfig                |  7 ++
 drivers/reset/starfive/Makefile               |  2 +
 .../starfive/reset-starfive-jh7100-audio.c    | 66 +++++++++++++++++++
 .../reset/starfive/reset-starfive-jh7100.h    | 16 +++++
 5 files changed, 92 insertions(+), 1 deletion(-)
 create mode 100644 drivers/reset/starfive/reset-starfive-jh7100-audio.c
 create mode 100644 drivers/reset/starfive/reset-starfive-jh7100.h

diff --git a/MAINTAINERS b/MAINTAINERS
index f398bfae65..3cdcd5588f 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -22627,7 +22627,7 @@ STARFIVE JH71X0 RESET CONTROLLER DRIVERS
 M:	Emil Renner Berthing <kernel@esmil.dk>
 M:	Hal Feng <hal.feng@starfivetech.com>
 S:	Maintained
-F:	Documentation/devicetree/bindings/reset/starfive,jh7100-reset.yaml
+F:	Documentation/devicetree/bindings/reset/starfive,jh7100-*.yaml
 F:	drivers/reset/starfive/reset-starfive-jh71*
 F:	include/dt-bindings/reset/starfive?jh71*.h
 
diff --git a/drivers/reset/starfive/Kconfig b/drivers/reset/starfive/Kconfig
index d832339f61..e125c87787 100644
--- a/drivers/reset/starfive/Kconfig
+++ b/drivers/reset/starfive/Kconfig
@@ -11,6 +11,13 @@ config RESET_STARFIVE_JH7100
 	help
 	  This enables the reset controller driver for the StarFive JH7100 SoC.
 
+config RESET_STARFIVE_JH7100_AUDIO
+	tristate "StarFive JH7100 Audio Reset Driver"
+	depends on RESET_STARFIVE_JH7100
+	default m if SOC_STARFIVE
+	help
+	  This enables the audio reset driver for the StarFive JH7100 SoC.
+
 config RESET_STARFIVE_JH7110
 	bool "StarFive JH7110 Reset Driver"
 	depends on CLK_STARFIVE_JH7110_SYS
diff --git a/drivers/reset/starfive/Makefile b/drivers/reset/starfive/Makefile
index 7a44b66fb9..ed8683748d 100644
--- a/drivers/reset/starfive/Makefile
+++ b/drivers/reset/starfive/Makefile
@@ -2,4 +2,6 @@
 obj-$(CONFIG_RESET_STARFIVE_JH71X0)		+= reset-starfive-jh71x0.o
 
 obj-$(CONFIG_RESET_STARFIVE_JH7100)		+= reset-starfive-jh7100.o
+obj-$(CONFIG_RESET_STARFIVE_JH7100_AUDIO)	+= reset-starfive-jh7100-audio.o
+
 obj-$(CONFIG_RESET_STARFIVE_JH7110)		+= reset-starfive-jh7110.o
diff --git a/drivers/reset/starfive/reset-starfive-jh7100-audio.c b/drivers/reset/starfive/reset-starfive-jh7100-audio.c
new file mode 100644
index 0000000000..44ffef634f
--- /dev/null
+++ b/drivers/reset/starfive/reset-starfive-jh7100-audio.c
@@ -0,0 +1,66 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Audio reset driver for the StarFive JH7100 SoC
+ *
+ * Copyright (C) 2021 Emil Renner Berthing <kernel@esmil.dk>
+ */
+
+#include <linux/mod_devicetable.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+
+#include "reset-starfive-jh71x0.h"
+
+#include <dt-bindings/reset/starfive-jh7100-audio.h>
+
+/* register offsets */
+#define JH7100_AUDRST_ASSERT0	0x00
+#define JH7100_AUDRST_STATUS0	0x04
+
+/*
+ * Writing a 1 to the n'th bit of the ASSERT register asserts
+ * line n, and writing a 0 deasserts the same line.
+ * Most reset lines have their status inverted so a 0 bit in the STATUS
+ * register means the line is asserted and a 1 means it's deasserted. A few
+ * lines don't though, so store the expected value of the status registers when
+ * all lines are asserted.
+ */
+static const u32 jh7100_audrst_asserted[1] = {
+	BIT(JH7100_AUDRST_USB_AXI) |
+	BIT(JH7100_AUDRST_USB_PWRUP_RST_N) |
+	BIT(JH7100_AUDRST_USB_PONRST)
+};
+
+static int jh7100_audrst_probe(struct platform_device *pdev)
+{
+	void __iomem *base = devm_platform_ioremap_resource(pdev, 0);
+
+	if (IS_ERR(base))
+		return PTR_ERR(base);
+
+	return reset_starfive_jh71x0_register(&pdev->dev, pdev->dev.of_node,
+					      base + JH7100_AUDRST_ASSERT0,
+					      base + JH7100_AUDRST_STATUS0,
+					      jh7100_audrst_asserted,
+					      JH7100_AUDRSTN_END,
+					      THIS_MODULE);
+}
+
+static const struct of_device_id jh7100_audrst_dt_ids[] = {
+	{ .compatible = "starfive,jh7100-audrst" },
+	{ /* sentinel */ }
+};
+MODULE_DEVICE_TABLE(of, jh7100_audrst_dt_ids);
+
+static struct platform_driver jh7100_audrst_driver = {
+	.probe = jh7100_audrst_probe,
+	.driver = {
+		.name = "jh7100-reset-audio",
+		.of_match_table = jh7100_audrst_dt_ids,
+	},
+};
+module_platform_driver(jh7100_audrst_driver);
+
+MODULE_AUTHOR("Emil Renner Berthing");
+MODULE_DESCRIPTION("StarFive JH7100 audio reset driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/reset/starfive/reset-starfive-jh7100.h b/drivers/reset/starfive/reset-starfive-jh7100.h
new file mode 100644
index 0000000000..ee8f3e3b16
--- /dev/null
+++ b/drivers/reset/starfive/reset-starfive-jh7100.h
@@ -0,0 +1,16 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
+/*
+ * Copyright (C) 2021 Emil Renner Berthing <kernel@esmil.dk>
+ */
+
+#ifndef _RESET_STARFIVE_JH7100_H_
+#define _RESET_STARFIVE_JH7100_H_
+
+#include <linux/platform_device.h>
+
+int reset_starfive_jh7100_generic_probe(struct platform_device *pdev,
+					const u32 *asserted,
+					unsigned int status_offset,
+					unsigned int nr_resets);
+
+#endif
-- 
2.49.0


From 766a4d8621d0b83f10cfb48bd83fd201bf00c6bc Mon Sep 17 00:00:00 2001
From: Emil Renner Berthing <kernel@esmil.dk>
Date: Sat, 20 Nov 2021 21:33:08 +0100
Subject: [PATCH 09/31] riscv: dts: starfive: Add StarFive JH7100 audio reset
 node

Add device tree node for the audio resets on the StarFive JH7100 RISC-V
SoC.

Signed-off-by: Emil Renner Berthing <kernel@esmil.dk>
---
 arch/riscv/boot/dts/starfive/jh7100.dtsi | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/arch/riscv/boot/dts/starfive/jh7100.dtsi b/arch/riscv/boot/dts/starfive/jh7100.dtsi
index f260c00053..be03aceb6a 100644
--- a/arch/riscv/boot/dts/starfive/jh7100.dtsi
+++ b/arch/riscv/boot/dts/starfive/jh7100.dtsi
@@ -249,6 +249,12 @@ audclk: clock-controller@10480000 {
 			#clock-cells = <1>;
 		};
 
+		audrst: reset-controller@10490000 {
+			compatible = "starfive,jh7100-audrst";
+			reg = <0x0 0x10490000 0x0 0x10000>;
+			#reset-cells = <1>;
+		};
+
 		clkgen: clock-controller@11800000 {
 			compatible = "starfive,jh7100-clkgen";
 			reg = <0x0 0x11800000 0x0 0x10000>;
-- 
2.49.0


From b6c015c22a5a15ecd9d759af5cc34ad9ce11b5e5 Mon Sep 17 00:00:00 2001
From: Emil Renner Berthing <kernel@esmil.dk>
Date: Sun, 3 Jul 2022 21:01:11 +0200
Subject: [PATCH 10/31] power: reset: tps65086: Allow building as a module

Signed-off-by: Emil Renner Berthing <kernel@esmil.dk>
---
 drivers/power/reset/Kconfig            | 2 +-
 drivers/power/reset/tps65086-restart.c | 1 +
 2 files changed, 2 insertions(+), 1 deletion(-)

diff --git a/drivers/power/reset/Kconfig b/drivers/power/reset/Kconfig
index 60bf0ca64c..3bb53a31df 100644
--- a/drivers/power/reset/Kconfig
+++ b/drivers/power/reset/Kconfig
@@ -217,7 +217,7 @@ config POWER_RESET_ST
 	  Reset support for STMicroelectronics boards.
 
 config POWER_RESET_TPS65086
-	bool "TPS65086 restart driver"
+	tristate "TPS65086 restart driver"
 	depends on MFD_TPS65086
 	help
 	  This driver adds support for resetting the TPS65086 PMIC on restart.
diff --git a/drivers/power/reset/tps65086-restart.c b/drivers/power/reset/tps65086-restart.c
index 6976dbcac7..599ec51e49 100644
--- a/drivers/power/reset/tps65086-restart.c
+++ b/drivers/power/reset/tps65086-restart.c
@@ -57,3 +57,4 @@ module_platform_driver(tps65086_restart_driver);
 
 MODULE_AUTHOR("Emil Renner Berthing <kernel@esmil.dk>");
 MODULE_DESCRIPTION("TPS65086 restart driver");
+MODULE_LICENSE("GPL v2");
-- 
2.49.0


From d509b3d765f97ae7a7caf15ddcd6721ba810d37d Mon Sep 17 00:00:00 2001
From: Emil Renner Berthing <emil.renner.berthing@canonical.com>
Date: Sat, 22 Jul 2023 15:59:02 +0200
Subject: [PATCH 11/31] usb: cdns3: starfive: Simplify mode init

The syscon regmap and offset to the USB mode register is only used at
probe time, so there is no need to store it in the device data. Just get
the regmap pointer in the cdns_mode_init() function where it is needed.
Also this function never uses the platform device, so just pass the
device pointer directly.

Signed-off-by: Emil Renner Berthing <emil.renner.berthing@canonical.com>
---
 drivers/usb/cdns3/cdns3-starfive.c | 51 ++++++++++++------------------
 1 file changed, 21 insertions(+), 30 deletions(-)

diff --git a/drivers/usb/cdns3/cdns3-starfive.c b/drivers/usb/cdns3/cdns3-starfive.c
index 2ff7f2b48c..3c2b0f2b91 100644
--- a/drivers/usb/cdns3/cdns3-starfive.c
+++ b/drivers/usb/cdns3/cdns3-starfive.c
@@ -34,46 +34,45 @@
 
 struct cdns_starfive {
 	struct device *dev;
-	struct regmap *stg_syscon;
 	struct reset_control *resets;
 	struct clk_bulk_data *clks;
 	int num_clks;
-	u32 stg_usb_mode;
 };
 
-static void cdns_mode_init(struct platform_device *pdev,
-			   struct cdns_starfive *data)
+static int cdns_mode_init(struct device *dev, struct cdns_starfive *data)
 {
+	struct regmap *syscon;
+	unsigned int usb_mode;
 	enum usb_dr_mode mode;
 
-	regmap_update_bits(data->stg_syscon, data->stg_usb_mode,
+	syscon = syscon_regmap_lookup_by_phandle_args(dev->of_node,
+						      "starfive,stg-syscon", 1, &usb_mode);
+	if (IS_ERR(syscon))
+		return dev_err_probe(dev, PTR_ERR(syscon),
+				     "Failed to parse starfive,stg-syscon\n");
+
+	regmap_update_bits(syscon, usb_mode,
 			   USB_MISC_CFG_MASK,
 			   USB_SUSPENDM_BYPS | USB_PLL_EN | USB_REFCLK_MODE);
 
 	/* dr mode setting */
-	mode = usb_get_dr_mode(&pdev->dev);
+	mode = usb_get_dr_mode(dev);
 
 	switch (mode) {
 	case USB_DR_MODE_HOST:
-		regmap_update_bits(data->stg_syscon,
-				   data->stg_usb_mode,
-				   USB_STRAP_MASK,
-				   USB_STRAP_HOST);
-		regmap_update_bits(data->stg_syscon,
-				   data->stg_usb_mode,
-				   USB_SUSPENDM_MASK,
-				   USB_SUSPENDM_HOST);
+		regmap_update_bits(syscon, usb_mode, USB_STRAP_MASK, USB_STRAP_HOST);
+		regmap_update_bits(syscon, usb_mode, USB_SUSPENDM_MASK, USB_SUSPENDM_HOST);
 		break;
 
 	case USB_DR_MODE_PERIPHERAL:
-		regmap_update_bits(data->stg_syscon, data->stg_usb_mode,
-				   USB_STRAP_MASK, USB_STRAP_DEVICE);
-		regmap_update_bits(data->stg_syscon, data->stg_usb_mode,
-				   USB_SUSPENDM_MASK, 0);
+		regmap_update_bits(syscon, usb_mode, USB_STRAP_MASK, USB_STRAP_DEVICE);
+		regmap_update_bits(syscon, usb_mode, USB_SUSPENDM_MASK, 0);
 		break;
 	default:
 		break;
 	}
+
+	return 0;
 }
 
 static int cdns_clk_rst_init(struct cdns_starfive *data)
@@ -108,7 +107,6 @@ static int cdns_starfive_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct cdns_starfive *data;
-	unsigned int args;
 	int ret;
 
 	data = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);
@@ -117,16 +115,6 @@ static int cdns_starfive_probe(struct platform_device *pdev)
 
 	data->dev = dev;
 
-	data->stg_syscon =
-		syscon_regmap_lookup_by_phandle_args(pdev->dev.of_node,
-						     "starfive,stg-syscon", 1, &args);
-
-	if (IS_ERR(data->stg_syscon))
-		return dev_err_probe(dev, PTR_ERR(data->stg_syscon),
-				     "Failed to parse starfive,stg-syscon\n");
-
-	data->stg_usb_mode = args;
-
 	data->num_clks = devm_clk_bulk_get_all(data->dev, &data->clks);
 	if (data->num_clks < 0)
 		return dev_err_probe(data->dev, -ENODEV,
@@ -137,7 +125,10 @@ static int cdns_starfive_probe(struct platform_device *pdev)
 		return dev_err_probe(data->dev, PTR_ERR(data->resets),
 				     "Failed to get resets");
 
-	cdns_mode_init(pdev, data);
+	ret = cdns_mode_init(dev, data);
+	if (ret)
+		return ret;
+
 	ret = cdns_clk_rst_init(data);
 	if (ret)
 		return ret;
-- 
2.49.0


From 4a969de59c1658a8399e57faf7e97c7150bba62c Mon Sep 17 00:00:00 2001
From: Emil Renner Berthing <emil.renner.berthing@canonical.com>
Date: Sat, 22 Jul 2023 16:18:24 +0200
Subject: [PATCH 12/31] usb: cdns3: starfive: Don't store device backpointer

Signed-off-by: Emil Renner Berthing <emil.renner.berthing@canonical.com>
---
 drivers/usb/cdns3/cdns3-starfive.c | 37 ++++++++++++------------------
 1 file changed, 15 insertions(+), 22 deletions(-)

diff --git a/drivers/usb/cdns3/cdns3-starfive.c b/drivers/usb/cdns3/cdns3-starfive.c
index 3c2b0f2b91..7c3d5c1467 100644
--- a/drivers/usb/cdns3/cdns3-starfive.c
+++ b/drivers/usb/cdns3/cdns3-starfive.c
@@ -33,7 +33,6 @@
 #define USB_REFCLK_MODE			BIT(23)
 
 struct cdns_starfive {
-	struct device *dev;
 	struct reset_control *resets;
 	struct clk_bulk_data *clks;
 	int num_clks;
@@ -49,7 +48,7 @@ static int cdns_mode_init(struct device *dev, struct cdns_starfive *data)
 						      "starfive,stg-syscon", 1, &usb_mode);
 	if (IS_ERR(syscon))
 		return dev_err_probe(dev, PTR_ERR(syscon),
-				     "Failed to parse starfive,stg-syscon\n");
+				     "failed to parse starfive,stg-syscon\n");
 
 	regmap_update_bits(syscon, usb_mode,
 			   USB_MISC_CFG_MASK,
@@ -75,18 +74,17 @@ static int cdns_mode_init(struct device *dev, struct cdns_starfive *data)
 	return 0;
 }
 
-static int cdns_clk_rst_init(struct cdns_starfive *data)
+static int cdns_clk_rst_init(struct device *dev, struct cdns_starfive *data)
 {
 	int ret;
 
 	ret = clk_bulk_prepare_enable(data->num_clks, data->clks);
 	if (ret)
-		return dev_err_probe(data->dev, ret,
-				     "failed to enable clocks\n");
+		return dev_err_probe(dev, ret, "failed to enable clocks\n");
 
 	ret = reset_control_deassert(data->resets);
 	if (ret) {
-		dev_err(data->dev, "failed to reset clocks\n");
+		dev_err(dev, "failed to reset clocks\n");
 		goto err_clk_init;
 	}
 
@@ -97,7 +95,7 @@ static int cdns_clk_rst_init(struct cdns_starfive *data)
 	return ret;
 }
 
-static void cdns_clk_rst_deinit(struct cdns_starfive *data)
+static void cdns_clk_rst_deinit(struct device *dev, struct cdns_starfive *data)
 {
 	reset_control_assert(data->resets);
 	clk_bulk_disable_unprepare(data->num_clks, data->clks);
@@ -113,31 +111,26 @@ static int cdns_starfive_probe(struct platform_device *pdev)
 	if (!data)
 		return -ENOMEM;
 
-	data->dev = dev;
-
-	data->num_clks = devm_clk_bulk_get_all(data->dev, &data->clks);
+	data->num_clks = devm_clk_bulk_get_all(dev, &data->clks);
 	if (data->num_clks < 0)
-		return dev_err_probe(data->dev, -ENODEV,
-				     "Failed to get clocks\n");
+		return dev_err_probe(dev, -ENODEV, "failed to get clocks\n");
 
-	data->resets = devm_reset_control_array_get_exclusive(data->dev);
+	data->resets = devm_reset_control_array_get_exclusive(dev);
 	if (IS_ERR(data->resets))
-		return dev_err_probe(data->dev, PTR_ERR(data->resets),
-				     "Failed to get resets");
+		return dev_err_probe(dev, PTR_ERR(data->resets), "failed to get resets\n");
 
 	ret = cdns_mode_init(dev, data);
 	if (ret)
 		return ret;
 
-	ret = cdns_clk_rst_init(data);
+	ret = cdns_clk_rst_init(dev, data);
 	if (ret)
 		return ret;
 
 	ret = of_platform_populate(dev->of_node, NULL, NULL, dev);
 	if (ret) {
-		dev_err(dev, "Failed to create children\n");
-		cdns_clk_rst_deinit(data);
-		return ret;
+		cdns_clk_rst_deinit(dev, data);
+		return dev_err_probe(dev, ret, "failed to create children\n");
 	}
 
 	device_set_wakeup_capable(dev, true);
@@ -167,7 +160,7 @@ static void cdns_starfive_remove(struct platform_device *pdev)
 
 	pm_runtime_disable(dev);
 	pm_runtime_put_noidle(dev);
-	cdns_clk_rst_deinit(data);
+	cdns_clk_rst_deinit(dev, data);
 	platform_set_drvdata(pdev, NULL);
 }
 
@@ -193,14 +186,14 @@ static int cdns_starfive_resume(struct device *dev)
 {
 	struct cdns_starfive *data = dev_get_drvdata(dev);
 
-	return cdns_clk_rst_init(data);
+	return cdns_clk_rst_init(dev, data);
 }
 
 static int cdns_starfive_suspend(struct device *dev)
 {
 	struct cdns_starfive *data = dev_get_drvdata(dev);
 
-	cdns_clk_rst_deinit(data);
+	cdns_clk_rst_deinit(dev, data);
 
 	return 0;
 }
-- 
2.49.0


From 17029b87bf9c10135cebb69219cb3db96b5a9914 Mon Sep 17 00:00:00 2001
From: Emil Renner Berthing <emil.renner.berthing@canonical.com>
Date: Sat, 22 Jul 2023 16:21:04 +0200
Subject: [PATCH 13/31] usb: cdns3: starfive: Add StarFive JH7100 support

Signed-off-by: Emil Renner Berthing <emil.renner.berthing@canonical.com>
---
 drivers/usb/cdns3/cdns3-starfive.c | 46 ++++++++++++++++++------------
 1 file changed, 28 insertions(+), 18 deletions(-)

diff --git a/drivers/usb/cdns3/cdns3-starfive.c b/drivers/usb/cdns3/cdns3-starfive.c
index 7c3d5c1467..35063825b6 100644
--- a/drivers/usb/cdns3/cdns3-starfive.c
+++ b/drivers/usb/cdns3/cdns3-starfive.c
@@ -20,17 +20,17 @@
 #include <linux/usb/otg.h>
 #include "core.h"
 
-#define USB_STRAP_HOST			BIT(17)
-#define USB_STRAP_DEVICE		BIT(18)
-#define USB_STRAP_MASK			GENMASK(18, 16)
+#define JH7110_STRAP_HOST		BIT(17)
+#define JH7110_STRAP_DEVICE		BIT(18)
+#define JH7110_STRAP_MASK		GENMASK(18, 16)
 
-#define USB_SUSPENDM_HOST		BIT(19)
-#define USB_SUSPENDM_MASK		BIT(19)
+#define JH7110_SUSPENDM_HOST		BIT(19)
+#define JH7110_SUSPENDM_MASK		BIT(19)
 
-#define USB_MISC_CFG_MASK		GENMASK(23, 20)
-#define USB_SUSPENDM_BYPS		BIT(20)
-#define USB_PLL_EN			BIT(22)
-#define USB_REFCLK_MODE			BIT(23)
+#define JH7110_MISC_CFG_MASK		GENMASK(23, 20)
+#define JH7110_SUSPENDM_BYPS		BIT(20)
+#define JH7110_PLL_EN			BIT(22)
+#define JH7110_REFCLK_MODE		BIT(23)
 
 struct cdns_starfive {
 	struct reset_control *resets;
@@ -38,7 +38,14 @@ struct cdns_starfive {
 	int num_clks;
 };
 
-static int cdns_mode_init(struct device *dev, struct cdns_starfive *data)
+typedef int (cdns_starfive_mode_init_t)(struct device *dev, struct cdns_starfive *data);
+
+static int cdns_jh7100_mode_init(struct device *dev, struct cdns_starfive *data)
+{
+	return 0;
+}
+
+static int cdns_jh7110_mode_init(struct device *dev, struct cdns_starfive *data)
 {
 	struct regmap *syscon;
 	unsigned int usb_mode;
@@ -51,21 +58,21 @@ static int cdns_mode_init(struct device *dev, struct cdns_starfive *data)
 				     "failed to parse starfive,stg-syscon\n");
 
 	regmap_update_bits(syscon, usb_mode,
-			   USB_MISC_CFG_MASK,
-			   USB_SUSPENDM_BYPS | USB_PLL_EN | USB_REFCLK_MODE);
+			   JH7110_MISC_CFG_MASK,
+			   JH7110_SUSPENDM_BYPS | JH7110_PLL_EN | JH7110_REFCLK_MODE);
 
 	/* dr mode setting */
 	mode = usb_get_dr_mode(dev);
 
 	switch (mode) {
 	case USB_DR_MODE_HOST:
-		regmap_update_bits(syscon, usb_mode, USB_STRAP_MASK, USB_STRAP_HOST);
-		regmap_update_bits(syscon, usb_mode, USB_SUSPENDM_MASK, USB_SUSPENDM_HOST);
+		regmap_update_bits(syscon, usb_mode, JH7110_STRAP_MASK, JH7110_STRAP_HOST);
+		regmap_update_bits(syscon, usb_mode, JH7110_SUSPENDM_MASK, JH7110_SUSPENDM_HOST);
 		break;
 
 	case USB_DR_MODE_PERIPHERAL:
-		regmap_update_bits(syscon, usb_mode, USB_STRAP_MASK, USB_STRAP_DEVICE);
-		regmap_update_bits(syscon, usb_mode, USB_SUSPENDM_MASK, 0);
+		regmap_update_bits(syscon, usb_mode, JH7110_STRAP_MASK, JH7110_STRAP_DEVICE);
+		regmap_update_bits(syscon, usb_mode, JH7110_SUSPENDM_MASK, 0);
 		break;
 	default:
 		break;
@@ -105,6 +112,7 @@ static int cdns_starfive_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
 	struct cdns_starfive *data;
+	cdns_starfive_mode_init_t *mode_init;
 	int ret;
 
 	data = devm_kzalloc(dev, sizeof(*data), GFP_KERNEL);
@@ -119,7 +127,8 @@ static int cdns_starfive_probe(struct platform_device *pdev)
 	if (IS_ERR(data->resets))
 		return dev_err_probe(dev, PTR_ERR(data->resets), "failed to get resets\n");
 
-	ret = cdns_mode_init(dev, data);
+	mode_init = device_get_match_data(dev);
+	ret = mode_init(dev, data);
 	if (ret)
 		return ret;
 
@@ -207,7 +216,8 @@ static const struct dev_pm_ops cdns_starfive_pm_ops = {
 };
 
 static const struct of_device_id cdns_starfive_of_match[] = {
-	{ .compatible = "starfive,jh7110-usb", },
+	{ .compatible = "starfive,jh7100-usb", .data = cdns_jh7100_mode_init },
+	{ .compatible = "starfive,jh7110-usb", .data = cdns_jh7110_mode_init },
 	{ /* sentinel */ }
 };
 MODULE_DEVICE_TABLE(of, cdns_starfive_of_match);
-- 
2.49.0


From 29d2617fbc7f956908271f7c9f355251fecc09f8 Mon Sep 17 00:00:00 2001
From: Emil Renner Berthing <emil.renner.berthing@canonical.com>
Date: Sat, 22 Jul 2023 16:36:17 +0200
Subject: [PATCH 14/31] riscv: dts: starfive: Add JH7100 USB node

Add the device tree node for the USB 3.0 peripheral on the
StarFive JH7100 SoC.

Signed-off-by: Emil Renner Berthing <emil.renner.berthing@canonical.com>
---
 .../boot/dts/starfive/jh7100-common.dtsi      |  5 ++++
 arch/riscv/boot/dts/starfive/jh7100.dtsi      | 26 +++++++++++++++++++
 2 files changed, 31 insertions(+)

diff --git a/arch/riscv/boot/dts/starfive/jh7100-common.dtsi b/arch/riscv/boot/dts/starfive/jh7100-common.dtsi
index 1f79481bfd..3fad20c55d 100644
--- a/arch/riscv/boot/dts/starfive/jh7100-common.dtsi
+++ b/arch/riscv/boot/dts/starfive/jh7100-common.dtsi
@@ -447,3 +447,8 @@ &uart3 {
 	pinctrl-0 = <&uart3_pins>;
 	status = "okay";
 };
+
+&usb3 {
+	dr_mode = "host";
+	status = "okay";
+};
diff --git a/arch/riscv/boot/dts/starfive/jh7100.dtsi b/arch/riscv/boot/dts/starfive/jh7100.dtsi
index be03aceb6a..b9a6f44526 100644
--- a/arch/riscv/boot/dts/starfive/jh7100.dtsi
+++ b/arch/riscv/boot/dts/starfive/jh7100.dtsi
@@ -255,6 +255,32 @@ audrst: reset-controller@10490000 {
 			#reset-cells = <1>;
 		};
 
+		usb3: usb@104c0000 {
+			compatible = "starfive,jh7100-usb";
+			ranges = <0x0 0x0 0x104c0000 0x100000>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+			clocks = <&audclk JH7100_AUDCLK_USB_LPM>,
+			         <&audclk JH7100_AUDCLK_USB_STB>,
+			         <&clkgen JH7100_CLK_USB_AXI>,
+			         <&clkgen JH7100_CLK_USBNOC_AXI>;
+			clock-names = "lpm", "stb", "axi", "nocaxi";
+			resets = <&rstgen JH7100_RSTN_USB_AXI>,
+			         <&rstgen JH7100_RSTN_USBNOC_AXI>;
+			reset-names = "axi", "nocaxi";
+			status = "disabled";
+
+			usb_cdns3: usb@0 {
+				compatible = "cdns,usb3";
+				reg = <0x00000 0x10000>,
+				      <0x10000 0x10000>,
+				      <0x20000 0x10000>;
+				reg-names = "otg", "xhci", "dev";
+				interrupts = <44>, <52>, <43>;
+				interrupt-names = "host", "peripheral", "otg";
+			};
+		};
+
 		clkgen: clock-controller@11800000 {
 			compatible = "starfive,jh7100-clkgen";
 			reg = <0x0 0x11800000 0x0 0x10000>;
-- 
2.49.0


From d68ccc8e1591cc1e99bd60883dbefd54ae11557f Mon Sep 17 00:00:00 2001
From: Emil Renner Berthing <kernel@esmil.dk>
Date: Thu, 14 Oct 2021 20:35:43 +0200
Subject: [PATCH 15/31] clk: starfive: jh7100: Keep more clocks alive

Signed-off-by: Emil Renner Berthing <kernel@esmil.dk>
---
 drivers/clk/starfive/clk-starfive-jh7100.c | 19 ++++++++++---------
 1 file changed, 10 insertions(+), 9 deletions(-)

diff --git a/drivers/clk/starfive/clk-starfive-jh7100.c b/drivers/clk/starfive/clk-starfive-jh7100.c
index 03f6f26a15..0342db24c2 100644
--- a/drivers/clk/starfive/clk-starfive-jh7100.c
+++ b/drivers/clk/starfive/clk-starfive-jh7100.c
@@ -94,9 +94,9 @@ static const struct jh71x0_clk_data jh7100_clk_data[] __initconst = {
 	JH71X0_GATE(JH7100_CLK_DMA2PNOC_AXI, "dma2pnoc_axi", 0, JH7100_CLK_CPU_AXI),
 	JH71X0_GATE(JH7100_CLK_SGDMA2P_AHB, "sgdma2p_ahb", 0, JH7100_CLK_AHB_BUS),
 	JH71X0__DIV(JH7100_CLK_DLA_BUS, "dla_bus", 4, JH7100_CLK_DLA_ROOT),
-	JH71X0_GATE(JH7100_CLK_DLA_AXI, "dla_axi", 0, JH7100_CLK_DLA_BUS),
-	JH71X0_GATE(JH7100_CLK_DLANOC_AXI, "dlanoc_axi", 0, JH7100_CLK_DLA_BUS),
-	JH71X0_GATE(JH7100_CLK_DLA_APB, "dla_apb", 0, JH7100_CLK_APB1_BUS),
+	JH71X0_GATE(JH7100_CLK_DLA_AXI, "dla_axi", CLK_IGNORE_UNUSED, JH7100_CLK_DLA_BUS),
+	JH71X0_GATE(JH7100_CLK_DLANOC_AXI, "dlanoc_axi", CLK_IGNORE_UNUSED, JH7100_CLK_DLA_BUS),
+	JH71X0_GATE(JH7100_CLK_DLA_APB, "dla_apb", CLK_IGNORE_UNUSED, JH7100_CLK_APB1_BUS),
 	JH71X0_GDIV(JH7100_CLK_VP6_CORE, "vp6_core", 0, 4, JH7100_CLK_DSP_ROOT_DIV),
 	JH71X0__DIV(JH7100_CLK_VP6BUS_SRC, "vp6bus_src", 4, JH7100_CLK_DSP_ROOT),
 	JH71X0_GDIV(JH7100_CLK_VP6_AXI, "vp6_axi", 0, 4, JH7100_CLK_VP6BUS_SRC),
@@ -163,8 +163,9 @@ static const struct jh71x0_clk_data jh7100_clk_data[] __initconst = {
 	JH71X0_GATE(JH7100_CLK_USB_AXI, "usb_axi", 0, JH7100_CLK_USB_BUS),
 	JH71X0_GATE(JH7100_CLK_USBNOC_AXI, "usbnoc_axi", 0, JH7100_CLK_USB_BUS),
 	JH71X0__DIV(JH7100_CLK_USBPHY_ROOTDIV, "usbphy_rootdiv", 4, JH7100_CLK_GMACUSB_ROOT),
-	JH71X0_GDIV(JH7100_CLK_USBPHY_125M, "usbphy_125m", 0, 8, JH7100_CLK_USBPHY_ROOTDIV),
-	JH71X0_GDIV(JH7100_CLK_USBPHY_PLLDIV25M, "usbphy_plldiv25m", 0, 32,
+	JH71X0_GDIV(JH7100_CLK_USBPHY_125M, "usbphy_125m", CLK_IGNORE_UNUSED, 8,
+		    JH7100_CLK_USBPHY_ROOTDIV),
+	JH71X0_GDIV(JH7100_CLK_USBPHY_PLLDIV25M, "usbphy_plldiv25m", CLK_IGNORE_UNUSED, 32,
 		    JH7100_CLK_USBPHY_ROOTDIV),
 	JH71X0__MUX(JH7100_CLK_USBPHY_25M, "usbphy_25m", 0, 2,
 		    JH7100_CLK_OSC_SYS,
@@ -183,11 +184,11 @@ static const struct jh71x0_clk_data jh7100_clk_data[] __initconst = {
 	JH71X0__DIV(JH7100_CLK_VIN_BUS, "vin_bus", 8, JH7100_CLK_VIN_SRC),
 	JH71X0_GATE(JH7100_CLK_VIN_AXI, "vin_axi", 0, JH7100_CLK_VIN_BUS),
 	JH71X0_GATE(JH7100_CLK_VINNOC_AXI, "vinnoc_axi", 0, JH7100_CLK_VIN_BUS),
-	JH71X0_GDIV(JH7100_CLK_VOUT_SRC, "vout_src", 0, 4, JH7100_CLK_VOUT_ROOT),
+	JH71X0_GDIV(JH7100_CLK_VOUT_SRC, "vout_src", CLK_IGNORE_UNUSED, 4, JH7100_CLK_VOUT_ROOT),
 	JH71X0__DIV(JH7100_CLK_DISPBUS_SRC, "dispbus_src", 4, JH7100_CLK_VOUTBUS_ROOT),
 	JH71X0__DIV(JH7100_CLK_DISP_BUS, "disp_bus", 4, JH7100_CLK_DISPBUS_SRC),
-	JH71X0_GATE(JH7100_CLK_DISP_AXI, "disp_axi", 0, JH7100_CLK_DISP_BUS),
-	JH71X0_GATE(JH7100_CLK_DISPNOC_AXI, "dispnoc_axi", 0, JH7100_CLK_DISP_BUS),
+	JH71X0_GATE(JH7100_CLK_DISP_AXI, "disp_axi", CLK_IGNORE_UNUSED, JH7100_CLK_DISP_BUS),
+	JH71X0_GATE(JH7100_CLK_DISPNOC_AXI, "dispnoc_axi", CLK_IGNORE_UNUSED, JH7100_CLK_DISP_BUS),
 	JH71X0_GATE(JH7100_CLK_SDIO0_AHB, "sdio0_ahb", 0, JH7100_CLK_AHB_BUS),
 	JH71X0_GDIV(JH7100_CLK_SDIO0_CCLKINT, "sdio0_cclkint", 0, 24, JH7100_CLK_PERH0_SRC),
 	JH71X0__INV(JH7100_CLK_SDIO0_CCLKINT_INV, "sdio0_cclkint_inv", JH7100_CLK_SDIO0_CCLKINT),
@@ -223,7 +224,7 @@ static const struct jh71x0_clk_data jh7100_clk_data[] __initconst = {
 	JH71X0_GATE(JH7100_CLK_AES, "aes_clk", 0, JH7100_CLK_SEC_AHB),
 	JH71X0_GATE(JH7100_CLK_SHA, "sha_clk", 0, JH7100_CLK_SEC_AHB),
 	JH71X0_GATE(JH7100_CLK_PKA, "pka_clk", 0, JH7100_CLK_SEC_AHB),
-	JH71X0_GATE(JH7100_CLK_TRNG_APB, "trng_apb", 0, JH7100_CLK_APB1_BUS),
+	JH71X0_GATE(JH7100_CLK_TRNG_APB, "trng_apb", CLK_IGNORE_UNUSED, JH7100_CLK_APB1_BUS),
 	JH71X0_GATE(JH7100_CLK_OTP_APB, "otp_apb", 0, JH7100_CLK_APB1_BUS),
 	JH71X0_GATE(JH7100_CLK_UART0_APB, "uart0_apb", 0, JH7100_CLK_APB1_BUS),
 	JH71X0_GDIV(JH7100_CLK_UART0_CORE, "uart0_core", 0, 63, JH7100_CLK_PERH1_SRC),
-- 
2.49.0


From 55efd0b9547e7bc9abcd44bc683b955b754dcc31 Mon Sep 17 00:00:00 2001
From: Emil Renner Berthing <kernel@esmil.dk>
Date: Sat, 17 Jul 2021 21:50:38 +0200
Subject: [PATCH 16/31] pinctrl: starfive: Reset pinmux settings

Current u-boot doesn't seem to take into account that some GPIOs are
configured as inputs/outputs of certain peripherals on power-up. This
means it ends up configuring some GPIOs as inputs to more than one
peripheral which the documentation explicitly says is illegal. Similarly
it also ends up configuring more than one GPIO as output of the same
peripheral. While not explicitly mentioned by the documentation this
also seems like a bad idea.

The easiest way to remedy this mess is to just disconnect all GPIOs from
peripherals and have our pinmux configuration set everything up
properly. This, however, means that we'd disconnect the serial console
from its pins for a while, so add a device tree property to keep
certain GPIOs from being reset.

Signed-off-by: Emil Renner Berthing <kernel@esmil.dk>
---
 .../pinctrl/starfive,jh7100-pinctrl.yaml      |  4 ++
 .../starfive/pinctrl-starfive-jh7100.c        | 66 +++++++++++++++++++
 2 files changed, 70 insertions(+)

diff --git a/Documentation/devicetree/bindings/pinctrl/starfive,jh7100-pinctrl.yaml b/Documentation/devicetree/bindings/pinctrl/starfive,jh7100-pinctrl.yaml
index f3258f2fd3..ce79d2ae3a 100644
--- a/Documentation/devicetree/bindings/pinctrl/starfive,jh7100-pinctrl.yaml
+++ b/Documentation/devicetree/bindings/pinctrl/starfive,jh7100-pinctrl.yaml
@@ -88,6 +88,10 @@ properties:
     $ref: /schemas/types.yaml#/definitions/uint32
     enum: [0, 1, 2, 3, 4, 5, 6]
 
+  starfive,keep-gpiomux:
+    description: Keep pinmux for these GPIOs from being reset at boot.
+    $ref: /schemas/types.yaml#/definitions/uint32-array
+
 required:
   - compatible
   - reg
diff --git a/drivers/pinctrl/starfive/pinctrl-starfive-jh7100.c b/drivers/pinctrl/starfive/pinctrl-starfive-jh7100.c
index 27f99183d9..a39ef71de9 100644
--- a/drivers/pinctrl/starfive/pinctrl-starfive-jh7100.c
+++ b/drivers/pinctrl/starfive/pinctrl-starfive-jh7100.c
@@ -203,6 +203,10 @@ static u16 starfive_drive_strength_from_max_mA(u32 i)
 	return (clamp(i, 14U, 63U) - 14) / 7;
 }
 
+static bool keepmux;
+module_param(keepmux, bool, 0644);
+MODULE_PARM_DESC(keepmux, "Keep pinmux settings from previous boot stage");
+
 struct starfive_pinctrl {
 	struct gpio_chip gc;
 	struct pinctrl_gpio_range gpios;
@@ -1210,6 +1214,65 @@ static void starfive_disable_clock(void *data)
 	clk_disable_unprepare(data);
 }
 
+#define GPI_END (GPI_USB_OVER_CURRENT + 1)
+static void starfive_pinmux_reset(struct starfive_pinctrl *sfp)
+{
+	static const DECLARE_BITMAP(defaults, GPI_END) = {
+		BIT_MASK(GPI_I2C0_PAD_SCK_IN) |
+		BIT_MASK(GPI_I2C0_PAD_SDA_IN) |
+		BIT_MASK(GPI_I2C1_PAD_SCK_IN) |
+		BIT_MASK(GPI_I2C1_PAD_SDA_IN) |
+		BIT_MASK(GPI_I2C2_PAD_SCK_IN) |
+		BIT_MASK(GPI_I2C2_PAD_SDA_IN) |
+		BIT_MASK(GPI_I2C3_PAD_SCK_IN) |
+		BIT_MASK(GPI_I2C3_PAD_SDA_IN) |
+		BIT_MASK(GPI_SDIO0_PAD_CARD_DETECT_N) |
+
+		BIT_MASK(GPI_SDIO1_PAD_CARD_DETECT_N) |
+		BIT_MASK(GPI_SPI0_PAD_SS_IN_N) |
+		BIT_MASK(GPI_SPI1_PAD_SS_IN_N) |
+		BIT_MASK(GPI_SPI2_PAD_SS_IN_N) |
+		BIT_MASK(GPI_SPI2AHB_PAD_SS_N) |
+		BIT_MASK(GPI_SPI3_PAD_SS_IN_N),
+
+		BIT_MASK(GPI_UART0_PAD_SIN) |
+		BIT_MASK(GPI_UART1_PAD_SIN) |
+		BIT_MASK(GPI_UART2_PAD_SIN) |
+		BIT_MASK(GPI_UART3_PAD_SIN) |
+		BIT_MASK(GPI_USB_OVER_CURRENT)
+	};
+	DECLARE_BITMAP(keep, NR_GPIOS) = {};
+	struct device_node *np = sfp->gc.parent->of_node;
+	int len = of_property_count_u32_elems(np, "starfive,keep-gpiomux");
+	int i;
+
+	for (i = 0; i < len; i++) {
+		u32 gpio;
+
+		of_property_read_u32_index(np, "starfive,keep-gpiomux", i, &gpio);
+		if (gpio < NR_GPIOS)
+			set_bit(gpio, keep);
+	}
+
+	for (i = 0; i < NR_GPIOS; i++) {
+		if (test_bit(i, keep))
+			continue;
+
+		writel_relaxed(GPO_DISABLE, sfp->base + GPON_DOEN_CFG + 8 * i);
+		writel_relaxed(GPO_LOW,     sfp->base + GPON_DOUT_CFG + 8 * i);
+	}
+
+	for (i = 0; i < GPI_END; i++) {
+		void __iomem *reg = sfp->base + GPI_CFG_OFFSET + 4 * i;
+		u32 din = readl_relaxed(reg);
+
+		if (din >= 2 && din < (NR_GPIOS + 2) && test_bit(din - 2, keep))
+			continue;
+
+		writel_relaxed(test_bit(i, defaults), reg);
+	}
+}
+
 static int starfive_probe(struct platform_device *pdev)
 {
 	struct device *dev = &pdev->dev;
@@ -1271,6 +1334,9 @@ static int starfive_probe(struct platform_device *pdev)
 		writel(value, sfp->padctl + IO_PADSHARE_SEL);
 	}
 
+	if (!keepmux)
+		starfive_pinmux_reset(sfp);
+
 	value = readl(sfp->padctl + IO_PADSHARE_SEL);
 	switch (value) {
 	case 0:
-- 
2.49.0


From 4143fdab65aa10be575bc938e32c1ae612e39a2a Mon Sep 17 00:00:00 2001
From: Emil Renner Berthing <emil.renner.berthing@canonical.com>
Date: Mon, 7 Nov 2022 21:05:18 +0100
Subject: [PATCH 17/31] net: phy: motorcomm: Disable rgmii rx delay

Signed-off-by: Emil Renner Berthing <emil.renner.berthing@canonical.com>
---
 drivers/net/phy/motorcomm.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/drivers/net/phy/motorcomm.c b/drivers/net/phy/motorcomm.c
index 0e91f5d1a4..5bf78c1bd8 100644
--- a/drivers/net/phy/motorcomm.c
+++ b/drivers/net/phy/motorcomm.c
@@ -1660,6 +1660,12 @@ static int yt8521_config_init(struct phy_device *phydev)
 		ret = ytphy_rgmii_clk_delay_config(phydev);
 		if (ret < 0)
 			goto err_restore_page;
+
+		/* disable rx delay */
+		ret = ytphy_modify_ext(phydev, YT8521_CHIP_CONFIG_REG,
+				       YT8521_CCR_RXC_DLY_EN, 0);
+		if (ret < 0)
+			goto err_restore_page;
 	}
 
 	if (of_property_read_bool(node, "motorcomm,auto-sleep-disabled")) {
-- 
2.49.0


From a2ff053d95a8c7e056150f173e67757498a16232 Mon Sep 17 00:00:00 2001
From: Emil Renner Berthing <emil.renner.berthing@canonical.com>
Date: Sat, 22 Jul 2023 18:50:49 +0200
Subject: [PATCH 18/31] usb: cdns3: starfive: Initialize JH7100 host mode

These settings are directly copied from StarFive's port of u-boot
for the JH7100:

  /* config strap */
  _SET_SYSCON_REG_SCFG_usb0_mode_strap(0x2);
  _SET_SYSCON_REG_SCFG_usb7_PLL_EN(0x1);
  _SET_SYSCON_REG_SCFG_usb7_U3_EQ_EN(0x1);
  _SET_SYSCON_REG_SCFG_usb7_U3_SSRX_SEL(0x1);
  _SET_SYSCON_REG_SCFG_usb7_U3_SSTX_SEL(0x1);
  _SET_SYSCON_REG_SCFG_usb3_utmi_iddig(0x1);

Signed-off-by: Emil Renner Berthing <emil.renner.berthing@canonical.com>
---
 arch/riscv/boot/dts/starfive/jh7100.dtsi |  6 ++++
 drivers/usb/cdns3/cdns3-starfive.c       | 43 ++++++++++++++++++++++++
 2 files changed, 49 insertions(+)

diff --git a/arch/riscv/boot/dts/starfive/jh7100.dtsi b/arch/riscv/boot/dts/starfive/jh7100.dtsi
index b9a6f44526..7dfb6cc215 100644
--- a/arch/riscv/boot/dts/starfive/jh7100.dtsi
+++ b/arch/riscv/boot/dts/starfive/jh7100.dtsi
@@ -255,6 +255,11 @@ audrst: reset-controller@10490000 {
 			#reset-cells = <1>;
 		};
 
+		sysaudio: syscon@104a0000 {
+			compatible = "starfive,jh7100-sysaudio", "syscon";
+			reg = <0x0 0x104a0000 0x0 0x10000>;
+		};
+
 		usb3: usb@104c0000 {
 			compatible = "starfive,jh7100-usb";
 			ranges = <0x0 0x0 0x104c0000 0x100000>;
@@ -268,6 +273,7 @@ usb3: usb@104c0000 {
 			resets = <&rstgen JH7100_RSTN_USB_AXI>,
 			         <&rstgen JH7100_RSTN_USBNOC_AXI>;
 			reset-names = "axi", "nocaxi";
+			starfive,syscon = <&sysaudio>;
 			status = "disabled";
 
 			usb_cdns3: usb@0 {
diff --git a/drivers/usb/cdns3/cdns3-starfive.c b/drivers/usb/cdns3/cdns3-starfive.c
index 35063825b6..9834d49a9a 100644
--- a/drivers/usb/cdns3/cdns3-starfive.c
+++ b/drivers/usb/cdns3/cdns3-starfive.c
@@ -20,6 +20,19 @@
 #include <linux/usb/otg.h>
 #include "core.h"
 
+#define JH7100_USB0			0x20
+#define JH7100_USB0_MODE_STRAP_MASK	GENMASK(2, 0)
+#define JH7100_USB0_MODE_STRAP_HOST	2
+
+#define JH7100_USB3			0x2c
+#define JH7100_USB3_UTMI_IDDIG		BIT(21)
+
+#define JH7100_USB7			0x3c
+#define JH7100_USB7_SSRX_SEL		BIT(18)
+#define JH7100_USB7_SSTX_SEL		BIT(19)
+#define JH7100_USB7_PLL_EN		BIT(23)
+#define JH7100_USB7_EQ_EN		BIT(25)
+
 #define JH7110_STRAP_HOST		BIT(17)
 #define JH7110_STRAP_DEVICE		BIT(18)
 #define JH7110_STRAP_MASK		GENMASK(18, 16)
@@ -42,6 +55,36 @@ typedef int (cdns_starfive_mode_init_t)(struct device *dev, struct cdns_starfive
 
 static int cdns_jh7100_mode_init(struct device *dev, struct cdns_starfive *data)
 {
+	struct regmap *syscon;
+	enum usb_dr_mode mode;
+
+	syscon = syscon_regmap_lookup_by_phandle(dev->of_node, "starfive,syscon");
+	if (IS_ERR(syscon))
+		return dev_err_probe(dev, PTR_ERR(syscon),
+				     "failed to get starfive,syscon\n");
+
+	/* dr mode setting */
+	mode = usb_get_dr_mode(dev);
+
+	switch (mode) {
+	case USB_DR_MODE_HOST:
+		regmap_update_bits(syscon, JH7100_USB0,
+				   JH7100_USB0_MODE_STRAP_MASK, JH7100_USB0_MODE_STRAP_HOST);
+		regmap_update_bits(syscon, JH7100_USB7,
+				   JH7100_USB7_PLL_EN, JH7100_USB7_PLL_EN);
+		regmap_update_bits(syscon, JH7100_USB7,
+				   JH7100_USB7_EQ_EN, JH7100_USB7_EQ_EN);
+		regmap_update_bits(syscon, JH7100_USB7,
+				   JH7100_USB7_SSRX_SEL, JH7100_USB7_SSRX_SEL);
+		regmap_update_bits(syscon, JH7100_USB7,
+				   JH7100_USB7_SSTX_SEL, JH7100_USB7_SSTX_SEL);
+		regmap_update_bits(syscon, JH7100_USB3,
+				   JH7100_USB3_UTMI_IDDIG, JH7100_USB3_UTMI_IDDIG);
+		break;
+	default:
+		break;
+	}
+
 	return 0;
 }
 
-- 
2.49.0


From dc8fab2a5cb03c23ba620f838d3749659fd24095 Mon Sep 17 00:00:00 2001
From: Matteo Croce <technoboy85@gmail.com>
Date: Fri, 21 May 2021 03:26:38 +0200
Subject: [PATCH 19/31] net: stmmac: use GFP_DMA32

Signed-off-by: Matteo Croce <mcroce@microsoft.com>
---
 drivers/net/ethernet/stmicro/stmmac/stmmac_main.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
index c0ae7db96f..ad60168ac7 100644
--- a/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
+++ b/drivers/net/ethernet/stmicro/stmmac/stmmac_main.c
@@ -1496,7 +1496,7 @@ static int stmmac_init_rx_buffers(struct stmmac_priv *priv,
 {
 	struct stmmac_rx_queue *rx_q = &dma_conf->rx_queue[queue];
 	struct stmmac_rx_buffer *buf = &rx_q->buf_pool[i];
-	gfp_t gfp = (GFP_ATOMIC | __GFP_NOWARN);
+	gfp_t gfp = (GFP_ATOMIC | __GFP_NOWARN | GFP_DMA32);
 
 	if (priv->dma_cap.host_dma_width <= 32)
 		gfp |= GFP_DMA32;
@@ -4817,7 +4817,7 @@ static inline void stmmac_rx_refill(struct stmmac_priv *priv, u32 queue)
 	struct stmmac_rx_queue *rx_q = &priv->dma_conf.rx_queue[queue];
 	int dirty = stmmac_rx_dirty(priv, queue);
 	unsigned int entry = rx_q->dirty_rx;
-	gfp_t gfp = (GFP_ATOMIC | __GFP_NOWARN);
+	gfp_t gfp = (GFP_ATOMIC | __GFP_NOWARN | GFP_DMA32);
 
 	if (priv->dma_cap.host_dma_width <= 32)
 		gfp |= GFP_DMA32;
-- 
2.49.0


From 2aac94601f63acb75fe142af2bc02db2a37e91bb Mon Sep 17 00:00:00 2001
From: Emil Renner Berthing <kernel@esmil.dk>
Date: Thu, 14 Oct 2021 20:56:54 +0200
Subject: [PATCH 20/31] serial: 8250_dw: Add starfive,jh7100-hsuart compatible

This adds a compatible for the high speed UARTs on the StarFive JH7100
RISC-V SoC. Just like the regular uarts we also need to keep the input
clocks at their default rate and rely only on the divisor in the UART.

Signed-off-by: Emil Renner Berthing <kernel@esmil.dk>
---
 drivers/tty/serial/8250/8250_dw.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/drivers/tty/serial/8250/8250_dw.c b/drivers/tty/serial/8250/8250_dw.c
index 6afcf27db3..ada350c5e8 100644
--- a/drivers/tty/serial/8250/8250_dw.c
+++ b/drivers/tty/serial/8250/8250_dw.c
@@ -761,6 +761,7 @@ static const struct of_device_id dw8250_of_match[] = {
 	{ .compatible = "marvell,armada-38x-uart", .data = &dw8250_armada_38x_data },
 	{ .compatible = "renesas,rzn1-uart", .data = &dw8250_renesas_rzn1_data },
 	{ .compatible = "sophgo,sg2044-uart", .data = &dw8250_skip_set_rate_data },
+	{ .compatible = "starfive,jh7100-hsuart", .data = &dw8250_skip_set_rate_data },
 	{ .compatible = "starfive,jh7100-uart", .data = &dw8250_skip_set_rate_data },
 	{ /* Sentinel */ }
 };
-- 
2.49.0


From 5b51639dd5ee7b83c739d36089211406625b304e Mon Sep 17 00:00:00 2001
From: Samin Guo <samin.guo@starfivetech.com>
Date: Fri, 8 Jan 2021 03:11:04 +0800
Subject: [PATCH 21/31] drivers/tty/serial/8250: update driver for JH7100

---
 drivers/tty/serial/8250/8250_port.c | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/drivers/tty/serial/8250/8250_port.c b/drivers/tty/serial/8250/8250_port.c
index 442967a6cd..c7aff7644a 100644
--- a/drivers/tty/serial/8250/8250_port.c
+++ b/drivers/tty/serial/8250/8250_port.c
@@ -68,8 +68,16 @@ static const struct serial8250_config uart_config[] = {
 	},
 	[PORT_16550] = {
 		.name		= "16550",
+#ifdef CONFIG_SOC_STARFIVE
+		.fifo_size	= 16,
+		.tx_loadsz	= 16,
+		.fcr		= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_00,
+		.rxtrig_bytes	= {1, 4, 8, 14},
+		.flags		= UART_CAP_FIFO,
+#else
 		.fifo_size	= 1,
 		.tx_loadsz	= 1,
+#endif
 	},
 	[PORT_16550A] = {
 		.name		= "16550A",
-- 
2.49.0


From 66f69eeb8607e03084c3cacda767e1178b5a90d2 Mon Sep 17 00:00:00 2001
From: Huan Feng <huan.feng@starfivetech.com>
Date: Fri, 8 Jan 2021 03:35:42 +0800
Subject: [PATCH 22/31] hwrng: Add StarFive JH7100 Random Number Generator
 driver

Signed-off-by: Emil Renner Berthing <kernel@esmil.dk>
---
 drivers/char/hw_random/Kconfig            |  13 ++
 drivers/char/hw_random/Makefile           |   1 +
 drivers/char/hw_random/starfive-vic-rng.c | 254 ++++++++++++++++++++++
 drivers/char/hw_random/starfive-vic-rng.h | 167 ++++++++++++++
 4 files changed, 435 insertions(+)
 create mode 100644 drivers/char/hw_random/starfive-vic-rng.c
 create mode 100644 drivers/char/hw_random/starfive-vic-rng.h

diff --git a/drivers/char/hw_random/Kconfig b/drivers/char/hw_random/Kconfig
index 17854f0523..2bc48dade5 100644
--- a/drivers/char/hw_random/Kconfig
+++ b/drivers/char/hw_random/Kconfig
@@ -348,6 +348,19 @@ config HW_RANDOM_POWERNV
 
 	  If unsure, say Y.
 
+config HW_RANDOM_STARFIVE_VIC
+	tristate "Starfive VIC Random Number Generator support"
+	depends on HW_RANDOM && (SOC_STARFIVE || COMPILE_TEST)
+	default SOC_STARFIVE
+	help
+	  This driver provides kernel-side support for the Random Number
+	  Generator hardware found on Starfive VIC SoC.
+
+	  To compile this driver as a module, choose M here: the
+	  module will be called starfive-vic-rng.
+
+	  If unsure, say Y.
+
 config HW_RANDOM_HISI
 	tristate "Hisilicon Random Number Generator support"
 	depends on ARCH_HISI || COMPILE_TEST
diff --git a/drivers/char/hw_random/Makefile b/drivers/char/hw_random/Makefile
index b9132b3f5d..9fcb7a87b1 100644
--- a/drivers/char/hw_random/Makefile
+++ b/drivers/char/hw_random/Makefile
@@ -29,6 +29,7 @@ obj-$(CONFIG_HW_RANDOM_OCTEON) += octeon-rng.o
 obj-$(CONFIG_HW_RANDOM_NOMADIK) += nomadik-rng.o
 obj-$(CONFIG_HW_RANDOM_PSERIES) += pseries-rng.o
 obj-$(CONFIG_HW_RANDOM_POWERNV) += powernv-rng.o
+obj-$(CONFIG_HW_RANDOM_STARFIVE_VIC)	+= starfive-vic-rng.o
 obj-$(CONFIG_HW_RANDOM_HISI)	+= hisi-rng.o
 obj-$(CONFIG_HW_RANDOM_HISTB) += histb-rng.o
 obj-$(CONFIG_HW_RANDOM_BCM2835) += bcm2835-rng.o
diff --git a/drivers/char/hw_random/starfive-vic-rng.c b/drivers/char/hw_random/starfive-vic-rng.c
new file mode 100644
index 0000000000..3e25574dea
--- /dev/null
+++ b/drivers/char/hw_random/starfive-vic-rng.c
@@ -0,0 +1,254 @@
+/*
+ ******************************************************************************
+ * @file  starfive-vic-rng.c
+ * @author  StarFive Technology
+ * @version  V1.0
+ * @date  08/13/2020
+ * @brief
+ ******************************************************************************
+ * @copy
+ *
+ * THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+ * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+ * TIME. AS A RESULT, STARFIVE SHALL NOT BE HELD LIABLE FOR ANY
+ * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+ * FROM THE CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+ * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+ *
+ * COPYRIGHT 2020 Shanghai StarFive Technology Co., Ltd.
+ */
+#include <linux/err.h>
+#include <linux/kernel.h>
+#include <linux/hw_random.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/platform_device.h>
+#include <linux/interrupt.h>
+#include <linux/random.h>
+
+#include "starfive-vic-rng.h"
+
+#define to_vic_rng(p)	container_of(p, struct vic_rng, rng)
+
+struct vic_rng {
+	struct device	*dev;
+	void __iomem	*base;
+	struct hwrng	rng;
+};
+
+static inline void vic_wait_till_idle(struct vic_rng *hrng)
+{
+	while(readl(hrng->base + VIC_STAT) & VIC_STAT_BUSY)
+		/* wait */;
+}
+
+static inline void vic_rng_irq_mask_clear(struct vic_rng *hrng)
+{
+	// clear register: ISTAT
+	u32 data = readl(hrng->base + VIC_ISTAT);
+	writel(data, hrng->base + VIC_ISTAT);
+	writel(0, hrng->base + VIC_ALARM);
+}
+
+static int vic_trng_cmd(struct vic_rng *hrng, u32 cmd) {
+	int res = 0;
+	// wait till idle
+	vic_wait_till_idle(hrng);
+	switch (cmd) {
+	case VIC_CTRL_CMD_NOP:
+	case VIC_CTRL_CMD_GEN_NOISE:
+	case VIC_CTRL_CMD_GEN_NONCE:
+	case VIC_CTRL_CMD_CREATE_STATE:
+	case VIC_CTRL_CMD_RENEW_STATE:
+	case VIC_CTRL_CMD_REFRESH_ADDIN:
+	case VIC_CTRL_CMD_GEN_RANDOM:
+	case VIC_CTRL_CMD_ADVANCE_STATE:
+	case VIC_CTRL_CMD_KAT:
+	case VIC_CTRL_CMD_ZEROIZE:
+		writel(cmd, hrng->base + VIC_CTRL);
+		break;
+	default:
+		res = -1;
+		break;
+	}
+
+	return res;
+}
+
+static int vic_rng_init(struct hwrng *rng)
+{
+	struct vic_rng *hrng = to_vic_rng(rng);
+
+	// wait till idle
+
+	// clear register: ISTAT
+	vic_rng_irq_mask_clear(hrng);
+
+	// set mission mode
+	writel(VIC_SMODE_SECURE_EN(1), hrng->base + VIC_SMODE);
+
+	vic_trng_cmd(hrng, VIC_CTRL_CMD_GEN_NOISE);
+	vic_wait_till_idle(hrng);
+
+	// set interrupt
+	writel(VIC_IE_ALL, hrng->base + VIC_IE);
+
+	// zeroize
+	vic_trng_cmd(hrng, VIC_CTRL_CMD_ZEROIZE);
+
+	vic_wait_till_idle(hrng);
+
+	return 0;
+}
+
+static irqreturn_t vic_rng_irq(int irq, void *priv)
+{
+	u32 status, val;
+	struct vic_rng *hrng = (struct vic_rng *)priv;
+
+	/*
+	 * clearing the interrupt will also clear the error register
+	 * read error and status before clearing
+	 */
+	status = readl(hrng->base + VIC_ISTAT);
+
+	if (status & VIC_ISTAT_ALARMS) {
+		writel(VIC_ISTAT_ALARMS, hrng->base + VIC_ISTAT);
+		val = readl(hrng->base + VIC_ALARM);
+		if (val & VIC_ALARM_ILLEGAL_CMD_SEQ) {
+			writel(VIC_ALARM_ILLEGAL_CMD_SEQ, hrng->base + VIC_ALARM);
+			//dev_info(hrng->dev, "ILLEGAL CMD SEQ: LAST_CMD=0x%x\r\n",
+			//VIC_STAT_LAST_CMD(readl(hrng->base + VIC_STAT)));
+		} else {
+			dev_info(hrng->dev, "Failed test: %x\r\n", val);
+		}
+	}
+
+	if (status & VIC_ISTAT_ZEROIZE) {
+		writel(VIC_ISTAT_ZEROIZE, hrng->base + VIC_ISTAT);
+		//dev_info(hrng->dev, "zeroized\r\n");
+	}
+
+	if (status & VIC_ISTAT_KAT_COMPLETE) {
+		writel(VIC_ISTAT_KAT_COMPLETE, hrng->base + VIC_ISTAT);
+		//dev_info(hrng->dev, "kat_completed\r\n");
+	}
+
+	if (status & VIC_ISTAT_NOISE_RDY) {
+		writel(VIC_ISTAT_NOISE_RDY, hrng->base + VIC_ISTAT);
+		//dev_info(hrng->dev, "noise_rdy\r\n");
+	}
+
+	if (status & VIC_ISTAT_DONE) {
+		writel(VIC_ISTAT_DONE, hrng->base + VIC_ISTAT);
+		//dev_info(hrng->dev, "done\r\n");
+		/*
+		if (VIC_STAT_LAST_CMD(readl(hrng->base + VIC_STAT)) ==
+		    VIC_CTRL_CMD_GEN_RANDOM) {
+			dev_info(hrng->dev, "Need Update Buffer\r\n");
+		}
+		*/
+	}
+	vic_rng_irq_mask_clear(hrng);
+
+	return IRQ_HANDLED;
+}
+
+static void vic_rng_cleanup(struct hwrng *rng)
+{
+	struct vic_rng *hrng = to_vic_rng(rng);
+
+	writel(0, hrng->base + VIC_CTRL);
+}
+
+static int vic_rng_read(struct hwrng *rng, void *buf, size_t max, bool wait)
+{
+	struct vic_rng *hrng = to_vic_rng(rng);
+
+	vic_trng_cmd(hrng, VIC_CTRL_CMD_ZEROIZE);
+	vic_trng_cmd(hrng, VIC_CTRL_CMD_GEN_NOISE);
+	vic_trng_cmd(hrng, VIC_CTRL_CMD_CREATE_STATE);
+
+	vic_wait_till_idle(hrng);
+	max = min_t(size_t, max, (VIC_RAND_LEN * 4));
+
+	writel(0x0, hrng->base + VIC_MODE);
+	vic_trng_cmd(hrng, VIC_CTRL_CMD_GEN_RANDOM);
+
+	vic_wait_till_idle(hrng);
+	memcpy_fromio(buf, hrng->base + VIC_RAND0, max);
+	vic_trng_cmd(hrng, VIC_CTRL_CMD_ZEROIZE);
+
+	vic_wait_till_idle(hrng);
+	return max;
+}
+
+static int vic_rng_probe(struct platform_device *pdev)
+{
+	int ret;
+	int irq;
+	struct vic_rng *rng;
+	struct resource *res;
+
+	rng = devm_kzalloc(&pdev->dev, sizeof(*rng), GFP_KERNEL);
+	if (!rng){
+		return -ENOMEM;
+	}
+
+	platform_set_drvdata(pdev, rng);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	rng->base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(rng->base)){
+		return PTR_ERR(rng->base);
+	}
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq <= 0)
+		return irq;
+
+	ret = devm_request_irq(&pdev->dev, irq, vic_rng_irq, 0, pdev->name,
+				(void *)rng);
+	if (ret) {
+		dev_err(&pdev->dev, "Can't get interrupt working.\n");
+		return ret;
+	}
+
+	rng->rng.name = pdev->name;
+	rng->rng.init = vic_rng_init;
+	rng->rng.cleanup = vic_rng_cleanup;
+	rng->rng.read = vic_rng_read;
+
+	rng->dev = &pdev->dev;
+
+	ret = devm_hwrng_register(&pdev->dev, &rng->rng);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to register hwrng\n");
+		return ret;
+	}
+
+	dev_info(&pdev->dev, "Initialized\n");
+
+	return 0;
+}
+
+static const struct of_device_id vic_rng_dt_ids[] = {
+	{ .compatible = "starfive,vic-rng" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, vic_rng_dt_ids);
+
+static struct platform_driver vic_rng_driver = {
+	.probe		= vic_rng_probe,
+	.driver		= {
+		.name		= "vic-rng",
+		.of_match_table	= vic_rng_dt_ids,
+	},
+};
+
+module_platform_driver(vic_rng_driver);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Huan Feng <huan.feng@starfivetech.com>");
+MODULE_DESCRIPTION("Starfive VIC random number generator driver");
diff --git a/drivers/char/hw_random/starfive-vic-rng.h b/drivers/char/hw_random/starfive-vic-rng.h
new file mode 100644
index 0000000000..b3bbabde0c
--- /dev/null
+++ b/drivers/char/hw_random/starfive-vic-rng.h
@@ -0,0 +1,167 @@
+/*
+ ******************************************************************************
+ * @file  starfive-vic-rng.h
+ * @author  StarFive Technology
+ * @version  V1.0
+ * @date  08/13/2020
+ * @brief
+ ******************************************************************************
+ * @copy
+ *
+ * THE PRESENT SOFTWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
+ * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
+ * TIME. AS A RESULT, STARFIVE SHALL NOT BE HELD LIABLE FOR ANY
+ * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
+ * FROM THE CONTENT OF SUCH SOFTWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
+ * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
+ *
+ * COPYRIGHT 2020 Shanghai StarFive Technology Co., Ltd.
+ */
+
+#define VIC_CTRL		0x00
+#define VIC_MODE		0x04
+#define VIC_SMODE		0x08
+#define VIC_STAT		0x0C
+#define VIC_IE			0x10
+#define VIC_ISTAT		0x14
+#define VIC_ALARM		0x18
+#define VIC_BUILD_ID		0x1C
+#define VIC_FEATURES		0x20
+#define VIC_RAND0		0x24
+#define VIC_NPA_DATA0		0x34
+#define VIC_SEED0		0x74
+#define VIC_IA_RDATA		0xA4
+#define VIC_IA_WDATA		0xA8
+#define VIC_IA_ADDR		0xAC
+#define VIC_IA_CMD		0xB0
+
+/* CTRL */
+#define VIC_CTRL_CMD_NOP		0
+#define VIC_CTRL_CMD_GEN_NOISE		1
+#define VIC_CTRL_CMD_GEN_NONCE		2
+#define VIC_CTRL_CMD_CREATE_STATE	3
+#define VIC_CTRL_CMD_RENEW_STATE	4
+#define VIC_CTRL_CMD_REFRESH_ADDIN	5
+#define VIC_CTRL_CMD_GEN_RANDOM		6
+#define VIC_CTRL_CMD_ADVANCE_STATE	7
+#define VIC_CTRL_CMD_KAT		8
+#define VIC_CTRL_CMD_ZEROIZE		15
+
+/* MODE */
+#define _VIC_MODE_ADDIN_PRESENT		4
+#define _VIC_MODE_PRED_RESIST		3
+#define _VIC_MODE_KAT_SEL		2
+#define _VIC_MODE_KAT_VEC		1
+#define _VIC_MODE_SEC_ALG		0
+
+#define VIC_MODE_ADDIN_PRESENT	(1UL << _VIC_MODE_ADDIN_PRESENT)
+#define VIC_MODE_PRED_RESIST	(1UL << _VIC_MODE_PRED_RESIST)
+#define VIC_MODE_KAT_SEL	(1UL << _VIC_MODE_KAT_SEL)
+#define VIC_MODE_KAT_VEC	(1UL << _VIC_MODE_KAT_VEC)
+#define VIC_MODE_SEC_ALG	(1UL << _VIC_MODE_SEC_ALG)
+
+/* SMODE */
+#define _VIC_SMODE_MAX_REJECTS	2
+#define _VIC_SMODE_SECURE_EN	1
+#define _VIC_SMODE_NONCE	0
+
+#define VIC_SMODE_MAX_REJECTS(x)	((x) << _VIC_SMODE_MAX_REJECTS)
+#define VIC_SMODE_SECURE_EN(x)		((x) << _VIC_SMODE_SECURE_EN)
+#define VIC_SMODE_NONCE			(1UL << _VIC_SMODE_NONCE)
+
+/* STAT */
+#define _VIC_STAT_BUSY		31
+#define _VIC_STAT_DRBG_STATE	7
+#define _VIC_STAT_SECURE	6
+#define _VIC_STAT_NONCE_MODE	5
+#define _VIC_STAT_SEC_ALG	4
+#define _VIC_STAT_LAST_CMD	0
+
+#define VIC_STAT_BUSY		(1UL << _VIC_STAT_BUSY)
+#define VIC_STAT_DRBG_STATE	(1UL << _VIC_STAT_DRBG_STATE)
+#define VIC_STAT_SECURE		(1UL << _VIC_STAT_SECURE)
+#define VIC_STAT_NONCE_MODE	(1UL << _VIC_STAT_NONCE_MODE)
+#define VIC_STAT_SEC_ALG	(1UL << _VIC_STAT_SEC_ALG)
+#define VIC_STAT_LAST_CMD(x)	(((x) >> _VIC_STAT_LAST_CMD) & 0xF)
+
+/* IE */
+#define _VIC_IE_GLBL		31
+#define _VIC_IE_DONE		4
+#define _VIC_IE_ALARMS		3
+#define _VIC_IE_NOISE_RDY	2
+#define _VIC_IE_KAT_COMPLETE	1
+#define _VIC_IE_ZEROIZE		0
+
+#define VIC_IE_GLBL		(1UL << _VIC_IE_GLBL)
+#define VIC_IE_DONE		(1UL << _VIC_IE_DONE)
+#define VIC_IE_ALARMS		(1UL << _VIC_IE_ALARMS)
+#define VIC_IE_NOISE_RDY	(1UL << _VIC_IE_NOISE_RDY)
+#define VIC_IE_KAT_COMPLETE	(1UL << _VIC_IE_KAT_COMPLETE)
+#define VIC_IE_ZEROIZE		(1UL << _VIC_IE_ZEROIZE)
+#define VIC_IE_ALL		(VIC_IE_GLBL | VIC_IE_DONE | VIC_IE_ALARMS | \
+				 VIC_IE_NOISE_RDY | VIC_IE_KAT_COMPLETE | VIC_IE_ZEROIZE)
+
+/* ISTAT */
+#define _VIC_ISTAT_DONE		4
+#define _VIC_ISTAT_ALARMS	3
+#define _VIC_ISTAT_NOISE_RDY	2
+#define _VIC_ISTAT_KAT_COMPLETE	1
+#define _VIC_ISTAT_ZEROIZE	0
+
+#define VIC_ISTAT_DONE		(1UL << _VIC_ISTAT_DONE)
+#define VIC_ISTAT_ALARMS	(1UL << _VIC_ISTAT_ALARMS)
+#define VIC_ISTAT_NOISE_RDY	(1UL << _VIC_ISTAT_NOISE_RDY)
+#define VIC_ISTAT_KAT_COMPLETE	(1UL << _VIC_ISTAT_KAT_COMPLETE)
+#define VIC_ISTAT_ZEROIZE	(1UL << _VIC_ISTAT_ZEROIZE)
+
+/* ALARMS */
+#define VIC_ALARM_ILLEGAL_CMD_SEQ			(1UL << 4)
+#define VIC_ALARM_FAILED_TEST_ID_OK			0
+#define VIC_ALARM_FAILED_TEST_ID_KAT_STAT		1
+#define VIC_ALARM_FAILED_TEST_ID_KAT			2
+#define VIC_ALARM_FAILED_TEST_ID_MONOBIT		3
+#define VIC_ALARM_FAILED_TEST_ID_RUN			4
+#define VIC_ALARM_FAILED_TEST_ID_LONGRUN		5
+#define VIC_ALARM_FAILED_TEST_ID_AUTOCORRELATION	6
+#define VIC_ALARM_FAILED_TEST_ID_POKER			7
+#define VIC_ALARM_FAILED_TEST_ID_REPETITION_COUNT	8
+#define VIC_ALARM_FAILED_TEST_ID_ADAPATIVE_PROPORTION	9
+
+/* BUILD_ID */
+#define VIC_BUILD_ID_STEPPING(x)		(((x) >> 28) & 0xF)
+#define VIC_BUILD_ID_EPN(x)			((x) & 0xFFFF)
+
+/* FEATURES */
+#define VIC_FEATURES_AES_256(x)			(((x) >> 9) & 1)
+#define VIC_FEATURES_EXTRA_PS_PRESENT(x)	(((x) >> 8) & 1)
+#define VIC_FEATURES_DIAG_LEVEL_NS(x)		(((x) >> 7) & 1)
+#define VIC_FEATURES_DIAG_LEVEL_CLP800(x)	(((x) >> 4) & 7)
+#define VIC_FEATURES_DIAG_LEVEL_ST_HLT(x)	(((x) >> 1) & 7)
+#define VIC_FEATURES_SECURE_RST_STATE(x)	((x) & 1)
+
+/* IA_CMD */
+#define VIC_IA_CMD_GO			(1UL << 31)
+#define VIC_IA_CMD_WR			(1)
+
+#define _VIC_SMODE_MAX_REJECTS_MASK	255UL
+#define _VIC_SMODE_SECURE_EN_MASK	1UL
+#define _VIC_SMODE_NONCE_MASK		1UL
+#define _VIC_MODE_SEC_ALG_MASK		1UL
+#define _VIC_MODE_ADDIN_PRESENT_MASK	1UL
+#define _VIC_MODE_PRED_RESIST_MASK	1UL
+
+#define VIC_SMODE_SET_MAX_REJECTS(y, x)	(((y) & ~(_VIC_SMODE_MAX_REJECTS_MASK << _VIC_SMODE_MAX_REJECTS)) | ((x) << _VIC_SMODE_MAX_REJECTS))
+#define VIC_SMODE_SET_SECURE_EN(y, x)	(((y) & ~(_VIC_SMODE_SECURE_EN_MASK   << _VIC_SMODE_SECURE_EN))   | ((x) << _VIC_SMODE_SECURE_EN))
+#define VIC_SMODE_SET_NONCE(y, x)	(((y) & ~(_VIC_SMODE_NONCE_MASK       << _VIC_SMODE_NONCE))       | ((x) << _VIC_SMODE_NONCE))
+#define VIC_SMODE_GET_MAX_REJECTS(x)	(((x) >> _VIC_SMODE_MAX_REJECTS) & _VIC_SMODE_MAX_REJECTS_MASK)
+#define VIC_SMODE_GET_SECURE_EN(x)	(((x) >> _VIC_SMODE_SECURE_EN)   & _VIC_SMODE_SECURE_EN_MASK)
+#define VIC_SMODE_GET_NONCE(x)		(((x) >> _VIC_SMODE_NONCE)       & _VIC_SMODE_NONCE_MASK)
+
+#define VIC_MODE_SET_SEC_ALG(y, x)	(((y) & ~(_VIC_MODE_SEC_ALG_MASK       << _VIC_MODE_SEC_ALG))	| ((x) << _VIC_MODE_SEC_ALG))
+#define VIC_MODE_SET_PRED_RESIST(y, x)	(((y) & ~(_VIC_MODE_PRED_RESIST_MASK   << _VIC_MODE_PRED_RESIST))    | ((x) << _VIC_MODE_PRED_RESIST))
+#define VIC_MODE_SET_ADDIN_PRESENT(y, x) (((y) & ~(_VIC_MODE_ADDIN_PRESENT_MASK << _VIC_MODE_ADDIN_PRESENT))  | ((x) << _VIC_MODE_ADDIN_PRESENT))
+#define VIC_MODE_GET_SEC_ALG(x)		(((x) >> _VIC_MODE_SEC_ALG)       & _VIC_MODE_SEC_ALG_MASK)
+#define VIC_MODE_GET_PRED_RESIST(x)	(((x) >> _VIC_MODE_PRED_RESIST)   & _VIC_MODE_PRED_RESIST_MASK)
+#define VIC_MODE_GET_ADDIN_PRESENT(x)	(((x) >> _VIC_MODE_ADDIN_PRESENT) & _VIC_MODE_ADDIN_PRESENT_MASK)
+
+#define VIC_RAND_LEN 4
-- 
2.49.0


From 9bd1cadca6614e9fddf6f41603ee54e3c514ddf4 Mon Sep 17 00:00:00 2001
From: Geert Uytterhoeven <geert@linux-m68k.org>
Date: Thu, 27 May 2021 20:13:43 +0200
Subject: [PATCH 23/31] [WIP] dt-bindings: dma: dw-axi-dmac: Increase DMA
 channel limit to 16

The first DMAC instance in the StarFive JH7100 SoC supports 16 DMA
channels.

FIXME Given there are more changes to the driver than just increasing
      DMAC_MAX_CHANNELS, we probably need a new compatible value, too.

Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
---
 Documentation/devicetree/bindings/dma/snps,dw-axi-dmac.yaml | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/Documentation/devicetree/bindings/dma/snps,dw-axi-dmac.yaml b/Documentation/devicetree/bindings/dma/snps,dw-axi-dmac.yaml
index 525f5f3932..51b2aedb6f 100644
--- a/Documentation/devicetree/bindings/dma/snps,dw-axi-dmac.yaml
+++ b/Documentation/devicetree/bindings/dma/snps,dw-axi-dmac.yaml
@@ -57,7 +57,7 @@ properties:
 
   dma-channels:
     minimum: 1
-    maximum: 8
+    maximum: 16
 
   resets:
     minItems: 1
@@ -81,14 +81,14 @@ properties:
       Channel priority specifier associated with the DMA channels.
     $ref: /schemas/types.yaml#/definitions/uint32-array
     minItems: 1
-    maxItems: 8
+    maxItems: 16
 
   snps,block-size:
     description: |
       Channel block size specifier associated with the DMA channels.
     $ref: /schemas/types.yaml#/definitions/uint32-array
     minItems: 1
-    maxItems: 8
+    maxItems: 16
 
   snps,axi-max-burst-len:
     description: |
-- 
2.49.0


From 8f7a760ccb4f62d03e0e2e7f3e4af158c0c02bcf Mon Sep 17 00:00:00 2001
From: Samin Guo <samin.guo@starfivetech.com>
Date: Wed, 17 Nov 2021 14:50:45 +0800
Subject: [PATCH 24/31] dmaengine: dw-axi-dmac: Handle xfer start while
 non-idle

Signed-off-by: Samin Guo <samin.guo@starfivetech.com>
Signed-off-by: Curry Zhang <curry.zhang@starfivetech.com>
---
 drivers/dma/dw-axi-dmac/dw-axi-dmac-platform.c | 12 +++++++++++-
 drivers/dma/dw-axi-dmac/dw-axi-dmac.h          |  1 +
 2 files changed, 12 insertions(+), 1 deletion(-)

diff --git a/drivers/dma/dw-axi-dmac/dw-axi-dmac-platform.c b/drivers/dma/dw-axi-dmac/dw-axi-dmac-platform.c
index b23536645f..34a17589b5 100644
--- a/drivers/dma/dw-axi-dmac/dw-axi-dmac-platform.c
+++ b/drivers/dma/dw-axi-dmac/dw-axi-dmac-platform.c
@@ -428,11 +428,13 @@ static void axi_chan_block_xfer_start(struct axi_dma_chan *chan,
 	u32 irq_mask;
 	u8 lms = 0; /* Select AXI0 master for LLI fetching */
 
+	chan->is_err = false;
 	if (unlikely(axi_chan_is_hw_enable(chan))) {
 		dev_err(chan2dev(chan), "%s is non-idle!\n",
 			axi_chan_name(chan));
 
-		return;
+		axi_chan_disable(chan);
+		chan->is_err = true;
 	}
 
 	axi_dma_enable(chan->chip);
@@ -1074,6 +1076,14 @@ static noinline void axi_chan_handle_err(struct axi_dma_chan *chan, u32 status)
 			axi_chan_name(chan));
 		goto out;
 	}
+	if (chan->is_err) {
+		struct axi_dma_desc *desc = vd_to_axi_desc(vd);
+
+		axi_chan_block_xfer_start(chan, desc);
+		chan->is_err = false;
+		goto out;
+	}
+
 	/* Remove the completed descriptor from issued list */
 	list_del(&vd->node);
 
diff --git a/drivers/dma/dw-axi-dmac/dw-axi-dmac.h b/drivers/dma/dw-axi-dmac/dw-axi-dmac.h
index b842e6a8d9..abf995ca84 100644
--- a/drivers/dma/dw-axi-dmac/dw-axi-dmac.h
+++ b/drivers/dma/dw-axi-dmac/dw-axi-dmac.h
@@ -50,6 +50,7 @@ struct axi_dma_chan {
 	struct dma_slave_config		config;
 	enum dma_transfer_direction	direction;
 	bool				cyclic;
+	bool 				is_err;
 	/* these other elements are all protected by vc.lock */
 	bool				is_paused;
 };
-- 
2.49.0


From c3fbee39ca85fe341afdd849d9a9b17f499973e5 Mon Sep 17 00:00:00 2001
From: Samin Guo <samin.guo@starfivetech.com>
Date: Wed, 17 Nov 2021 14:50:45 +0800
Subject: [PATCH 25/31] dmaengine: dw-axi-dmac: Add StarFive JH7100 support

Signed-off-by: Samin Guo <samin.guo@starfivetech.com>
Signed-off-by: Emil Renner Berthing <kernel@esmil.dk>
---
 drivers/dma/dw-axi-dmac/dw-axi-dmac-platform.c | 12 ++++++++++++
 drivers/dma/dw-axi-dmac/dw-axi-dmac.h          |  4 ++++
 2 files changed, 16 insertions(+)

diff --git a/drivers/dma/dw-axi-dmac/dw-axi-dmac-platform.c b/drivers/dma/dw-axi-dmac/dw-axi-dmac-platform.c
index 34a17589b5..cafd0b142f 100644
--- a/drivers/dma/dw-axi-dmac/dw-axi-dmac-platform.c
+++ b/drivers/dma/dw-axi-dmac/dw-axi-dmac-platform.c
@@ -723,8 +723,13 @@ static int dw_axi_dma_set_hw_desc(struct axi_dma_chan *chan,
 
 	hw_desc->lli->block_ts_lo = cpu_to_le32(block_ts - 1);
 
+#ifdef CONFIG_SOC_STARFIVE
+	ctllo |= DWAXIDMAC_BURST_TRANS_LEN_16 << CH_CTL_L_DST_MSIZE_POS |
+		 DWAXIDMAC_BURST_TRANS_LEN_16 << CH_CTL_L_SRC_MSIZE_POS;
+#else
 	ctllo |= DWAXIDMAC_BURST_TRANS_LEN_4 << CH_CTL_L_DST_MSIZE_POS |
 		 DWAXIDMAC_BURST_TRANS_LEN_4 << CH_CTL_L_SRC_MSIZE_POS;
+#endif
 	hw_desc->lli->ctl_lo = cpu_to_le32(ctllo);
 
 	set_desc_src_master(hw_desc);
@@ -1589,7 +1594,11 @@ static int dw_probe(struct platform_device *pdev)
 	 * Therefore, set constraint to 1024 * 4.
 	 */
 	dw->dma.dev->dma_parms = &dw->dma_parms;
+#ifdef CONFIG_SOC_STARFIVE
+	dma_set_max_seg_size(&pdev->dev, DMAC_MAX_BLK_SIZE);
+#else
 	dma_set_max_seg_size(&pdev->dev, MAX_BLOCK_SIZE);
+#endif
 	platform_set_drvdata(pdev, chip);
 
 	pm_runtime_enable(chip->dev);
@@ -1673,6 +1682,9 @@ static const struct of_device_id dw_dma_of_id_table[] = {
 	}, {
 		.compatible = "intel,kmb-axi-dma",
 		.data = (void *)AXI_DMA_FLAG_HAS_APB_REGS,
+	}, {
+		.compatible = "starfive,jh7100-axi-dma",
+		.data = (void *)(AXI_DMA_FLAG_HAS_RESETS | AXI_DMA_FLAG_USE_CFG2),
 	}, {
 		.compatible = "starfive,jh7110-axi-dma",
 		.data = (void *)(AXI_DMA_FLAG_HAS_RESETS | AXI_DMA_FLAG_USE_CFG2),
diff --git a/drivers/dma/dw-axi-dmac/dw-axi-dmac.h b/drivers/dma/dw-axi-dmac/dw-axi-dmac.h
index abf995ca84..f65e719c16 100644
--- a/drivers/dma/dw-axi-dmac/dw-axi-dmac.h
+++ b/drivers/dma/dw-axi-dmac/dw-axi-dmac.h
@@ -288,7 +288,11 @@ enum {
 #define CH_CTL_L_SRC_MAST		BIT(0)
 
 /* CH_CFG_H */
+#ifdef CONFIG_SOC_STARFIVE
+#define CH_CFG_H_PRIORITY_POS		15
+#else
 #define CH_CFG_H_PRIORITY_POS		17
+#endif
 #define CH_CFG_H_DST_PER_POS		12
 #define CH_CFG_H_SRC_PER_POS		7
 #define CH_CFG_H_HS_SEL_DST_POS		4
-- 
2.49.0


From 7f48e982fdb6e75a6ed768bbd03728061e4691fb Mon Sep 17 00:00:00 2001
From: Walker Chen <walker.chen@starfivetech.com>
Date: Wed, 17 Nov 2021 15:50:50 +0800
Subject: [PATCH 26/31] ASoC: starfive: Add StarFive JH7100 audio drivers

Signed-off-by: Michael Yan <michael.yan@starfivetech.com>
Signed-off-by: Jenny Zhang <jenny.zhang@starfivetech.com>
Signed-off-by: Walker Chen <walker.chen@starfivetech.com>
Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
[geertu: convert not to use asoc_xxx()]
Signed-off-by: Emil Renner Berthing <kernel@esmil.dk>
---
 sound/soc/Makefile                      |    1 +
 sound/soc/starfive/Kconfig              |   56 ++
 sound/soc/starfive/Makefile             |   21 +
 sound/soc/starfive/i2svad-pcm.c         |  249 ++++++
 sound/soc/starfive/i2svad.c             | 1041 +++++++++++++++++++++++
 sound/soc/starfive/i2svad.h             |  246 ++++++
 sound/soc/starfive/pdm.c                |  362 ++++++++
 sound/soc/starfive/pdm.h                |   42 +
 sound/soc/starfive/pwmdac-pcm.c         |  233 +++++
 sound/soc/starfive/pwmdac-transmitter.c |   81 ++
 sound/soc/starfive/pwmdac.c             |  862 +++++++++++++++++++
 sound/soc/starfive/pwmdac.h             |  161 ++++
 sound/soc/starfive/spdif-pcm.c          |  288 +++++++
 sound/soc/starfive/spdif.c              |  384 +++++++++
 sound/soc/starfive/spdif.h              |  154 ++++
 15 files changed, 4181 insertions(+)
 create mode 100644 sound/soc/starfive/i2svad-pcm.c
 create mode 100644 sound/soc/starfive/i2svad.c
 create mode 100644 sound/soc/starfive/i2svad.h
 create mode 100644 sound/soc/starfive/pdm.c
 create mode 100644 sound/soc/starfive/pdm.h
 create mode 100644 sound/soc/starfive/pwmdac-pcm.c
 create mode 100644 sound/soc/starfive/pwmdac-transmitter.c
 create mode 100644 sound/soc/starfive/pwmdac.c
 create mode 100644 sound/soc/starfive/pwmdac.h
 create mode 100644 sound/soc/starfive/spdif-pcm.c
 create mode 100644 sound/soc/starfive/spdif.c
 create mode 100644 sound/soc/starfive/spdif.h

diff --git a/sound/soc/Makefile b/sound/soc/Makefile
index 08baaa11d8..657c3bf5f9 100644
--- a/sound/soc/Makefile
+++ b/sound/soc/Makefile
@@ -63,6 +63,7 @@ obj-$(CONFIG_SND_SOC)	+= renesas/
 obj-$(CONFIG_SND_SOC)	+= rockchip/
 obj-$(CONFIG_SND_SOC)	+= samsung/
 obj-$(CONFIG_SND_SOC)	+= sdca/
+obj-$(CONFIG_SND_SOC)	+= starfive/
 obj-$(CONFIG_SND_SOC)	+= sof/
 obj-$(CONFIG_SND_SOC)	+= spear/
 obj-$(CONFIG_SND_SOC)	+= sprd/
diff --git a/sound/soc/starfive/Kconfig b/sound/soc/starfive/Kconfig
index 279ac5c1d3..b87f30cd41 100644
--- a/sound/soc/starfive/Kconfig
+++ b/sound/soc/starfive/Kconfig
@@ -22,3 +22,59 @@ config SND_SOC_JH7110_TDM
 	select SND_SOC_GENERIC_DMAENGINE_PCM
 	help
 	  Say Y or M if you want to add support for StarFive TDM driver.
+
+config SND_STARFIVE_SPDIF
+	tristate "starfive spdif"
+	depends on SOC_STARFIVE || COMPILE_TEST
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	select REGMAP_MMIO
+	help
+	  Say Y or M if you want to add support for codecs attached to the
+	  I2S interface on VIC vic_starlight board. You will also need to select
+	  the drivers for the rest of VIC audio subsystem.
+
+config SND_STARFIVE_SPDIF_PCM
+	bool "PCM PIO extension for spdif driver"
+	depends on SND_STARFIVE_SPDIF
+	help
+	 Say Y or N if you want to add a custom ALSA extension that registers
+	 a PCM and uses PIO to transfer data.
+
+config SND_STARFIVE_PWMDAC
+	tristate "starfive pwmdac Device Driver"
+	depends on SOC_STARFIVE || COMPILE_TEST
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	help
+	 Say Y or M if you want to add support for sf pwmdac driver.
+
+config SND_STARFIVE_PWMDAC_PCM
+	bool "PCM PIO extension for pwmdac driver"
+	depends on SND_STARFIVE_PWMDAC
+	help
+	 Say Y or N if you want to add a custom ALSA extension that registers
+	 a PCM and uses PIO to transfer data.
+
+config SND_STARFIVE_PDM
+	tristate "starfive pdm Device Driver"
+	depends on SOC_STARFIVE || COMPILE_TEST
+	select REGMAP_MMIO
+	help
+	 Say Y or M if you want to add support for sf pdm driver.
+
+config SND_STARFIVE_I2SVAD
+	tristate "starfive I2SVAD Device Driver"
+	depends on SOC_STARFIVE || COMPILE_TEST
+	select SND_SOC_GENERIC_DMAENGINE_PCM
+	help
+	 Say Y or M if you want to add support for I2SVAD driver for
+	 starfive I2SVAD device.
+
+config SND_STARFIVE_I2SVAD_PCM
+	bool "PCM PIO extension for I2SVAD driver"
+	depends on SND_STARFIVE_I2SVAD
+	help
+	 Say Y or N if you want to add a custom ALSA extension that registers
+	 a PCM and uses PIO to transfer data.
+
+	 This functionality is specially suited for I2SVAD devices that don't have
+	 DMA support.
diff --git a/sound/soc/starfive/Makefile b/sound/soc/starfive/Makefile
index 9e958f70ef..8da7a814f6 100644
--- a/sound/soc/starfive/Makefile
+++ b/sound/soc/starfive/Makefile
@@ -1,3 +1,24 @@
 # StarFive Platform Support
 obj-$(CONFIG_SND_SOC_JH7110_PWMDAC) += jh7110_pwmdac.o
 obj-$(CONFIG_SND_SOC_JH7110_TDM) += jh7110_tdm.o
+
+snd-soc-starfive-spdif-y := spdif.o
+snd-soc-starfive-spdif-$(CONFIG_SND_STARFIVE_SPDIF_PCM) += spdif-pcm.o
+
+obj-$(CONFIG_SND_STARFIVE_SPDIF) += snd-soc-starfive-spdif.o
+
+snd-soc-starfive-pwmdac-y := pwmdac.o
+snd-soc-starfive-pwmdac-$(CONFIG_SND_STARFIVE_PWMDAC_PCM) += pwmdac-pcm.o
+snd-soc-starfive-pwmdac-transmitter-y := pwmdac-transmitter.o
+
+obj-$(CONFIG_SND_STARFIVE_PWMDAC) += snd-soc-starfive-pwmdac.o
+obj-$(CONFIG_SND_STARFIVE_PWMDAC) += snd-soc-starfive-pwmdac-transmitter.o
+
+snd-soc-starfive-pdm-y := pdm.o
+
+obj-$(CONFIG_SND_STARFIVE_PDM) += snd-soc-starfive-pdm.o
+
+snd-soc-starfive-i2svad-y := i2svad.o
+snd-soc-starfive-i2svad-$(CONFIG_SND_STARFIVE_I2SVAD_PCM) += i2svad-pcm.o
+
+obj-$(CONFIG_SND_STARFIVE_I2SVAD) += snd-soc-starfive-i2svad.o
diff --git a/sound/soc/starfive/i2svad-pcm.c b/sound/soc/starfive/i2svad-pcm.c
new file mode 100644
index 0000000000..6f799bf5b8
--- /dev/null
+++ b/sound/soc/starfive/i2svad-pcm.c
@@ -0,0 +1,249 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#include <linux/io.h>
+#include <linux/rcupdate.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+
+#include "i2svad.h"
+
+#define BUFFER_BYTES_MAX	(3 * 2 * 8 * PERIOD_BYTES_MIN)
+#define PERIOD_BYTES_MIN	4096
+#define PERIODS_MIN		2
+
+#define i2svad_pcm_tx_fn(sample_bits) \
+static unsigned int i2svad_pcm_tx_##sample_bits(struct i2svad_dev *dev, \
+		struct snd_pcm_runtime *runtime, unsigned int tx_ptr, \
+		bool *period_elapsed) \
+{ \
+	const u##sample_bits (*p)[2] = (void *)runtime->dma_area; \
+	unsigned int period_pos = tx_ptr % runtime->period_size; \
+	int i; \
+\
+	for (i = 0; i < dev->fifo_th; i++) { \
+		iowrite32(p[tx_ptr][0], dev->i2s_base + LRBR_LTHR(0)); \
+		iowrite32(p[tx_ptr][1], dev->i2s_base + RRBR_RTHR(0)); \
+		period_pos++; \
+		if (++tx_ptr >= runtime->buffer_size) \
+			tx_ptr = 0; \
+	} \
+	*period_elapsed = period_pos >= runtime->period_size; \
+	return tx_ptr; \
+}
+
+#define i2svad_pcm_rx_fn(sample_bits) \
+static unsigned int i2svad_pcm_rx_##sample_bits(struct i2svad_dev *dev, \
+		struct snd_pcm_runtime *runtime, unsigned int rx_ptr, \
+		bool *period_elapsed) \
+{ \
+	u##sample_bits (*p)[2] = (void *)runtime->dma_area; \
+	unsigned int period_pos = rx_ptr % runtime->period_size; \
+	int i; \
+\
+	for (i = 0; i < dev->fifo_th; i++) { \
+		p[rx_ptr][0] = ioread32(dev->i2s_base + LRBR_LTHR(0)); \
+		p[rx_ptr][1] = ioread32(dev->i2s_base + RRBR_RTHR(0)); \
+		period_pos++; \
+		if (++rx_ptr >= runtime->buffer_size) \
+			rx_ptr = 0; \
+	} \
+	*period_elapsed = period_pos >= runtime->period_size; \
+	return rx_ptr; \
+}
+
+i2svad_pcm_tx_fn(16);
+i2svad_pcm_rx_fn(16);
+
+#undef i2svad_pcm_tx_fn
+#undef i2svad_pcm_rx_fn
+
+static const struct snd_pcm_hardware i2svad_pcm_hardware = {
+	.info = SNDRV_PCM_INFO_INTERLEAVED |
+		SNDRV_PCM_INFO_MMAP |
+		SNDRV_PCM_INFO_MMAP_VALID |
+		SNDRV_PCM_INFO_BLOCK_TRANSFER,
+	.rates = SNDRV_PCM_RATE_32000 |
+		SNDRV_PCM_RATE_44100 |
+		SNDRV_PCM_RATE_48000,
+	.rate_min = 32000,
+	.rate_max = 48000,
+	.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	.channels_min = 2,
+	.channels_max = 2,
+	.buffer_bytes_max = BUFFER_BYTES_MAX,
+	.period_bytes_min = PERIOD_BYTES_MIN,
+	.period_bytes_max = BUFFER_BYTES_MAX / PERIODS_MIN,
+	.periods_min = PERIODS_MIN,
+	.periods_max = BUFFER_BYTES_MAX / PERIOD_BYTES_MIN,
+	.fifo_size = 16,
+};
+
+static void i2svad_pcm_transfer(struct i2svad_dev *dev, bool push)
+{
+	struct snd_pcm_substream *substream;
+	bool active, period_elapsed;
+
+	rcu_read_lock();
+	if (push)
+		substream = rcu_dereference(dev->tx_substream);
+	else
+		substream = rcu_dereference(dev->rx_substream);
+	active = substream && snd_pcm_running(substream);
+	if (active) {
+		unsigned int ptr;
+		unsigned int new_ptr;
+
+		if (push) {
+			ptr = READ_ONCE(dev->tx_ptr);
+			new_ptr = dev->tx_fn(dev, substream->runtime, ptr,
+					&period_elapsed);
+			cmpxchg(&dev->tx_ptr, ptr, new_ptr);
+		} else {
+			ptr = READ_ONCE(dev->rx_ptr);
+			new_ptr = dev->rx_fn(dev, substream->runtime, ptr,
+					&period_elapsed);
+			cmpxchg(&dev->rx_ptr, ptr, new_ptr);
+		}
+
+		if (period_elapsed)
+			snd_pcm_period_elapsed(substream);
+	}
+	rcu_read_unlock();
+}
+
+void i2svad_pcm_push_tx(struct i2svad_dev *dev)
+{
+	i2svad_pcm_transfer(dev, true);
+}
+
+void i2svad_pcm_pop_rx(struct i2svad_dev *dev)
+{
+	i2svad_pcm_transfer(dev, false);
+}
+
+static int i2svad_pcm_open(struct snd_soc_component *component,
+			struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_soc_pcm_runtime *rtd = snd_soc_substream_to_rtd(substream);
+	struct i2svad_dev *dev = snd_soc_dai_get_drvdata(snd_soc_rtd_to_cpu(rtd, 0));
+
+	snd_soc_set_runtime_hwparams(substream, &i2svad_pcm_hardware);
+	snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);
+	runtime->private_data = dev;
+
+	return 0;
+}
+
+static int i2svad_pcm_close(struct snd_soc_component *component,
+			struct snd_pcm_substream *substream)
+{
+	synchronize_rcu();
+	return 0;
+}
+
+static int i2svad_pcm_hw_params(struct snd_soc_component *component,
+			struct snd_pcm_substream *substream,
+			struct snd_pcm_hw_params *hw_params)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct i2svad_dev *dev = runtime->private_data;
+
+	switch (params_channels(hw_params)) {
+	case 2:
+		break;
+	default:
+		dev_err(dev->dev, "invalid channels number\n");
+		return -EINVAL;
+	}
+
+	switch (params_format(hw_params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		dev->tx_fn = i2svad_pcm_tx_16;
+		dev->rx_fn = i2svad_pcm_rx_16;
+		break;
+	default:
+		dev_err(dev->dev, "invalid format\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int i2svad_pcm_trigger(struct snd_soc_component *component,
+			struct snd_pcm_substream *substream, int cmd)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct i2svad_dev *dev = runtime->private_data;
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			WRITE_ONCE(dev->tx_ptr, 0);
+			rcu_assign_pointer(dev->tx_substream, substream);
+		} else {
+			WRITE_ONCE(dev->rx_ptr, 0);
+			rcu_assign_pointer(dev->rx_substream, substream);
+		}
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			rcu_assign_pointer(dev->tx_substream, NULL);
+		else
+			rcu_assign_pointer(dev->rx_substream, NULL);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static snd_pcm_uframes_t i2svad_pcm_pointer(struct snd_soc_component *component,
+					struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct i2svad_dev *dev = runtime->private_data;
+	snd_pcm_uframes_t pos;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		pos = READ_ONCE(dev->tx_ptr);
+	else
+		pos = READ_ONCE(dev->rx_ptr);
+
+	return pos < runtime->buffer_size ? pos : 0;
+}
+
+static int i2svad_pcm_new(struct snd_soc_component *component,
+			struct snd_soc_pcm_runtime *rtd)
+{
+	size_t size = i2svad_pcm_hardware.buffer_bytes_max;
+
+	snd_pcm_set_managed_buffer_all(rtd->pcm,
+			SNDRV_DMA_TYPE_CONTINUOUS,
+			NULL, size, size);
+	return 0;
+}
+
+static const struct snd_soc_component_driver i2svad_pcm_component = {
+	.open		= i2svad_pcm_open,
+	.close		= i2svad_pcm_close,
+	.hw_params	= i2svad_pcm_hw_params,
+	.trigger	= i2svad_pcm_trigger,
+	.pointer	= i2svad_pcm_pointer,
+	.pcm_construct	= i2svad_pcm_new,
+};
+
+int i2svad_pcm_register(struct platform_device *pdev)
+{
+	return devm_snd_soc_register_component(&pdev->dev, &i2svad_pcm_component,
+					NULL, 0);
+}
diff --git a/sound/soc/starfive/i2svad.c b/sound/soc/starfive/i2svad.c
new file mode 100644
index 0000000000..f8d0f894f2
--- /dev/null
+++ b/sound/soc/starfive/i2svad.c
@@ -0,0 +1,1041 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/pm_runtime.h>
+#include <sound/designware_i2s.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/dmaengine_pcm.h>
+#include <linux/kthread.h>
+
+#include "i2svad.h"
+
+/* vad control function*/
+static void vad_start(struct vad_params *vad)
+{
+	regmap_update_bits(vad->vad_map, VAD_MEM_SW,
+			VAD_MEM_SW_MASK, VAD_MEM_SW_TO_VAD);
+	regmap_update_bits(vad->vad_map, VAD_SW,
+			VAD_SW_MASK, VAD_SW_VAD_XMEM_ENABLE|VAD_SW_ADC_ENABLE);
+	regmap_update_bits(vad->vad_map, VAD_SPINT_EN,
+			VAD_SPINT_EN_MASK, VAD_SPINT_EN_ENABLE);
+	regmap_update_bits(vad->vad_map, VAD_SLINT_EN,
+			VAD_SLINT_EN_MASK, VAD_SLINT_EN_ENABLE);
+}
+
+static void vad_stop(struct vad_params *vad)
+{
+	regmap_update_bits(vad->vad_map, VAD_SPINT_EN,
+			VAD_SPINT_EN_MASK, VAD_SLINT_EN_DISABLE);
+	regmap_update_bits(vad->vad_map, VAD_SLINT_EN,
+			VAD_SLINT_EN_MASK, VAD_SLINT_EN_DISABLE);
+	regmap_update_bits(vad->vad_map, VAD_SW,
+			VAD_SW_MASK, VAD_SW_VAD_XMEM_DISABLE|VAD_SW_ADC_DISABLE);
+	regmap_update_bits(vad->vad_map, VAD_MEM_SW,
+			VAD_MEM_SW_MASK, VAD_MEM_SW_TO_AXI);
+}
+
+static void vad_status(struct vad_params *vad)
+{
+	u32 sp_value,sp_en;
+	u32 sl_value,sl_en;
+
+	regmap_read(vad->vad_map, VAD_SPINT,&sp_value);
+	regmap_read(vad->vad_map, VAD_SPINT_EN,&sp_en);
+	if (sp_value&sp_en){
+		regmap_update_bits(vad->vad_map, VAD_SPINT_CLR,
+				VAD_SPINT_CLR_MASK, VAD_SPINT_CLR_VAD_SPINT);
+		vad->vstatus = VAD_STATUS_SPINT;
+		vad_stop(vad);
+		vad_start(vad);
+	}
+
+	regmap_read(vad->vad_map, VAD_SLINT,&sl_value);
+	regmap_read(vad->vad_map, VAD_SLINT_EN,&sl_en);
+	if (sl_value&sl_en){
+		regmap_update_bits(vad->vad_map, VAD_SLINT_CLR,
+				VAD_SLINT_CLR_MASK, VAD_SLINT_CLR_VAD_SLINT);
+		vad->vstatus = VAD_STATUS_SLINT;
+	}
+}
+
+static int vad_trigger(struct vad_params *vad,int cmd)
+{
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if(vad->vswitch)
+		{
+			vad_start(vad);
+		}
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		vad_stop(vad);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static void vad_init(struct vad_params *vad)
+{
+	/* left_margin */
+	regmap_update_bits(vad->vad_map, VAD_LEFT_MARGIN,
+			VAD_LEFT_MARGIN_MASK, 0x0);
+	/* right_margin */
+	regmap_update_bits(vad->vad_map, VAD_RIGHT_MARGIN,
+			VAD_RIGHT_MARGIN_MASK, 0x0);
+	/*low-energy transition range threshold ——NL*/
+	regmap_update_bits(vad->vad_map, VAD_N_LOW_CONT_FRAMES,
+			VAD_N_LOW_CONT_FRAMES_MASK, 0x3);
+	/* low-energy transition range */
+	regmap_update_bits(vad->vad_map, VAD_N_LOW_SEEK_FRAMES,
+			VAD_N_LOW_SEEK_FRAMES_MASK, 0x8);
+	/* high-energy transition range threshold——NH */
+	regmap_update_bits(vad->vad_map, VAD_N_HIGH_CONT_FRAMES,
+			VAD_N_HIGH_CONT_FRAMES_MASK, 0x5);
+	/* high-energy transition range */
+	regmap_update_bits(vad->vad_map, VAD_N_HIGH_SEEK_FRAMES,
+			VAD_N_HIGH_SEEK_FRAMES_MASK, 0x1E);
+	/*low-energy voice range threshold——NVL*/
+	regmap_update_bits(vad->vad_map, VAD_N_SPEECH_LOW_HIGH_FRAMES,
+			VAD_N_SPEECH_LOW_HIGH_FRAMES_MASK, 0x2);
+	/*low-energy voice range*/
+	regmap_update_bits(vad->vad_map, VAD_N_SPEECH_LOW_SEEK_FRAMES,
+			VAD_N_SPEECH_LOW_SEEK_FRAMES_MASK, 0x12);
+	/*mean silence frame range*/
+	regmap_update_bits(vad->vad_map, VAD_MEAN_SIL_FRAMES,
+			VAD_MEAN_SIL_FRAMES_MASK, 0xA);
+	/*low-energy threshold scaling factor,12bit(0~0xFFF)*/
+	regmap_update_bits(vad->vad_map, VAD_N_ALPHA,
+			VAD_N_ALPHA_MASK, 0x1A);
+	/*high-energy threshold scaling factor,12bit(0~0xFFF)*/
+	regmap_update_bits(vad->vad_map, VAD_N_BETA,
+			VAD_N_BETA_MASK, 0x34);
+	regmap_update_bits(vad->vad_map, VAD_LEFT_WD,
+			VAD_LEFT_WD_MASK, VAD_LEFT_WD_BIT_15_0);
+	regmap_update_bits(vad->vad_map, VAD_RIGHT_WD,
+			VAD_RIGHT_WD_MASK, VAD_RIGHT_WD_BIT_15_0);
+	regmap_update_bits(vad->vad_map, VAD_LR_SEL,
+			VAD_LR_SEL_MASK, VAD_LR_SEL_L);
+	regmap_update_bits(vad->vad_map, VAD_STOP_DELAY,
+			VAD_STOP_DELAY_MASK, VAD_STOP_DELAY_0_SAMPLE);
+	regmap_update_bits(vad->vad_map, VAD_ADDR_START,
+			VAD_ADDR_START_MASK, 0x0);
+	regmap_update_bits(vad->vad_map, VAD_ADDR_WRAP,
+			VAD_ADDR_WRAP_MASK, 0x2000);
+	regmap_update_bits(vad->vad_map, VAD_MEM_SW,
+			VAD_MEM_SW_MASK, VAD_MEM_SW_TO_AXI);
+	regmap_update_bits(vad->vad_map, VAD_SPINT_CLR,
+			VAD_SPINT_CLR_MASK, VAD_SPINT_CLR_VAD_SPINT);
+	regmap_update_bits(vad->vad_map, VAD_SLINT_CLR,
+			VAD_SLINT_CLR_MASK, VAD_SLINT_CLR_VAD_SLINT);
+}
+
+
+static int vad_switch_info(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_BOOLEAN;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 1;
+
+	return 0;
+}
+
+static int vad_switch_get(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct i2svad_dev *dev = snd_soc_component_get_drvdata(component);
+
+	ucontrol->value.integer.value[0] = dev->vad.vswitch;
+
+	return 0;
+}
+
+static int vad_switch_put(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct i2svad_dev *dev = snd_soc_component_get_drvdata(component);
+	int val;
+
+	val = ucontrol->value.integer.value[0];
+	if (val && !dev->vad.vswitch) {
+		dev->vad.vswitch = true;
+	} else if (!val && dev->vad.vswitch) {
+		dev->vad.vswitch = false;
+		vad_stop(&(dev->vad));
+	}
+
+	return 0;
+}
+
+
+static int vad_status_info(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 0;
+	uinfo->value.integer.max = 2;
+
+	return 0;
+}
+
+static int vad_status_get(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct i2svad_dev *dev = snd_soc_component_get_drvdata(component);
+
+	ucontrol->value.integer.value[0] = dev->vad.vstatus;
+	dev->vad.vstatus = VAD_STATUS_NORMAL;
+
+	return 0;
+}
+
+
+#define SOC_VAD_SWITCH_DECL(xname) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.info = vad_switch_info, .get = vad_switch_get, \
+	.put = vad_switch_put, }
+
+#define SOC_VAD_STATUS_DECL(xname) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.info = vad_status_info, .get = vad_status_get, }
+
+
+static const struct snd_kcontrol_new vad_snd_controls[] = {
+	SOC_VAD_SWITCH_DECL("vad switch"),
+	SOC_VAD_STATUS_DECL("vad status"),
+};
+
+static int vad_probe(struct snd_soc_component *component)
+{
+	struct i2svad_dev *priv = snd_soc_component_get_drvdata(component);
+
+	snd_soc_component_init_regmap(component, priv->vad.vad_map);
+	snd_soc_add_component_controls(component, vad_snd_controls,
+				ARRAY_SIZE(vad_snd_controls));
+
+	return 0;
+}
+
+/* i2s control function*/
+static inline void i2s_write_reg(void __iomem *io_base, int reg, u32 val)
+{
+	writel(val, io_base + reg);
+}
+
+static inline u32 i2s_read_reg(void __iomem *io_base, int reg)
+{
+	return readl(io_base + reg);
+}
+
+static inline void i2s_disable_channels(struct i2svad_dev *dev, u32 stream)
+{
+	u32 i = 0;
+
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		for (i = 0; i < ALL_CHANNEL_NUM; i++)
+			i2s_write_reg(dev->i2s_base, TER(i), 0);
+	} else {
+		for (i = 0; i < ALL_CHANNEL_NUM; i++)
+			i2s_write_reg(dev->i2s_base, RER(i), 0);
+	}
+}
+
+static inline void i2s_clear_irqs(struct i2svad_dev *dev, u32 stream)
+{
+	u32 i = 0;
+
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		for (i = 0; i < ALL_CHANNEL_NUM; i++)
+			i2s_read_reg(dev->i2s_base, TOR(i));
+	} else {
+		for (i = 0; i < ALL_CHANNEL_NUM; i++)
+			i2s_read_reg(dev->i2s_base, ROR(i));
+	}
+}
+
+static inline void i2s_disable_irqs(struct i2svad_dev *dev, u32 stream,
+				int chan_nr)
+{
+	u32 i, irq;
+
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		for (i = 0; i < (chan_nr / 2); i++) {
+			irq = i2s_read_reg(dev->i2s_base, IMR(i));
+			i2s_write_reg(dev->i2s_base, IMR(i), irq | 0x30);
+		}
+	} else {
+		for (i = 0; i < (chan_nr / 2); i++) {
+			irq = i2s_read_reg(dev->i2s_base, IMR(i));
+			i2s_write_reg(dev->i2s_base, IMR(i), irq | 0x03);
+		}
+	}
+}
+
+static inline void i2s_enable_irqs(struct i2svad_dev *dev, u32 stream,
+				int chan_nr)
+{
+	u32 i, irq;
+
+	if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		for (i = 0; i < (chan_nr / 2); i++) {
+			irq = i2s_read_reg(dev->i2s_base, IMR(i));
+			i2s_write_reg(dev->i2s_base, IMR(i), irq & ~0x30);
+		}
+	} else {
+		for (i = 0; i < (chan_nr / 2); i++) {
+			irq = i2s_read_reg(dev->i2s_base, IMR(i));
+			i2s_write_reg(dev->i2s_base, IMR(i), irq & ~0x03);
+		}
+	}
+}
+
+static irqreturn_t i2s_irq_handler(int irq, void *dev_id)
+{
+	struct i2svad_dev *dev = dev_id;
+	bool irq_valid = false;
+	u32 isr[4];
+	int i;
+
+	for (i = 0; i < ALL_CHANNEL_NUM; i++)
+		isr[i] = i2s_read_reg(dev->i2s_base, ISR(i));
+
+	i2s_clear_irqs(dev, SNDRV_PCM_STREAM_PLAYBACK);
+	i2s_clear_irqs(dev, SNDRV_PCM_STREAM_CAPTURE);
+
+	for (i = 0; i < 4; i++) {
+		/*
+		 * Check if TX fifo is empty. If empty fill FIFO with samples
+		 * NOTE: Only two channels supported
+		 */
+		if ((isr[i] & ISR_TXFE) && (i == 0) && dev->use_pio) {
+			i2svad_pcm_push_tx(dev);
+			irq_valid = true;
+		}
+
+		/*
+		 * Data available. Retrieve samples from FIFO
+		 * NOTE: Only two channels supported
+		 */
+		if ((isr[i] & ISR_RXDA) && (i == 0) && dev->use_pio) {
+			i2svad_pcm_pop_rx(dev);
+			irq_valid = true;
+		}
+
+		/* Error Handling: TX */
+		if (isr[i] & ISR_TXFO) {
+			//dev_err(dev->dev, "TX overrun (ch_id=%d)\n", i);
+			irq_valid = true;
+		}
+
+		/* Error Handling: TX */
+		if (isr[i] & ISR_RXFO) {
+			//dev_err(dev->dev, "RX overrun (ch_id=%d)\n", i);
+			irq_valid = true;
+		}
+	}
+
+	vad_status(&(dev->vad));
+
+	if (irq_valid)
+		return IRQ_HANDLED;
+	else
+		return IRQ_NONE;
+}
+
+static void i2s_start(struct i2svad_dev *dev,
+			struct snd_pcm_substream *substream)
+{
+	struct i2s_clk_config_data *config = &dev->config;
+
+	i2s_write_reg(dev->i2s_base, IER, 1);
+	i2s_enable_irqs(dev, substream->stream, config->chan_nr);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		i2s_write_reg(dev->i2s_base, ITER, 1);
+	else
+		i2s_write_reg(dev->i2s_base, IRER, 1);
+
+	i2s_write_reg(dev->i2s_base, CER, 1);
+}
+
+static void i2s_stop(struct i2svad_dev *dev,
+		struct snd_pcm_substream *substream)
+{
+
+	i2s_clear_irqs(dev, substream->stream);
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		i2s_write_reg(dev->i2s_base, ITER, 0);
+	else
+		i2s_write_reg(dev->i2s_base, IRER, 0);
+
+	i2s_disable_irqs(dev, substream->stream, 8);
+
+	if (!dev->active) {
+		i2s_write_reg(dev->i2s_base, CER, 0);
+		i2s_write_reg(dev->i2s_base, IER, 0);
+	}
+}
+
+static int dw_i2s_startup(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *cpu_dai)
+{
+	struct i2svad_dev *dev = snd_soc_dai_get_drvdata(cpu_dai);
+	union dw_i2s_snd_dma_data *dma_data = NULL;
+
+
+	if (!(dev->capability & DWC_I2S_RECORD) &&
+			(substream->stream == SNDRV_PCM_STREAM_CAPTURE))
+		return -EINVAL;
+
+	if (!(dev->capability & DWC_I2S_PLAY) &&
+			(substream->stream == SNDRV_PCM_STREAM_PLAYBACK))
+		return -EINVAL;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		dma_data = &dev->play_dma_data;
+	else if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+		dma_data = &dev->capture_dma_data;
+
+	snd_soc_dai_set_dma_data(cpu_dai, substream, (void *)dma_data);
+
+	return 0;
+}
+
+static void dw_i2s_config(struct i2svad_dev *dev, int stream)
+{
+	u32 ch_reg;
+	struct i2s_clk_config_data *config = &dev->config;
+
+
+	i2s_disable_channels(dev, stream);
+
+	for (ch_reg = 0; ch_reg < (config->chan_nr / 2); ch_reg++) {
+		if (stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			i2s_write_reg(dev->i2s_base, TCR(ch_reg),
+					dev->xfer_resolution);
+			i2s_write_reg(dev->i2s_base, TFCR(ch_reg),
+					dev->fifo_th - 1);
+			i2s_write_reg(dev->i2s_base, TER(ch_reg), 1);
+		} else {
+			i2s_write_reg(dev->i2s_base, RCR(ch_reg),
+					dev->xfer_resolution);
+			i2s_write_reg(dev->i2s_base, RFCR(ch_reg),
+					dev->fifo_th - 1);
+			i2s_write_reg(dev->i2s_base, RER(ch_reg), 1);
+		}
+
+	}
+}
+
+static int dw_i2s_hw_params(struct snd_pcm_substream *substream,
+		struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct i2svad_dev *dev = snd_soc_dai_get_drvdata(dai);
+	struct i2s_clk_config_data *config = &dev->config;
+	int ret;
+
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		config->data_width = 16;
+		dev->ccr = 0x00;
+		dev->xfer_resolution = 0x02;
+		break;
+
+	case SNDRV_PCM_FORMAT_S24_LE:
+		config->data_width = 24;
+		dev->ccr = 0x08;
+		dev->xfer_resolution = 0x04;
+		break;
+
+	case SNDRV_PCM_FORMAT_S32_LE:
+		config->data_width = 32;
+		dev->ccr = 0x10;
+		dev->xfer_resolution = 0x05;
+		break;
+
+	default:
+		dev_err(dev->dev, "designware-i2s: unsupported PCM fmt");
+		return -EINVAL;
+	}
+
+	config->chan_nr = params_channels(params);
+
+	switch (config->chan_nr) {
+	case EIGHT_CHANNEL_SUPPORT:
+	case SIX_CHANNEL_SUPPORT:
+	case FOUR_CHANNEL_SUPPORT:
+	case TWO_CHANNEL_SUPPORT:
+		break;
+	default:
+		dev_err(dev->dev, "channel not supported\n");
+		return -EINVAL;
+	}
+
+	dw_i2s_config(dev, substream->stream);
+
+	i2s_write_reg(dev->i2s_base, CCR, dev->ccr);
+
+	config->sample_rate = params_rate(params);
+
+	if (dev->capability & DW_I2S_MASTER) {
+		if (dev->i2s_clk_cfg) {
+			ret = dev->i2s_clk_cfg(config);
+			if (ret < 0) {
+				dev_err(dev->dev, "runtime audio clk config fail\n");
+				return ret;
+			}
+		} else {
+			u32 bitclk = config->sample_rate *
+					config->data_width * 2;
+
+			ret = clk_set_rate(dev->clk, bitclk);
+			if (ret) {
+				dev_err(dev->dev, "Can't set I2S clock rate: %d\n",
+					ret);
+				return ret;
+			}
+		}
+	}
+	return 0;
+}
+
+static void dw_i2s_shutdown(struct snd_pcm_substream *substream,
+		struct snd_soc_dai *dai)
+{
+	snd_soc_dai_set_dma_data(dai, substream, NULL);
+}
+
+static int dw_i2s_prepare(struct snd_pcm_substream *substream,
+			struct snd_soc_dai *dai)
+{
+	struct i2svad_dev *dev = snd_soc_dai_get_drvdata(dai);
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		i2s_write_reg(dev->i2s_base, TXFFR, 1);
+	else
+		i2s_write_reg(dev->i2s_base, RXFFR, 1);
+
+	return 0;
+}
+
+static int dw_i2s_trigger(struct snd_pcm_substream *substream,
+		int cmd, struct snd_soc_dai *dai)
+{
+	struct i2svad_dev *dev = snd_soc_dai_get_drvdata(dai);
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		dev->active++;
+		i2s_start(dev, substream);
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		dev->active--;
+		i2s_stop(dev, substream);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE)
+	{
+		vad_trigger(&(dev->vad),cmd);
+	}
+	return ret;
+}
+
+static int dw_i2s_set_fmt(struct snd_soc_dai *cpu_dai, unsigned int fmt)
+{
+	struct i2svad_dev *dev = snd_soc_dai_get_drvdata(cpu_dai);
+	int ret = 0;
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBM_CFM:
+		if (dev->capability & DW_I2S_SLAVE)
+			ret = 0;
+		else
+			ret = -EINVAL;
+		break;
+	case SND_SOC_DAIFMT_CBS_CFS:
+		if (dev->capability & DW_I2S_MASTER)
+			ret = 0;
+		else
+			ret = -EINVAL;
+		break;
+	case SND_SOC_DAIFMT_CBM_CFS:
+	case SND_SOC_DAIFMT_CBS_CFM:
+		ret = -EINVAL;
+		break;
+	default:
+		dev_dbg(dev->dev, "dwc : Invalid master/slave format\n");
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+}
+
+static const struct snd_soc_dai_ops dw_i2s_dai_ops = {
+	.startup	= dw_i2s_startup,
+	.shutdown	= dw_i2s_shutdown,
+	.hw_params	= dw_i2s_hw_params,
+	.prepare	= dw_i2s_prepare,
+	.trigger	= dw_i2s_trigger,
+	.set_fmt	= dw_i2s_set_fmt,
+};
+
+#ifdef CONFIG_PM
+static int dw_i2s_runtime_suspend(struct device *dev)
+{
+	struct i2svad_dev *dw_dev = dev_get_drvdata(dev);
+
+	if (dw_dev->capability & DW_I2S_MASTER)
+		clk_disable(dw_dev->clk);
+	return 0;
+}
+
+static int dw_i2s_runtime_resume(struct device *dev)
+{
+	struct i2svad_dev *dw_dev = dev_get_drvdata(dev);
+
+	if (dw_dev->capability & DW_I2S_MASTER)
+		clk_enable(dw_dev->clk);
+	return 0;
+}
+
+static int dw_i2s_suspend(struct snd_soc_component *component)
+{
+	struct i2svad_dev *dev = snd_soc_component_get_drvdata(component);
+
+	if (dev->capability & DW_I2S_MASTER)
+		clk_disable(dev->clk);
+	return 0;
+}
+
+static int dw_i2s_resume(struct snd_soc_component *component)
+{
+	struct i2svad_dev *dev = snd_soc_component_get_drvdata(component);
+	struct snd_soc_dai *dai;
+	int stream;
+
+	if (dev->capability & DW_I2S_MASTER)
+		clk_enable(dev->clk);
+
+	for_each_component_dais(component, dai) {
+		for_each_pcm_streams(stream)
+			if (snd_soc_dai_stream_active(dai, stream))
+				dw_i2s_config(dev, stream);
+	}
+
+	return 0;
+}
+
+#else
+#define dw_i2s_suspend	NULL
+#define dw_i2s_resume	NULL
+#endif
+
+static int dw_i2svad_probe(struct snd_soc_component *component)
+{
+	vad_probe(component);
+	return 0;
+}
+
+static const struct snd_soc_component_driver dw_i2s_component = {
+	.name		= "dw-i2s",
+	.probe		= dw_i2svad_probe,
+	.suspend	= dw_i2s_suspend,
+	.resume		= dw_i2s_resume,
+};
+
+/*
+ * The following tables allow a direct lookup of various parameters
+ * defined in the I2S block's configuration in terms of sound system
+ * parameters.  Each table is sized to the number of entries possible
+ * according to the number of configuration bits describing an I2S
+ * block parameter.
+ */
+
+/* Maximum bit resolution of a channel - not uniformly spaced */
+static const u32 fifo_width[COMP_MAX_WORDSIZE] = {
+	12, 16, 20, 24, 32, 0, 0, 0
+};
+
+/* Width of (DMA) bus */
+static const u32 bus_widths[COMP_MAX_DATA_WIDTH] = {
+	DMA_SLAVE_BUSWIDTH_1_BYTE,
+	DMA_SLAVE_BUSWIDTH_2_BYTES,
+	DMA_SLAVE_BUSWIDTH_4_BYTES,
+	DMA_SLAVE_BUSWIDTH_UNDEFINED
+};
+
+/* PCM format to support channel resolution */
+static const u32 formats[COMP_MAX_WORDSIZE] = {
+	SNDRV_PCM_FMTBIT_S16_LE,
+	SNDRV_PCM_FMTBIT_S16_LE,
+	SNDRV_PCM_FMTBIT_S24_LE,
+	SNDRV_PCM_FMTBIT_S24_LE,
+	SNDRV_PCM_FMTBIT_S32_LE,
+	0,
+	0,
+	0
+};
+
+static const struct regmap_config sf_i2s_regmap_cfg = {
+	.reg_bits	= 32,
+	.val_bits	= 32,
+	.reg_stride	= 4,
+	.max_register	= 0x1000,
+};
+
+static int dw_configure_dai(struct i2svad_dev *dev,
+				struct snd_soc_dai_driver *dw_i2s_dai,
+				unsigned int rates)
+{
+	/*
+	 * Read component parameter registers to extract
+	 * the I2S block's configuration.
+	 */
+	u32 comp1 = i2s_read_reg(dev->i2s_base, dev->i2s_reg_comp1);
+	u32 comp2 = i2s_read_reg(dev->i2s_base, dev->i2s_reg_comp2);
+	u32 fifo_depth = 1 << (1 + COMP1_FIFO_DEPTH_GLOBAL(comp1));
+	u32 idx;
+
+	if (dev->capability & DWC_I2S_RECORD &&
+			dev->quirks & DW_I2S_QUIRK_COMP_PARAM1)
+		comp1 = comp1 & ~BIT(5);
+
+	if (dev->capability & DWC_I2S_PLAY &&
+			dev->quirks & DW_I2S_QUIRK_COMP_PARAM1)
+		comp1 = comp1 & ~BIT(6);
+
+	if (COMP1_TX_ENABLED(comp1)) {
+		dev_dbg(dev->dev, " designware: play supported\n");
+		idx = COMP1_TX_WORDSIZE_0(comp1);
+		if (WARN_ON(idx >= ARRAY_SIZE(formats)))
+			return -EINVAL;
+		if (dev->quirks & DW_I2S_QUIRK_16BIT_IDX_OVERRIDE)
+			idx = 1;
+		dw_i2s_dai->playback.channels_min = MIN_CHANNEL_NUM;
+		dw_i2s_dai->playback.channels_max =
+				1 << (COMP1_TX_CHANNELS(comp1) + 1);
+		//dw_i2s_dai->playback.formats = formats[idx];
+		dw_i2s_dai->playback.formats = SNDRV_PCM_FMTBIT_S16_LE;
+		dw_i2s_dai->playback.rates = rates;
+	}
+
+	if (COMP1_RX_ENABLED(comp1)) {
+		dev_dbg(dev->dev, "designware: record supported\n");
+		idx = COMP2_RX_WORDSIZE_0(comp2);
+		if (WARN_ON(idx >= ARRAY_SIZE(formats)))
+			return -EINVAL;
+		if (dev->quirks & DW_I2S_QUIRK_16BIT_IDX_OVERRIDE)
+			idx = 1;
+		dw_i2s_dai->capture.channels_min = MIN_CHANNEL_NUM;
+		dw_i2s_dai->capture.channels_max =
+				1 << (COMP1_RX_CHANNELS(comp1) + 1);
+		//dw_i2s_dai->capture.formats = formats[idx];
+		dw_i2s_dai->capture.formats = SNDRV_PCM_FMTBIT_S16_LE;
+		dw_i2s_dai->capture.rates = rates;
+	}
+
+	if (COMP1_MODE_EN(comp1)) {
+		dev_dbg(dev->dev, "designware: i2s master mode supported\n");
+		dev->capability |= DW_I2S_MASTER;
+	} else {
+		dev_dbg(dev->dev, "designware: i2s slave mode supported\n");
+		dev->capability |= DW_I2S_SLAVE;
+	}
+
+	dev->fifo_th = fifo_depth / 2;
+	return 0;
+}
+
+static int dw_configure_dai_by_pd(struct i2svad_dev *dev,
+				struct snd_soc_dai_driver *dw_i2s_dai,
+				struct resource *res,
+				const struct i2s_platform_data *pdata)
+{
+	u32 comp1 = i2s_read_reg(dev->i2s_base, dev->i2s_reg_comp1);
+	u32 idx = COMP1_APB_DATA_WIDTH(comp1);
+	int ret;
+
+	if (WARN_ON(idx >= ARRAY_SIZE(bus_widths)))
+		return -EINVAL;
+
+	ret = dw_configure_dai(dev, dw_i2s_dai, pdata->snd_rates);
+	if (ret < 0)
+		return ret;
+
+	if (dev->quirks & DW_I2S_QUIRK_16BIT_IDX_OVERRIDE)
+		idx = 1;
+	/* Set DMA slaves info */
+	dev->play_dma_data.pd.data = pdata->play_dma_data;
+	dev->capture_dma_data.pd.data = pdata->capture_dma_data;
+	dev->play_dma_data.pd.addr = res->start + I2S_TXDMA;
+	dev->capture_dma_data.pd.addr = res->start + I2S_RXDMA;
+	dev->play_dma_data.pd.max_burst = 16;
+	dev->capture_dma_data.pd.max_burst = 16;
+	dev->play_dma_data.pd.addr_width = bus_widths[idx];
+	dev->capture_dma_data.pd.addr_width = bus_widths[idx];
+	dev->play_dma_data.pd.filter = pdata->filter;
+	dev->capture_dma_data.pd.filter = pdata->filter;
+
+	return 0;
+}
+
+static int dw_configure_dai_by_dt(struct i2svad_dev *dev,
+				struct snd_soc_dai_driver *dw_i2s_dai,
+				struct resource *res)
+{
+	u32 comp1 = i2s_read_reg(dev->i2s_base, I2S_COMP_PARAM_1);
+	u32 comp2 = i2s_read_reg(dev->i2s_base, I2S_COMP_PARAM_2);
+	u32 fifo_depth = 1 << (1 + COMP1_FIFO_DEPTH_GLOBAL(comp1));
+	u32 idx = COMP1_APB_DATA_WIDTH(comp1);
+	u32 idx2;
+	int ret;
+
+	if (WARN_ON(idx >= ARRAY_SIZE(bus_widths)))
+		return -EINVAL;
+
+	ret = dw_configure_dai(dev, dw_i2s_dai, SNDRV_PCM_RATE_8000_192000);
+	if (ret < 0)
+		return ret;
+
+	if (COMP1_TX_ENABLED(comp1)) {
+		idx2 = COMP1_TX_WORDSIZE_0(comp1);
+
+		dev->capability |= DWC_I2S_PLAY;
+		dev->play_dma_data.dt.addr = res->start + I2S_TXDMA;
+		dev->play_dma_data.dt.addr_width = bus_widths[idx];
+		dev->play_dma_data.dt.fifo_size = fifo_depth *
+			(fifo_width[idx2]) >> 8;
+		dev->play_dma_data.dt.maxburst = 16;
+	}
+	if (COMP1_RX_ENABLED(comp1)) {
+		idx2 = COMP2_RX_WORDSIZE_0(comp2);
+
+		dev->capability |= DWC_I2S_RECORD;
+		dev->capture_dma_data.dt.addr = res->start + I2S_RXDMA;
+		dev->capture_dma_data.dt.addr_width = bus_widths[idx];
+		dev->capture_dma_data.dt.fifo_size = fifo_depth *
+			(fifo_width[idx2] >> 8);
+		dev->capture_dma_data.dt.maxburst = 16;
+	}
+
+	return 0;
+
+}
+
+static int dw_i2s_probe(struct platform_device *pdev)
+{
+	const struct i2s_platform_data *pdata = pdev->dev.platform_data;
+	struct i2svad_dev *dev;
+	struct resource *res;
+	int ret, irq;
+	struct snd_soc_dai_driver *dw_i2s_dai;
+	const char *clk_id;
+
+	dev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+
+	dw_i2s_dai = devm_kzalloc(&pdev->dev, sizeof(*dw_i2s_dai), GFP_KERNEL);
+	if (!dw_i2s_dai)
+		return -ENOMEM;
+
+	dw_i2s_dai->ops = &dw_i2s_dai_ops;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	dev->i2s_base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(dev->i2s_base))
+		return PTR_ERR(dev->i2s_base);
+
+	dev->vad.vad_base = dev->i2s_base;
+	dev->vad.vad_map = devm_regmap_init_mmio(&pdev->dev, dev->i2s_base, &sf_i2s_regmap_cfg);
+	if (IS_ERR(dev->vad.vad_map)) {
+		dev_err(&pdev->dev, "failed to init regmap: %ld\n",
+			PTR_ERR(dev->vad.vad_map));
+		return PTR_ERR(dev->vad.vad_map);
+	}
+
+	dev->dev = &pdev->dev;
+
+	dev->clk_apb_i2svad = devm_clk_get(&pdev->dev, "i2svad_apb");
+	if (IS_ERR(dev->clk_apb_i2svad))
+		return dev_err_probe(&pdev->dev, PTR_ERR(dev->clk_apb_i2svad),
+				     "failed to get apb clock\n");
+
+	dev->rst_apb_i2svad = devm_reset_control_get_exclusive(&pdev->dev, "apb_i2svad");
+	if (IS_ERR(dev->rst_apb_i2svad))
+		return dev_err_probe(&pdev->dev, PTR_ERR(dev->rst_apb_i2svad),
+				     "failed to get apb reset\n");
+
+	dev->rst_i2svad_srst = devm_reset_control_get_exclusive(&pdev->dev, "i2svad_srst");
+	if (IS_ERR(dev->rst_i2svad_srst))
+		return dev_err_probe(&pdev->dev, PTR_ERR(dev->rst_i2svad_srst),
+				     "failed to get source reset\n");
+
+	ret = clk_prepare_enable(dev->clk_apb_i2svad);
+	if (ret)
+		return dev_err_probe(&pdev->dev, ret, "failed to enable apb clock\n");
+
+	ret = reset_control_deassert(dev->rst_apb_i2svad);
+	if (ret)
+		return dev_err_probe(&pdev->dev, ret, "failed to deassert apb reset\n");
+
+	ret = reset_control_deassert(dev->rst_i2svad_srst);
+	if (ret)
+		return dev_err_probe(&pdev->dev, ret, "failed to deassert source reset\n");
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq >= 0) {
+		ret = devm_request_irq(&pdev->dev, irq, i2s_irq_handler, 0,
+				pdev->name, dev);
+		if (ret < 0) {
+			dev_err(&pdev->dev, "failed to request irq\n");
+			return ret;
+		}
+	}
+
+	dev->i2s_reg_comp1 = I2S_COMP_PARAM_1;
+	dev->i2s_reg_comp2 = I2S_COMP_PARAM_2;
+	if (pdata) {
+		dev->capability = pdata->cap;
+		clk_id = NULL;
+		dev->quirks = pdata->quirks;
+		if (dev->quirks & DW_I2S_QUIRK_COMP_REG_OFFSET) {
+			dev->i2s_reg_comp1 = pdata->i2s_reg_comp1;
+			dev->i2s_reg_comp2 = pdata->i2s_reg_comp2;
+		}
+		ret = dw_configure_dai_by_pd(dev, dw_i2s_dai, res, pdata);
+	} else {
+		clk_id = "i2sclk";
+		ret = dw_configure_dai_by_dt(dev, dw_i2s_dai, res);
+	}
+	if (ret < 0)
+		return ret;
+
+	if (dev->capability & DW_I2S_MASTER) {
+		if (pdata) {
+			dev->i2s_clk_cfg = pdata->i2s_clk_cfg;
+			if (!dev->i2s_clk_cfg) {
+				dev_err(&pdev->dev, "no clock configure method\n");
+				return -ENODEV;
+			}
+		}
+		dev->clk = devm_clk_get(&pdev->dev, clk_id);
+
+		if (IS_ERR(dev->clk))
+			return PTR_ERR(dev->clk);
+
+		ret = clk_prepare_enable(dev->clk);
+		if (ret < 0)
+			return ret;
+	}
+
+	dev_set_drvdata(&pdev->dev, dev);
+	ret = devm_snd_soc_register_component(&pdev->dev, &dw_i2s_component,
+					 dw_i2s_dai, 1);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "not able to register dai\n");
+		goto err_clk_disable;
+	}
+
+	if (!pdata) {
+		if (irq >= 0) {
+			ret = i2svad_pcm_register(pdev);
+			dev->use_pio = true;
+		} else {
+			ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL,
+					0);
+			dev->use_pio = false;
+		}
+
+		if (ret) {
+			dev_err(&pdev->dev, "could not register pcm: %d\n",
+					ret);
+			goto err_clk_disable;
+		}
+	}
+
+	vad_init(&(dev->vad));
+	pm_runtime_enable(&pdev->dev);
+
+	return 0;
+
+err_clk_disable:
+	if (dev->capability & DW_I2S_MASTER)
+		clk_disable_unprepare(dev->clk);
+	return ret;
+}
+
+static void dw_i2s_remove(struct platform_device *pdev)
+{
+	struct i2svad_dev *dev = dev_get_drvdata(&pdev->dev);
+
+	if (dev->capability & DW_I2S_MASTER)
+		clk_disable_unprepare(dev->clk);
+
+	pm_runtime_disable(&pdev->dev);
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id dw_i2s_of_match[] = {
+	{ .compatible = "starfive,sf-i2svad", },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, dw_i2s_of_match);
+#endif
+
+static const struct dev_pm_ops dwc_pm_ops = {
+	SET_RUNTIME_PM_OPS(dw_i2s_runtime_suspend, dw_i2s_runtime_resume, NULL)
+};
+
+static struct platform_driver dw_i2s_driver = {
+	.probe		= dw_i2s_probe,
+	.remove		= dw_i2s_remove,
+	.driver		= {
+		.name	= "sf-i2svad",
+		.of_match_table = of_match_ptr(dw_i2s_of_match),
+		.pm = &dwc_pm_ops,
+	},
+};
+
+module_platform_driver(dw_i2s_driver);
+
+MODULE_AUTHOR("jenny zhang <jenny.zhang@starfivetech.com>");
+MODULE_DESCRIPTION("starfive I2SVAD SoC Interface");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:sf-i2svad");
diff --git a/sound/soc/starfive/i2svad.h b/sound/soc/starfive/i2svad.h
new file mode 100644
index 0000000000..cd14cb4ce8
--- /dev/null
+++ b/sound/soc/starfive/i2svad.h
@@ -0,0 +1,246 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#ifndef __SND_SOC_STARFIVE_I2SVAD_H
+#define __SND_SOC_STARFIVE_I2SVAD_H
+
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/reset.h>
+#include <linux/types.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/pcm.h>
+#include <sound/designware_i2s.h>
+
+/* common register for all channel */
+#define IER		0x000
+#define IRER		0x004
+#define ITER		0x008
+#define CER		0x00C
+#define CCR		0x010
+#define RXFFR		0x014
+#define TXFFR		0x018
+
+/* Interrupt status register fields */
+#define ISR_TXFO	BIT(5)
+#define ISR_TXFE	BIT(4)
+#define ISR_RXFO	BIT(1)
+#define ISR_RXDA	BIT(0)
+
+/* I2STxRxRegisters for all channels */
+#define LRBR_LTHR(x)	(0x40 * x + 0x020)
+#define RRBR_RTHR(x)	(0x40 * x + 0x024)
+#define RER(x)		(0x40 * x + 0x028)
+#define TER(x)		(0x40 * x + 0x02C)
+#define RCR(x)		(0x40 * x + 0x030)
+#define TCR(x)		(0x40 * x + 0x034)
+#define ISR(x)		(0x40 * x + 0x038)
+#define IMR(x)		(0x40 * x + 0x03C)
+#define ROR(x)		(0x40 * x + 0x040)
+#define TOR(x)		(0x40 * x + 0x044)
+#define RFCR(x)		(0x40 * x + 0x048)
+#define TFCR(x)		(0x40 * x + 0x04C)
+#define RFF(x)		(0x40 * x + 0x050)
+#define TFF(x)		(0x40 * x + 0x054)
+
+/* I2SCOMPRegisters */
+#define I2S_COMP_PARAM_2	0x01F0
+#define I2S_COMP_PARAM_1	0x01F4
+#define I2S_COMP_VERSION	0x01F8
+#define I2S_COMP_TYPE		0x01FC
+
+/* VAD Registers */
+#define VAD_LEFT_MARGIN				0x800  /* left_margin */
+#define VAD_RIGHT_MARGIN			0x804  /* right_margin */
+#define VAD_N_LOW_CONT_FRAMES			0x808  /* low-energy transition range threshold ——NL*/
+#define VAD_N_LOW_SEEK_FRAMES			0x80C  /* low-energy transition range */
+#define VAD_N_HIGH_CONT_FRAMES			0x810  /* high-energy transition range threshold——NH */
+#define VAD_N_HIGH_SEEK_FRAMES			0x814  /* high-energy transition range */
+#define VAD_N_SPEECH_LOW_HIGH_FRAMES		0x818  /* low-energy voice range threshold——NVL*/
+#define VAD_N_SPEECH_LOW_SEEK_FRAMES		0x81C  /* low-energy voice range*/
+#define VAD_MEAN_SIL_FRAMES			0x820  /* mean silence frame range*/
+#define VAD_N_ALPHA				0x824  /* low-energy threshold scaling factor,12bit(0~0xFFF)*/
+#define VAD_N_BETA				0x828  /* high-energy threshold scaling factor,12bit(0~0xFFF)*/
+#define VAD_FIFO_DEPTH				0x82C  /* status register for VAD */
+#define VAD_LR_SEL				0x840  /* L/R channel data selection for processing */
+#define VAD_SW					0x844  /* push enable signal*/
+#define VAD_LEFT_WD				0x848  /* select left channel*/
+#define VAD_RIGHT_WD				0x84C  /* select right channel*/
+#define VAD_STOP_DELAY				0x850  /* delay stop for 0-3 samples*/
+#define VAD_ADDR_START				0x854  /* vad memory start address, align with 64bit*/
+#define VAD_ADDR_WRAP				0x858  /* vad memory highest address for Push, align with 64bit,(addr_wrap-1) is the max physical address*/
+#define VAD_MEM_SW				0x85C  /* xmem switch */
+#define VAD_SPINT_CLR				0x860  /* clear vad_spint interrup status*/
+#define VAD_SPINT_EN				0x864  /* disable/enable vad_spint from vad_flag rising edge*/
+#define VAD_SLINT_CLR				0x868  /* clear vad_slint interrup status*/
+#define VAD_SLINT_EN				0x86C  /* disable/enable  vad_slint from vad_flag falling edge*/
+#define VAD_RAW_SPINT				0x870  /* status of spint before vad_spint_en*/
+#define VAD_RAW_SLINT				0x874  /* status of slint before vad_slint_en*/
+#define VAD_SPINT				0x878  /* status of spint after vad_spint_en*/
+#define VAD_SLINT				0x87C  /* status of slint before vad_slint_en*/
+#define VAD_XMEM_ADDR				0x880  /* next xmem address ,align to 16bi*/
+#define VAD_I2S_CTRL_REG_ADDR			0x884
+
+/*
+ * vad parameter register fields
+ */
+#define VAD_LEFT_MARGIN_MASK			GENMASK(4, 0)
+#define VAD_RIGHT_MARGIN_MASK			GENMASK(4, 0)
+#define VAD_N_LOW_CONT_FRAMES_MASK		GENMASK(4, 0)
+#define VAD_N_LOW_SEEK_FRAMES_MASK		GENMASK(4, 0)
+#define VAD_N_HIGH_CONT_FRAMES_MASK		GENMASK(4, 0)
+#define VAD_N_HIGH_SEEK_FRAMES_MASK		GENMASK(4, 0)
+#define VAD_N_SPEECH_LOW_HIGH_FRAMES_MASK	GENMASK(4, 0)
+#define VAD_N_SPEECH_LOW_SEEK_FRAMES_MASK	GENMASK(4, 0)
+#define VAD_MEAN_SIL_FRAMES_MASK		GENMASK(4, 0)
+#define VAD_N_ALPHA_MASK			GENMASK(11, 0)
+#define VAD_N_BETA_MASK				GENMASK(11, 0)
+#define VAD_LR_SEL_MASK				GENMASK(0, 0)
+#define VAD_LR_SEL_L				(0 << 0)
+#define VAD_LR_SEL_R				(1 << 0)
+
+#define VAD_SW_MASK				GENMASK(1, 0)
+#define VAD_SW_VAD_XMEM_ENABLE			(1 << 0)
+#define VAD_SW_VAD_XMEM_DISABLE			(0 << 0)
+#define VAD_SW_ADC_ENABLE			(1 << 1)
+#define VAD_SW_ADC_DISABLE			(0 << 1)
+
+
+#define VAD_LEFT_WD_MASK			GENMASK(0, 0)
+#define VAD_LEFT_WD_BIT_31_16			(1 << 1)
+#define VAD_LEFT_WD_BIT_15_0			(0 << 1)
+
+
+#define VAD_RIGHT_WD_MASK			GENMASK(0, 0)
+#define VAD_RIGHT_WD_BIT_31_16			(1 << 1)
+#define VAD_RIGHT_WD_BIT_15_0			(0 << 1)
+
+
+#define VAD_STOP_DELAY_MASK			GENMASK(1, 0)
+#define VAD_STOP_DELAY_0_SAMPLE			0
+#define VAD_STOP_DELAY_1_SAMPLE			1
+#define VAD_STOP_DELAY_2_SAMPLE			2
+#define VAD_STOP_DELAY_3_SAMPLE			3
+
+#define VAD_ADDR_START_MASK			GENMASK(12, 0)
+#define VAD_ADDR_WRAP_MASK			GENMASK(13, 0)
+#define VAD_MEM_SW_MASK				GENMASK(0, 0)
+#define VAD_SPINT_CLR_MASK			GENMASK(0, 0)
+#define VAD_SPINT_EN_MASK			GENMASK(0, 0)
+#define VAD_SLINT_CLR_MASK			GENMASK(0, 0)
+#define VAD_SLINT_EN_MASK			GENMASK(0, 0)
+#define VAD_I2S_CTRL_REG_ADDR_MASK		GENMASK(0, 0)
+
+#define VAD_MEM_SW_TO_VAD			(1 << 0)
+#define VAD_MEM_SW_TO_AXI			(0 << 0)
+
+#define VAD_SPINT_CLR_VAD_SPINT			(1 << 0)
+
+#define VAD_SPINT_EN_ENABLE			(1 << 0)
+#define VAD_SPINT_EN_DISABLE			(0 << 0)
+
+#define VAD_SLINT_CLR_VAD_SLINT			(1 << 0)
+
+#define VAD_SLINT_EN_ENABLE			(1 << 0)
+#define VAD_SLINT_EN_DISABLE			(0 << 0)
+
+#define VAD_STATUS_NORMAL			0
+#define VAD_STATUS_SPINT			1
+#define VAD_STATUS_SLINT			2
+
+/*
+ * Component parameter register fields - define the I2S block's
+ * configuration.
+ */
+#define COMP1_TX_WORDSIZE_3(r)		(((r) & GENMASK(27, 25)) >> 25)
+#define COMP1_TX_WORDSIZE_2(r)		(((r) & GENMASK(24, 22)) >> 22)
+#define COMP1_TX_WORDSIZE_1(r)		(((r) & GENMASK(21, 19)) >> 19)
+#define COMP1_TX_WORDSIZE_0(r)		(((r) & GENMASK(18, 16)) >> 16)
+#define COMP1_TX_CHANNELS(r)		(((r) & GENMASK(10, 9)) >> 9)
+#define COMP1_RX_CHANNELS(r)		(((r) & GENMASK(8, 7)) >> 7)
+#define COMP1_RX_ENABLED(r)		(((r) & BIT(6)) >> 6)
+#define COMP1_TX_ENABLED(r)		(((r) & BIT(5)) >> 5)
+#define COMP1_MODE_EN(r)		(((r) & BIT(4)) >> 4)
+#define COMP1_FIFO_DEPTH_GLOBAL(r)	(((r) & GENMASK(3, 2)) >> 2)
+#define COMP1_APB_DATA_WIDTH(r)		(((r) & GENMASK(1, 0)) >> 0)
+
+#define COMP2_RX_WORDSIZE_3(r)		(((r) & GENMASK(12, 10)) >> 10)
+#define COMP2_RX_WORDSIZE_2(r)		(((r) & GENMASK(9, 7)) >> 7)
+#define COMP2_RX_WORDSIZE_1(r)		(((r) & GENMASK(5, 3)) >> 3)
+#define COMP2_RX_WORDSIZE_0(r)		(((r) & GENMASK(2, 0)) >> 0)
+
+/* Number of entries in WORDSIZE and DATA_WIDTH parameter registers */
+#define COMP_MAX_WORDSIZE		(1 << 3)
+#define COMP_MAX_DATA_WIDTH		(1 << 2)
+
+#define MAX_CHANNEL_NUM		8
+#define MIN_CHANNEL_NUM		2
+#define ALL_CHANNEL_NUM		4
+
+
+union dw_i2s_snd_dma_data {
+	struct i2s_dma_data pd;
+	struct snd_dmaengine_dai_dma_data dt;
+};
+
+struct vad_params {
+	void __iomem *vad_base;
+	struct regmap *vad_map;
+	unsigned int vswitch;
+	unsigned int vstatus; /*vad detect status: 1:SPINT 2:SLINT 0:normal*/
+};
+
+struct i2svad_dev {
+	void __iomem *i2s_base;
+	struct clk *clk;
+	int active;
+	unsigned int capability;
+	unsigned int quirks;
+	unsigned int i2s_reg_comp1;
+	unsigned int i2s_reg_comp2;
+	struct device *dev;
+	u32 ccr;
+	u32 xfer_resolution;
+	u32 fifo_th;
+
+	struct clk *clk_apb_i2svad;
+	struct reset_control *rst_apb_i2svad;
+	struct reset_control *rst_i2svad_srst;
+
+	/* data related to DMA transfers b/w i2s and DMAC */
+	union dw_i2s_snd_dma_data play_dma_data;
+	union dw_i2s_snd_dma_data capture_dma_data;
+	struct i2s_clk_config_data config;
+	int (*i2s_clk_cfg)(struct i2s_clk_config_data *config);
+
+	/* data related to PIO transfers */
+	bool use_pio;
+	struct snd_pcm_substream __rcu *tx_substream;
+	struct snd_pcm_substream __rcu *rx_substream;
+	unsigned int (*tx_fn)(struct i2svad_dev *dev,
+			struct snd_pcm_runtime *runtime, unsigned int tx_ptr,
+			bool *period_elapsed);
+	unsigned int (*rx_fn)(struct i2svad_dev *dev,
+			struct snd_pcm_runtime *runtime, unsigned int rx_ptr,
+			bool *period_elapsed);
+	unsigned int tx_ptr;
+	unsigned int rx_ptr;
+
+	struct vad_params vad;
+};
+
+#if IS_ENABLED(CONFIG_SND_STARFIVE_I2SVAD_PCM)
+void i2svad_pcm_push_tx(struct i2svad_dev *dev);
+void i2svad_pcm_pop_rx(struct i2svad_dev *dev);
+int i2svad_pcm_register(struct platform_device *pdev);
+#else
+static inline void i2svad_pcm_push_tx(struct i2svad_dev *dev) { }
+static inline void i2svad_pcm_pop_rx(struct i2svad_dev *dev) { }
+static inline int i2svad_pcm_register(struct platform_device *pdev)
+{
+	return -EINVAL;
+}
+#endif
+
+#endif
diff --git a/sound/soc/starfive/pdm.c b/sound/soc/starfive/pdm.c
new file mode 100644
index 0000000000..71ffa55318
--- /dev/null
+++ b/sound/soc/starfive/pdm.c
@@ -0,0 +1,362 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#include <linux/clk.h>
+#include <linux/module.h>
+#include <linux/of_irq.h>
+#include <linux/of_platform.h>
+#include <linux/regmap.h>
+#include <sound/soc.h>
+#include <sound/soc-dai.h>
+#include <sound/pcm_params.h>
+#include <sound/initval.h>
+#include <sound/tlv.h>
+
+#include "pdm.h"
+
+#define AUDIOC_CLK 	(12288000)
+#define PDM_MUL 	(128)
+
+struct sf_pdm {
+	struct regmap *pdm_map;
+	struct regmap *clk_map;
+	struct clk *clk;
+};
+
+static const DECLARE_TLV_DB_SCALE(volume_tlv, -9450, 150, 0);
+
+static const struct snd_kcontrol_new sf_pdm_snd_controls[] = {
+	SOC_SINGLE("DC compensation Control", PDM_DMIC_CTRL0, 30, 1, 0),
+	SOC_SINGLE("High Pass Filter Control", PDM_DMIC_CTRL0, 28, 1, 0),
+	SOC_SINGLE("Left Channel Volume Control", PDM_DMIC_CTRL0, 23, 1, 0),
+	SOC_SINGLE("Right Channel Volume Control", PDM_DMIC_CTRL0, 22, 1, 0),
+	SOC_SINGLE_TLV("Volume", PDM_DMIC_CTRL0, 16, 0x3F, 1, volume_tlv),
+	SOC_SINGLE("Data MSB Shift", PDM_DMIC_CTRL0, 1, 7, 0),
+	SOC_SINGLE("SCALE", PDM_DC_SCALE0, 0, 0x3F, 0),
+	SOC_SINGLE("DC offset", PDM_DC_SCALE0, 8, 0xFFFFF, 0),
+};
+
+static int sf_pdm_set_mclk(struct regmap *map, unsigned int clk, unsigned int weight)
+{
+	int mclk_div,bclk_div,lrclk_div;
+	u32	pdm_div;
+
+	/*
+	audio source clk:12288000, mclk_div:4, mclk:3M
+	support 8K/16K/32K/48K sample reate
+	suapport 16/24/32 bit weight
+	bit weight 32
+	mclk bclk  lrclk
+	3M   1.5M  48K
+	3M   1M    32K
+	3M   0.5M  16K
+	3M   0.25M  8K
+
+	bit weight 24,set lrclk_div as 32
+	mclk bclk  lrclk
+	3M   1.5M  48K
+	3M   1M    32K
+	3M   0.5M  16K
+	3M   0.25M  8K
+
+	bit weight 16
+	mclk bclk   lrclk
+	3M   0.75M  48K
+	3M   0.5M   32K
+	3M   0.25M  16K
+	3M   0.125M 8K
+	*/
+
+	switch (clk) {
+	case 8000:
+	case 16000:
+	case 32000:
+	case 48000:
+		break;
+	default:
+		printk(KERN_ERR "sample rate:%d\n", clk);
+		return -EINVAL;
+	}
+
+	switch (weight) {
+	case 16:
+	case 24:
+	case 32:
+		break;
+	default:
+		printk(KERN_ERR "bit weight:%d\n", weight);
+		return -EINVAL;
+	}
+
+	if (24 == weight) {
+		weight = 32;
+	}
+
+	mclk_div = 4;
+	bclk_div = AUDIOC_CLK/mclk_div/(clk*weight);
+	lrclk_div = weight;
+
+	/* PDM MCLK = 128*LRCLK */
+	pdm_div = AUDIOC_CLK/(PDM_MUL*clk);
+
+	regmap_update_bits(map, AUDIO_CLK_ADC_MCLK, 0x0F, mclk_div);
+	regmap_update_bits(map, AUDIO_CLK_I2SADC_BCLK, 0x1F, bclk_div);
+	regmap_update_bits(map, AUDIO_CLK_ADC_LRCLK, 0x3F, lrclk_div);
+	regmap_update_bits(map, AUDIO_CLK_PDM_CLK, 0x0F, pdm_div);
+
+	return 0;
+}
+
+static void sf_pdm_enable(struct regmap *map)
+{
+	/* Enable PDM */
+	regmap_update_bits(map, PDM_DMIC_CTRL0, 0x01<<PDM_DMIC_RVOL_OFFSET, 0);
+	regmap_update_bits(map, PDM_DMIC_CTRL0, 0x01<<PDM_DMIC_LVOL_OFFSET, 0);
+}
+
+static void sf_pdm_disable(struct regmap *map)
+{
+	regmap_update_bits(map, PDM_DMIC_CTRL0,
+		0x01<<PDM_DMIC_RVOL_OFFSET, 0x01<<PDM_DMIC_RVOL_OFFSET);
+	regmap_update_bits(map, PDM_DMIC_CTRL0,
+		0x01<<PDM_DMIC_LVOL_OFFSET, 0x01<<PDM_DMIC_LVOL_OFFSET);
+}
+
+static int sf_pdm_trigger(struct snd_pcm_substream *substream, int cmd,
+			struct snd_soc_dai *dai)
+{
+	struct sf_pdm *priv = snd_soc_dai_get_drvdata(dai);
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		sf_pdm_enable(priv->pdm_map);
+		return 0;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		sf_pdm_disable(priv->pdm_map);
+		return 0;
+
+	default:
+		return -EINVAL;
+	}
+}
+
+static int sf_pdm_hw_params(struct snd_pcm_substream *substream,
+			struct snd_pcm_hw_params *params,
+			struct snd_soc_dai *dai)
+{
+	struct sf_pdm *priv = snd_soc_dai_get_drvdata(dai);
+	unsigned int rate = params_rate(params);
+	unsigned int width;
+	int ret;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		return 0;
+
+	width = params_width(params);
+	switch (width) {
+	case 16:
+	case 24:
+	case 32:
+		break;
+	default:
+		dev_err(dai->dev, "unsupported sample width\n");
+		return -EINVAL;
+	}
+
+	ret = sf_pdm_set_mclk(priv->clk_map, rate, width);
+	if (ret < 0) {
+		dev_err(dai->dev, "unsupported sample rate\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sf_pdm_dai_probe(struct snd_soc_dai *dai)
+{
+	struct sf_pdm *priv = snd_soc_dai_get_drvdata(dai);
+
+	/* Reset */
+	regmap_update_bits(priv->pdm_map, PDM_DMIC_CTRL0,
+		0x01<<PDM_DMIC_SW_RSTN_OFFSET, 0x00);
+	regmap_update_bits(priv->pdm_map, PDM_DMIC_CTRL0,
+		0x01<<PDM_DMIC_SW_RSTN_OFFSET, 0x01<<PDM_DMIC_SW_RSTN_OFFSET);
+
+	/* Make sure the device is initially disabled */
+	sf_pdm_disable(priv->pdm_map);
+
+	/* MUTE */
+	regmap_update_bits(priv->pdm_map, PDM_DMIC_CTRL0,
+		0x3F<<PDM_DMIC_VOL_OFFSET, 0x3F<<PDM_DMIC_VOL_OFFSET);
+
+	/* UNMUTE */
+	regmap_update_bits(priv->pdm_map, PDM_DMIC_CTRL0,
+		0x3F<<PDM_DMIC_VOL_OFFSET, 0);
+
+	/* enable high pass filter */
+	regmap_update_bits(priv->pdm_map, PDM_DMIC_CTRL0,
+		0x01<<PDM_DMIC_ENHPF_OFFSET, 0x01<<PDM_DMIC_ENHPF_OFFSET);
+
+	/* i2s slaver mode */
+	regmap_update_bits(priv->pdm_map, PDM_DMIC_CTRL0,
+		0x01<<PDM_DMIC_I2SMODE_OFFSET, 0x01<<PDM_DMIC_I2SMODE_OFFSET);
+
+	/* disable fast mode */
+	regmap_update_bits(priv->pdm_map, PDM_DMIC_CTRL0,
+		0x01<<PDM_DMIC_FASTMODE_OFFSET, 0);
+
+	/* enable dc bypass mode */
+	regmap_update_bits(priv->pdm_map, PDM_DMIC_CTRL0,
+		0x01<<PDM_DMIC_DCBPS_OFFSET, 0);
+
+	/* dmic msb shift 0 */
+	regmap_update_bits(priv->pdm_map, PDM_DMIC_CTRL0,
+		0x07<<PDM_DMIC_MSB_SHIFT_OFFSET, 0);
+
+	/* scale:0 */
+	regmap_update_bits(priv->pdm_map, PDM_DC_SCALE0, 0x3F, 0x08);
+
+	/* DC offset:0 */
+	regmap_update_bits(priv->pdm_map, PDM_DC_SCALE0,
+		0xFFFFF<<PDM_DMIC_DCOFF1_OFFSET, 0xC0005<<PDM_DMIC_DCOFF1_OFFSET);
+
+	return 0;
+}
+
+static int sf_pdm_dai_remove(struct snd_soc_dai *dai)
+{
+	struct sf_pdm *priv = snd_soc_dai_get_drvdata(dai);
+
+	/* MUTE */
+	regmap_update_bits(priv->pdm_map, PDM_DMIC_CTRL0,
+		0x3F<<PDM_DMIC_VOL_OFFSET, 0x3F<<PDM_DMIC_VOL_OFFSET);
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops sf_pdm_dai_ops = {
+	.probe		= sf_pdm_dai_probe,
+	.remove		= sf_pdm_dai_remove,
+	.trigger	= sf_pdm_trigger,
+	.hw_params	= sf_pdm_hw_params,
+};
+
+#define SF_PCM_RATE (SNDRV_PCM_RATE_8000|SNDRV_PCM_RATE_16000|\
+					SNDRV_PCM_RATE_32000|SNDRV_PCM_RATE_48000)
+
+static struct snd_soc_dai_driver sf_pdm_dai_drv = {
+	.name = "PDM",
+	.id = 0,
+	.capture = {
+		.stream_name	= "Capture",
+		.channels_min	= 2,
+		.channels_max	= 2,
+		.rates		= 	SF_PCM_RATE,
+		.formats	= 	SNDRV_PCM_FMTBIT_S16_LE|\
+						SNDRV_PCM_FMTBIT_S24_LE|\
+						SNDRV_PCM_FMTBIT_S32_LE,
+	},
+	.ops		= &sf_pdm_dai_ops,
+	.symmetric_rate = 1,
+};
+
+static int pdm_probe(struct snd_soc_component *component)
+{
+	struct sf_pdm *priv = snd_soc_component_get_drvdata(component);
+
+	snd_soc_component_init_regmap(component, priv->pdm_map);
+	snd_soc_add_component_controls(component, sf_pdm_snd_controls,
+				ARRAY_SIZE(sf_pdm_snd_controls));
+
+	return 0;
+}
+
+static const struct snd_soc_component_driver sf_pdm_component_drv = {
+	.name = "sf-pdm",
+	.probe = pdm_probe,
+};
+
+static const struct regmap_config sf_pdm_regmap_cfg = {
+	.reg_bits	= 32,
+	.val_bits	= 32,
+	.reg_stride	= 4,
+	.max_register	= 0x20,
+};
+
+static const struct regmap_config sf_audio_clk_regmap_cfg = {
+	.reg_bits	= 32,
+	.val_bits	= 32,
+	.reg_stride	= 4,
+	.max_register	= 0x100,
+};
+
+static int sf_pdm_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct sf_pdm *priv;
+	struct resource *res;
+	void __iomem *regs;
+
+	priv = devm_kzalloc(dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+	platform_set_drvdata(pdev, priv);
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "pdm");
+	regs = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(regs))
+		return PTR_ERR(regs);
+
+	priv->pdm_map = devm_regmap_init_mmio(dev, regs, &sf_pdm_regmap_cfg);
+	if (IS_ERR(priv->pdm_map)) {
+		dev_err(dev, "failed to init regmap: %ld\n",
+			PTR_ERR(priv->pdm_map));
+		return PTR_ERR(priv->pdm_map);
+	}
+
+	res = platform_get_resource_byname(pdev, IORESOURCE_MEM, "audio-clk");
+	regs = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(regs))
+		return PTR_ERR(regs);
+
+	priv->clk_map = devm_regmap_init_mmio(dev, regs, &sf_audio_clk_regmap_cfg);
+	if (IS_ERR(priv->clk_map)) {
+		dev_err(dev, "failed to init regmap: %ld\n",
+			PTR_ERR(priv->clk_map));
+		return PTR_ERR(priv->clk_map);
+	}
+
+	return devm_snd_soc_register_component(dev, &sf_pdm_component_drv,
+					&sf_pdm_dai_drv, 1);
+}
+
+static void sf_pdm_dev_remove(struct platform_device *pdev)
+{
+}
+
+static const struct of_device_id sf_pdm_of_match[] = {
+	{.compatible = "starfive,sf-pdm",},
+	{}
+};
+MODULE_DEVICE_TABLE(of, sf_pdm_of_match);
+
+static struct platform_driver sf_pdm_driver = {
+
+	.probe = sf_pdm_probe,
+	.remove = sf_pdm_dev_remove,
+	.driver = {
+		.name = "sf-pdm",
+		.of_match_table = sf_pdm_of_match,
+	},
+};
+module_platform_driver(sf_pdm_driver);
+
+MODULE_AUTHOR("michael.yan <michael.yan@starfivetech.com>");
+MODULE_DESCRIPTION("starfive PDM Controller Driver");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/starfive/pdm.h b/sound/soc/starfive/pdm.h
new file mode 100644
index 0000000000..f510ac41d6
--- /dev/null
+++ b/sound/soc/starfive/pdm.h
@@ -0,0 +1,42 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#ifndef __SND_SOC_STARFIVE_PDM_H
+#define __SND_SOC_STARFIVE_PDM_H
+
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/dmaengine.h>
+#include <linux/types.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/pcm.h>
+
+#define PDM_DMIC_CTRL0			(0x00)
+#define PDM_DC_SCALE0			(0x04)
+#define PDM_DMIC_CTRL1			(0x10)
+#define PDM_DC_SCALE1			(0x14)
+
+/* PDM CTRL OFFSET */
+#define PDM_DMIC_MSB_SHIFT_OFFSET	(1)
+#define PDM_DMIC_VOL_OFFSET		(16)
+#define PDM_DMIC_RVOL_OFFSET		(22)
+#define PDM_DMIC_LVOL_OFFSET		(23)
+#define PDM_DMIC_I2SMODE_OFFSET		(24)
+#define PDM_DMIC_ENHPF_OFFSET		(28)
+#define PDM_DMIC_FASTMODE_OFFSET	(29)
+#define PDM_DMIC_DCBPS_OFFSET		(30)
+#define PDM_DMIC_SW_RSTN_OFFSET		(31)
+
+/* PDM SCALE OFFSET */
+#define PDM_DMIC_DCOFF3_OFFSET		(24)
+#define PDM_DMIC_DCOFF2_OFFSET		(16)
+#define PDM_DMIC_DCOFF1_OFFSET		(8)
+#define PDM_DMIC_SCALE_OFFSET		(0)
+
+#define AUDIO_CLK_ADC_MCLK		0x0
+#define AUDIO_CLK_I2SADC_BCLK		0xC
+#define AUDIO_CLK_ADC_LRCLK		0x14
+#define AUDIO_CLK_PDM_CLK		0x1C
+
+#endif /* __SND_SOC_STARFIVE_PDM_H */
diff --git a/sound/soc/starfive/pwmdac-pcm.c b/sound/soc/starfive/pwmdac-pcm.c
new file mode 100644
index 0000000000..d8d5dd2f35
--- /dev/null
+++ b/sound/soc/starfive/pwmdac-pcm.c
@@ -0,0 +1,233 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#include <linux/io.h>
+#include <linux/rcupdate.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include "pwmdac.h"
+
+#define BUFFER_BYTES_MAX	(3 * 2 * 8 * PERIOD_BYTES_MIN)
+#define PERIOD_BYTES_MIN	4096
+#define PERIODS_MIN		2
+
+static unsigned int sf_pwmdac_pcm_tx_8(struct sf_pwmdac_dev *dev,
+		struct snd_pcm_runtime *runtime, unsigned int tx_ptr,
+		bool *period_elapsed)
+{
+	const u8 (*p)[2] = (void *)runtime->dma_area;
+	unsigned int period_pos = tx_ptr % runtime->period_size;
+	int i;
+	u32 basedat = 0;
+
+	for (i = 0; i < dev->fifo_th; i++) {
+		basedat = (p[tx_ptr][0]<<8)|(p[tx_ptr][1] << 24);
+		iowrite32(basedat,dev->pwmdac_base + PWMDAC_WDATA);
+		period_pos++;
+		if (++tx_ptr >= runtime->buffer_size)
+			tx_ptr = 0;
+	}
+
+	*period_elapsed = period_pos >= runtime->period_size;
+
+	return tx_ptr;
+}
+
+
+static unsigned int sf_pwmdac_pcm_tx_16(struct sf_pwmdac_dev *dev,
+		struct snd_pcm_runtime *runtime, unsigned int tx_ptr,
+		bool *period_elapsed)
+{
+	const u16 (*p)[2] = (void *)runtime->dma_area;
+	unsigned int period_pos = tx_ptr % runtime->period_size;
+	int i;
+	u32 basedat = 0;
+
+	for (i = 0; i < dev->fifo_th; i++) {
+		basedat = (p[tx_ptr][0])|(p[tx_ptr][1] << 16);
+		iowrite32(basedat,dev->pwmdac_base + PWMDAC_WDATA);
+		period_pos++;
+		if (++tx_ptr >= runtime->buffer_size)
+			tx_ptr = 0;
+	}
+
+	*period_elapsed = period_pos >= runtime->period_size;
+	return tx_ptr;
+}
+
+static const struct snd_pcm_hardware sf_pcm_hardware = {
+	.info = SNDRV_PCM_INFO_INTERLEAVED |
+		SNDRV_PCM_INFO_MMAP |
+		SNDRV_PCM_INFO_MMAP_VALID |
+		SNDRV_PCM_INFO_BLOCK_TRANSFER,
+	.rates = SNDRV_PCM_RATE_16000,
+	.rate_min = 16000,
+	.rate_max = 16000,
+	.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	.channels_min = 2,
+	.channels_max = 2,
+	.buffer_bytes_max = BUFFER_BYTES_MAX,
+	.period_bytes_min = PERIOD_BYTES_MIN,
+	.period_bytes_max = BUFFER_BYTES_MAX / PERIODS_MIN,
+	.periods_min = PERIODS_MIN,
+	.periods_max = BUFFER_BYTES_MAX / PERIOD_BYTES_MIN,
+	.fifo_size = 2,
+};
+
+static void sf_pcm_transfer(struct sf_pwmdac_dev *dev, bool push)
+{
+	struct snd_pcm_substream *substream = NULL;
+	bool period_elapsed = false;
+	bool active;
+
+	rcu_read_lock();
+	if (push)
+		substream = rcu_dereference(dev->tx_substream);
+
+	active = substream && snd_pcm_running(substream);
+	if (active) {
+		unsigned int ptr;
+		unsigned int new_ptr;
+
+		if (push) {
+			ptr = READ_ONCE(dev->tx_ptr);
+			new_ptr = dev->tx_fn(dev, substream->runtime, ptr,
+					&period_elapsed);
+			cmpxchg(&dev->tx_ptr, ptr, new_ptr);
+		}
+
+		if (period_elapsed)
+			snd_pcm_period_elapsed(substream);
+	}
+	rcu_read_unlock();
+}
+
+void sf_pwmdac_pcm_push_tx(struct sf_pwmdac_dev *dev)
+{
+	sf_pcm_transfer(dev, true);
+}
+
+
+static int sf_pcm_open(struct snd_soc_component *component,
+			struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_soc_pcm_runtime *rtd = snd_soc_substream_to_rtd(substream);
+	struct sf_pwmdac_dev *dev = snd_soc_dai_get_drvdata(snd_soc_rtd_to_cpu(rtd, 0));
+
+	snd_soc_set_runtime_hwparams(substream, &sf_pcm_hardware);
+	snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);
+	runtime->private_data = dev;
+
+	return 0;
+}
+
+
+static int sf_pcm_close(struct snd_soc_component *component,
+			struct snd_pcm_substream *substream)
+{
+	synchronize_rcu();
+	return 0;
+}
+
+static int sf_pcm_hw_params(struct snd_soc_component *component,
+			struct snd_pcm_substream *substream,
+			struct snd_pcm_hw_params *hw_params)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct sf_pwmdac_dev *dev = runtime->private_data;
+
+	switch (params_channels(hw_params)) {
+	case 2:
+		break;
+	default:
+		dev_err(dev->dev, "invalid channels number\n");
+		return -EINVAL;
+	}
+
+	switch (params_format(hw_params)) {
+	case SNDRV_PCM_FORMAT_U8:
+	case SNDRV_PCM_FORMAT_S8:
+		dev->tx_fn = sf_pwmdac_pcm_tx_8;
+		break;
+	case SNDRV_PCM_FORMAT_S16_LE:
+		dev->tx_fn = sf_pwmdac_pcm_tx_16;
+		break;
+	default:
+		dev_err(dev->dev, "invalid format\n");
+		return -EINVAL;
+	}
+
+		return 0;
+}
+
+
+static int sf_pcm_trigger(struct snd_soc_component *component,
+			struct snd_pcm_substream *substream, int cmd)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct sf_pwmdac_dev *dev = runtime->private_data;
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			WRITE_ONCE(dev->tx_ptr, 0);
+			rcu_assign_pointer(dev->tx_substream, substream);
+		}
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			rcu_assign_pointer(dev->tx_substream, NULL);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static snd_pcm_uframes_t sf_pcm_pointer(struct snd_soc_component *component,
+			struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct sf_pwmdac_dev *dev = runtime->private_data;
+	snd_pcm_uframes_t pos = 0;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		pos = READ_ONCE(dev->tx_ptr);
+
+	return pos < runtime->buffer_size ? pos : 0;
+}
+
+static int sf_pcm_new(struct snd_soc_component *component,
+			struct snd_soc_pcm_runtime *rtd)
+{
+	size_t size = sf_pcm_hardware.buffer_bytes_max;
+
+	snd_pcm_set_managed_buffer_all(rtd->pcm,
+			SNDRV_DMA_TYPE_CONTINUOUS,
+			NULL, size, size);
+	return 0;
+}
+
+static const struct snd_soc_component_driver dw_pcm_component = {
+	.open		= sf_pcm_open,
+	.close		= sf_pcm_close,
+	.hw_params	= sf_pcm_hw_params,
+	.trigger	= sf_pcm_trigger,
+	.pointer	= sf_pcm_pointer,
+	.pcm_construct	= sf_pcm_new,
+};
+
+int sf_pwmdac_pcm_register(struct platform_device *pdev)
+{
+	return devm_snd_soc_register_component(&pdev->dev, &dw_pcm_component,
+					NULL, 0);
+}
diff --git a/sound/soc/starfive/pwmdac-transmitter.c b/sound/soc/starfive/pwmdac-transmitter.c
new file mode 100644
index 0000000000..46c2e5041f
--- /dev/null
+++ b/sound/soc/starfive/pwmdac-transmitter.c
@@ -0,0 +1,81 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/slab.h>
+#include <sound/soc.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <linux/of.h>
+
+#define DRV_NAME "pwmdac-dit"
+
+#define STUB_RATES	SNDRV_PCM_RATE_8000_192000
+#define STUB_FORMATS	(SNDRV_PCM_FMTBIT_S8|\
+			SNDRV_PCM_FMTBIT_U8      |\
+			SNDRV_PCM_FMTBIT_S16_LE  | \
+			SNDRV_PCM_FMTBIT_S20_3LE | \
+			SNDRV_PCM_FMTBIT_S24_LE  | \
+			SNDRV_PCM_FMTBIT_S32_LE)
+
+static const struct snd_soc_dapm_widget dit_widgets[] = {
+	SND_SOC_DAPM_OUTPUT("pwmdac-out"),
+};
+
+static const struct snd_soc_dapm_route dit_routes[] = {
+	{ "pwmdac-out", NULL, "Playback" },
+};
+
+static struct snd_soc_component_driver soc_codec_pwmdac_dit = {
+	.dapm_widgets		= dit_widgets,
+	.num_dapm_widgets	= ARRAY_SIZE(dit_widgets),
+	.dapm_routes		= dit_routes,
+	.num_dapm_routes	= ARRAY_SIZE(dit_routes),
+	.idle_bias_on		= 1,
+	.use_pmdown_time	= 1,
+	.endianness		= 1,
+};
+
+static struct snd_soc_dai_driver dit_stub_dai = {
+	.name		= "pwmdac-dit-hifi",
+	.playback 	= {
+		.stream_name	= "Playback",
+		.channels_min	= 1,
+		.channels_max	= 384,
+		.rates		= STUB_RATES,
+		.formats	= STUB_FORMATS,
+	},
+};
+
+static int pwmdac_dit_probe(struct platform_device *pdev)
+{
+
+	return devm_snd_soc_register_component(&pdev->dev,
+			&soc_codec_pwmdac_dit,
+			&dit_stub_dai, 1);
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id pwmdac_dit_dt_ids[] = {
+	{ .compatible = "linux,pwmdac-dit", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, pwmdac_dit_dt_ids);
+#endif
+
+static struct platform_driver pwmdac_dit_driver = {
+	.probe		= pwmdac_dit_probe,
+	.driver		= {
+		.name	= DRV_NAME,
+		.of_match_table = of_match_ptr(pwmdac_dit_dt_ids),
+	},
+};
+
+module_platform_driver(pwmdac_dit_driver);
+
+MODULE_AUTHOR("jenny.zhang <jenny.zhang@starfivetech.com>");
+MODULE_DESCRIPTION("pwmdac dummy codec driver");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform: starfive-pwmdac dummy codec");
diff --git a/sound/soc/starfive/pwmdac.c b/sound/soc/starfive/pwmdac.c
new file mode 100644
index 0000000000..af5dead70c
--- /dev/null
+++ b/sound/soc/starfive/pwmdac.c
@@ -0,0 +1,862 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * PWMDAC driver for the StarFive JH7100 SoC
+ *
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/init.h>
+#include <linux/io.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/pm_runtime.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/dmaengine_pcm.h>
+#include "pwmdac.h"
+#include <linux/kthread.h>
+
+struct ct_pwmdac {
+	char *name;
+	unsigned int vals;
+};
+
+static const struct ct_pwmdac pwmdac_ct_shift_bit[] = {
+	{ .name = "8bit", .vals = PWMDAC_SHIFT_8 },
+	{ .name = "10bit", .vals = PWMDAC_SHIFT_10 }
+};
+
+static const struct ct_pwmdac pwmdac_ct_duty_cycle[] = {
+	{ .name = "left", .vals = PWMDAC_CYCLE_LEFT },
+	{ .name = "right", .vals = PWMDAC_CYCLE_RIGHT },
+	{ .name = "center", .vals = PWMDAC_CYCLE_CENTER }
+};
+
+static const struct ct_pwmdac pwmdac_ct_data_mode[] = {
+	{ .name = "unsinged", .vals = UNSINGED_DATA },
+	{ .name = "inverter", .vals = INVERTER_DATA_MSB }
+};
+
+static const struct ct_pwmdac pwmdac_ct_lr_change[] = {
+	{ .name = "no_change", .vals = NO_CHANGE },
+	{ .name = "change", .vals = CHANGE }
+};
+
+static const struct ct_pwmdac pwmdac_ct_shift[] = {
+	{ .name = "left 0 bit", .vals = PWMDAC_DATA_LEFT_SHIFT_BIT_0 },
+	{ .name = "left 1 bit", .vals = PWMDAC_DATA_LEFT_SHIFT_BIT_1 },
+	{ .name = "left 2 bit", .vals = PWMDAC_DATA_LEFT_SHIFT_BIT_2 },
+	{ .name = "left 3 bit", .vals = PWMDAC_DATA_LEFT_SHIFT_BIT_3 },
+	{ .name = "left 4 bit", .vals = PWMDAC_DATA_LEFT_SHIFT_BIT_4 },
+	{ .name = "left 5 bit", .vals = PWMDAC_DATA_LEFT_SHIFT_BIT_5 },
+	{ .name = "left 6 bit", .vals = PWMDAC_DATA_LEFT_SHIFT_BIT_6 }
+};
+
+static int pwmdac_shift_bit_info(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_info *uinfo)
+{
+	unsigned int items = ARRAY_SIZE(pwmdac_ct_shift_bit);
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = items;
+	if (uinfo->value.enumerated.item >= items) {
+		uinfo->value.enumerated.item = items - 1;
+	}
+	strcpy(uinfo->value.enumerated.name,
+			pwmdac_ct_shift_bit[uinfo->value.enumerated.item].name);
+
+	return 0;
+}
+static int pwmdac_shift_bit_get(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct sf_pwmdac_dev *dev = snd_soc_component_get_drvdata(component);
+	unsigned int item;
+
+	if (dev->shift_bit == pwmdac_ct_shift_bit[0].vals)
+		item = 0;
+	else
+		item = 1;
+
+	ucontrol->value.enumerated.item[0] = item;
+
+	return 0;
+}
+
+static int pwmdac_shift_bit_put(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct sf_pwmdac_dev *dev = snd_soc_component_get_drvdata(component);
+	int sel = ucontrol->value.enumerated.item[0];
+	unsigned int items = ARRAY_SIZE(pwmdac_ct_shift_bit);
+
+	if (sel >= items)
+		return 0;
+
+	switch (sel) {
+	case 1:
+		dev->shift_bit = pwmdac_ct_shift_bit[1].vals;
+		break;
+	default:
+		dev->shift_bit = pwmdac_ct_shift_bit[0].vals;
+		break;
+	}
+
+	return 0;
+}
+
+static int pwmdac_duty_cycle_info(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_info *uinfo)
+{
+	unsigned int items = ARRAY_SIZE(pwmdac_ct_duty_cycle);
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = items;
+	if (uinfo->value.enumerated.item >= items)
+		uinfo->value.enumerated.item = items - 1;
+	strcpy(uinfo->value.enumerated.name,
+		pwmdac_ct_duty_cycle[uinfo->value.enumerated.item].name);
+
+	return 0;
+}
+
+static int pwmdac_duty_cycle_get(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct sf_pwmdac_dev *dev = snd_soc_component_get_drvdata(component);
+
+	ucontrol->value.enumerated.item[0] = dev->duty_cycle;
+	return 0;
+}
+
+static int pwmdac_duty_cycle_put(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct sf_pwmdac_dev *dev = snd_soc_component_get_drvdata(component);
+	int sel = ucontrol->value.enumerated.item[0];
+	unsigned int items = ARRAY_SIZE(pwmdac_ct_duty_cycle);
+
+	if (sel >= items)
+		return 0;
+
+	dev->duty_cycle = pwmdac_ct_duty_cycle[sel].vals;
+	return 0;
+}
+
+/*
+static int pwmdac_datan_info(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_info *uinfo)
+{
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_INTEGER;
+	uinfo->count = 1;
+	uinfo->value.integer.min = 1;
+	uinfo->value.integer.max = PWMDAC_SAMPLE_CNT_511;
+	uinfo->value.integer.step = 1;
+	return 0;
+}
+
+static int pwmdac_datan_get(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct sf_pwmdac_dev *dev = snd_soc_component_get_drvdata(component);
+
+	ucontrol->value.integer.value[0] = dev->datan;
+
+	return 0;
+}
+
+static int pwmdac_datan_put(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct sf_pwmdac_dev *dev = snd_soc_component_get_drvdata(component);
+	int sel = ucontrol->value.integer.value[0];
+
+	if (sel > PWMDAC_SAMPLE_CNT_511)
+		return 0;
+
+	dev->datan = sel;
+
+	return 0;
+}
+*/
+
+static int pwmdac_data_mode_info(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_info *uinfo)
+{
+	unsigned int items = ARRAY_SIZE(pwmdac_ct_data_mode);
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = items;
+	if (uinfo->value.enumerated.item >= items)
+		uinfo->value.enumerated.item = items - 1;
+	strcpy(uinfo->value.enumerated.name,
+		pwmdac_ct_data_mode[uinfo->value.enumerated.item].name);
+
+	return 0;
+}
+
+static int pwmdac_data_mode_get(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct sf_pwmdac_dev *dev = snd_soc_component_get_drvdata(component);
+
+	ucontrol->value.enumerated.item[0] = dev->data_mode;
+	return 0;
+}
+
+static int pwmdac_data_mode_put(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct sf_pwmdac_dev *dev = snd_soc_component_get_drvdata(component);
+	int sel = ucontrol->value.enumerated.item[0];
+	unsigned int items = ARRAY_SIZE(pwmdac_ct_data_mode);
+
+	if (sel >= items)
+		return 0;
+
+	dev->data_mode = pwmdac_ct_data_mode[sel].vals;
+	return 0;
+}
+
+static int pwmdac_shift_info(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_info *uinfo)
+{
+	unsigned int items = ARRAY_SIZE(pwmdac_ct_shift);
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = items;
+	if (uinfo->value.enumerated.item >= items)
+		uinfo->value.enumerated.item = items - 1;
+	strcpy(uinfo->value.enumerated.name,
+		pwmdac_ct_shift[uinfo->value.enumerated.item].name);
+
+	return 0;
+}
+
+static int pwmdac_shift_get(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct sf_pwmdac_dev *dev = snd_soc_component_get_drvdata(component);
+	unsigned int item = dev->shift;
+
+	ucontrol->value.enumerated.item[0] = pwmdac_ct_shift[item].vals;
+	return 0;
+}
+
+static int pwmdac_shift_put(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct sf_pwmdac_dev *dev = snd_soc_component_get_drvdata(component);
+	int sel = ucontrol->value.enumerated.item[0];
+	unsigned int items = ARRAY_SIZE(pwmdac_ct_shift);
+
+	if (sel >= items)
+		return 0;
+
+	dev->shift = pwmdac_ct_shift[sel].vals;
+	return 0;
+}
+
+static int pwmdac_lr_change_info(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_info *uinfo)
+{
+	unsigned int items = ARRAY_SIZE(pwmdac_ct_lr_change);
+
+	uinfo->type = SNDRV_CTL_ELEM_TYPE_ENUMERATED;
+	uinfo->count = 1;
+	uinfo->value.enumerated.items = items;
+	if (uinfo->value.enumerated.item >= items)
+		uinfo->value.enumerated.item = items - 1;
+	strcpy(uinfo->value.enumerated.name,
+		pwmdac_ct_lr_change[uinfo->value.enumerated.item].name);
+
+	return 0;
+}
+
+static int pwmdac_lr_change_get(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct sf_pwmdac_dev *dev = snd_soc_component_get_drvdata(component);
+
+	ucontrol->value.enumerated.item[0] = dev->lr_change;
+	return 0;
+}
+
+static int pwmdac_lr_change_put(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_component *component = snd_kcontrol_chip(kcontrol);
+	struct sf_pwmdac_dev *dev = snd_soc_component_get_drvdata(component);
+	int sel = ucontrol->value.enumerated.item[0];
+	unsigned int items = ARRAY_SIZE(pwmdac_ct_lr_change);
+
+	if (sel >= items)
+		return 0;
+
+	dev->lr_change = pwmdac_ct_lr_change[sel].vals;
+	return 0;
+}
+
+static inline void pwmdc_write_reg(void __iomem *io_base, int reg, u32 val)
+{
+	writel(val, io_base + reg);
+}
+
+static inline u32 pwmdc_read_reg(void __iomem *io_base, int reg)
+{
+	return readl(io_base + reg);
+}
+
+/*
+ * 32bit-4byte
+*/
+static void pwmdac_set_ctrl_enable(struct sf_pwmdac_dev *dev)
+{
+	u32 date;
+	date = pwmdc_read_reg(dev->pwmdac_base, PWMDAC_CTRL);
+	pwmdc_write_reg(dev->pwmdac_base, PWMDAC_CTRL, date | BIT(0) );
+}
+
+/*
+ * 32bit-4byte
+*/
+static void pwmdac_set_ctrl_disable(struct sf_pwmdac_dev *dev)
+{
+	u32 date;
+	date = pwmdc_read_reg(dev->pwmdac_base, PWMDAC_CTRL);
+	pwmdc_write_reg(dev->pwmdac_base, PWMDAC_CTRL, date & ~ BIT(0));
+}
+
+/*
+ * 8:8-bit
+ * 10:10-bit
+*/
+static void pwmdac_set_ctrl_shift(struct sf_pwmdac_dev *dev, u8 data)
+{
+	u32 value = 0;
+
+	if (data == 8) {
+		value = (~((~value) | 0x02));
+		pwmdc_write_reg(dev->pwmdac_base , PWMDAC_CTRL, value);
+	}
+	else if(data == 10){
+		value |= 0x02;
+		pwmdc_write_reg(dev->pwmdac_base , PWMDAC_CTRL, value);
+	}
+}
+
+/*
+ * 00:left
+ * 01:right
+ * 10:center
+*/
+static void pwmdac_set_ctrl_dutyCycle(struct sf_pwmdac_dev *dev, u8 data)
+{
+	u32 value = 0;
+
+	value = pwmdc_read_reg(dev->pwmdac_base , PWMDAC_CTRL);
+	if (data == 0) { //left
+		value = (~((~value) | (0x03<<2)));
+		pwmdc_write_reg(dev->pwmdac_base , PWMDAC_CTRL, value);
+	}
+	else if (data == 1) { //right
+		value = (~((~value) | (0x01<<3))) | (0x01<<2);
+		pwmdc_write_reg(dev->pwmdac_base , PWMDAC_CTRL, value);
+	}
+	else if (data == 2) { //center
+		value = (~((~value) | (0x01<<2))) | (0x01<<3);
+		pwmdc_write_reg(dev->pwmdac_base , PWMDAC_CTRL, value);
+	}
+}
+
+
+static void pwmdac_set_ctrl_N(struct sf_pwmdac_dev *dev, u16 data)
+{
+	u32 value = 0;
+
+	value = pwmdc_read_reg(dev->pwmdac_base , PWMDAC_CTRL);
+	pwmdc_write_reg(dev->pwmdac_base , PWMDAC_CTRL, (value & 0xF) | ((data - 1) << 4));
+}
+
+
+static void pwmdac_LR_data_change(struct sf_pwmdac_dev *dev, u8 data)
+{
+	u32 value = 0;
+
+	value = pwmdc_read_reg(dev->pwmdac_base , PWMDAC_CTRL);
+	switch (data) {
+	case NO_CHANGE:
+		value &= (~SFC_PWMDAC_LEFT_RIGHT_DATA_CHANGE);
+		break;
+	case CHANGE:
+		value |= SFC_PWMDAC_LEFT_RIGHT_DATA_CHANGE;
+		break;
+	}
+	pwmdc_write_reg(dev->pwmdac_base, PWMDAC_CTRL, value);
+}
+
+static void pwmdac_data_mode(struct sf_pwmdac_dev *dev, u8 data)
+{
+	u32 value = 0;
+
+	value = pwmdc_read_reg(dev->pwmdac_base , PWMDAC_CTRL);
+	if (data == UNSINGED_DATA) {
+		value &= (~SFC_PWMDAC_DATA_MODE);
+	}
+	else if (data == INVERTER_DATA_MSB) {
+		value |= SFC_PWMDAC_DATA_MODE;
+	}
+	pwmdc_write_reg(dev->pwmdac_base,PWMDAC_CTRL, value);
+}
+
+static int pwmdac_data_shift(struct sf_pwmdac_dev *dev,u8 data)
+{
+	u32 value = 0;
+
+	if ((data < PWMDAC_DATA_LEFT_SHIFT_BIT_0) || (data > PWMDAC_DATA_LEFT_SHIFT_BIT_7)) {
+		return -1;
+	}
+
+	value = pwmdc_read_reg(dev->pwmdac_base , PWMDAC_CTRL);
+	value &= ( ~ ( PWMDAC_DATA_LEFT_SHIFT_BIT_ALL << 15 ) );
+	value |= (data<<15);
+	pwmdc_write_reg(dev->pwmdac_base , PWMDAC_CTRL, value);
+	return 0;
+}
+
+static int get_pwmdac_fifo_state(struct sf_pwmdac_dev *dev)
+{
+	u32 value;
+
+	value = pwmdc_read_reg(dev->pwmdac_base , PWMDAC_SATAE);
+	if ((value & 0x02) == 0)
+		return FIFO_UN_FULL;
+
+	return FIFO_FULL;
+}
+
+
+static void pwmdac_set(struct sf_pwmdac_dev *dev)
+{
+	///8-bit + left + N=16
+	pwmdac_set_ctrl_shift(dev, dev->shift_bit);
+	pwmdac_set_ctrl_dutyCycle(dev, dev->duty_cycle);
+	pwmdac_set_ctrl_N(dev, dev->datan);
+	pwmdac_set_ctrl_enable(dev);
+
+	pwmdac_LR_data_change(dev, dev->lr_change);
+	pwmdac_data_mode(dev, dev->data_mode);
+	if (dev->shift) {
+		pwmdac_data_shift(dev, dev->shift);
+	}
+}
+
+static void pwmdac_stop(struct sf_pwmdac_dev *dev)
+{
+	pwmdac_set_ctrl_disable(dev);
+}
+
+static int pwmdac_config(struct sf_pwmdac_dev *dev)
+{
+	switch (dev->mode) {
+	case shift_8Bit_unsigned:
+	case shift_8Bit_unsigned_dataShift:
+		/* 8 bit, unsigned */
+		dev->shift_bit	= PWMDAC_SHIFT_8;
+		dev->duty_cycle	= PWMDAC_CYCLE_CENTER;
+		dev->datan		= PWMDAC_SAMPLE_CNT_8;
+		dev->data_mode	= UNSINGED_DATA;
+		break;
+
+	case shift_8Bit_inverter:
+	case shift_8Bit_inverter_dataShift:
+		/* 8 bit, invert */
+		dev->shift_bit	= PWMDAC_SHIFT_8;
+		dev->duty_cycle	= PWMDAC_CYCLE_CENTER;
+		dev->datan		= PWMDAC_SAMPLE_CNT_8;
+		dev->data_mode	= INVERTER_DATA_MSB;
+		break;
+
+	case shift_10Bit_unsigned:
+	case shift_10Bit_unsigned_dataShift:
+		/* 10 bit, unsigend */
+		dev->shift_bit	= PWMDAC_SHIFT_10;
+		dev->duty_cycle	= PWMDAC_CYCLE_CENTER;
+		dev->datan		= PWMDAC_SAMPLE_CNT_8;
+		dev->data_mode	= UNSINGED_DATA;
+		break;
+
+	case shift_10Bit_inverter:
+	case shift_10Bit_inverter_dataShift:
+		/* 10 bit, invert */
+		dev->shift_bit	= PWMDAC_SHIFT_10;
+		dev->duty_cycle	= PWMDAC_CYCLE_CENTER;
+		dev->datan		= PWMDAC_SAMPLE_CNT_8;
+		dev->data_mode	= INVERTER_DATA_MSB;
+		break;
+
+	default:
+		return -1;
+	}
+
+	if ((dev->mode == shift_8Bit_unsigned_dataShift) || (dev->mode == shift_8Bit_inverter_dataShift)
+		|| (dev->mode == shift_10Bit_unsigned_dataShift) || (dev->mode == shift_10Bit_inverter_dataShift)) {
+		dev->shift = 4; /*0~7*/
+	} else {
+		dev->shift = 0;
+	}
+	dev->lr_change = NO_CHANGE;
+	return 0;
+}
+
+static int sf_pwmdac_prepare(struct snd_pcm_substream *substream,
+			struct snd_soc_dai *dai)
+{
+	//struct sf_pwmdac_dev *dev = snd_soc_dai_get_drvdata(dai);
+	//pwmdac_set(dev);
+	return 0;
+}
+
+static int pwmdac_tx_thread(void *dev)
+{
+	struct sf_pwmdac_dev *pwmdac_dev = (struct sf_pwmdac_dev *)dev;
+
+	set_current_state(TASK_INTERRUPTIBLE);
+	while (!schedule_timeout(usecs_to_jiffies(50))) {
+		if (pwmdac_dev->tx_thread_exit)
+			break;
+		if (get_pwmdac_fifo_state(pwmdac_dev)==0) {
+			sf_pwmdac_pcm_push_tx(pwmdac_dev);
+		}
+
+		set_current_state(TASK_INTERRUPTIBLE);
+	}
+
+	pwmdac_dev->tx_thread = NULL;
+	return 0;
+}
+
+static int sf_pwmdac_trigger(struct snd_pcm_substream *substream,
+		int cmd, struct snd_soc_dai *dai)
+{
+	struct sf_pwmdac_dev *dev = snd_soc_dai_get_drvdata(dai);
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		dev->active++;
+		pwmdac_set(dev);
+		if (dev->use_pio) {
+			dev->tx_thread = kthread_create(pwmdac_tx_thread, (void *)dev, "pwmdac");
+			if (IS_ERR(dev->tx_thread)) {
+				return PTR_ERR(dev->tx_thread);
+			}
+			wake_up_process(dev->tx_thread);
+			dev->tx_thread_exit = 0;
+		}
+		break;
+
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		dev->active--;
+		pwmdac_stop(dev);
+		if (dev->use_pio) {
+			if(dev->tx_thread) {
+				dev->tx_thread_exit = 1;
+			}
+		}
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+	return ret;
+
+	return 0;
+}
+
+static int sf_pwmdac_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct sf_pwmdac_dev *dev = dev_get_drvdata(dai->dev);
+
+	dev->play_dma_data.addr = dev->mapbase + PWMDAC_WDATA;
+
+	switch (params_channels(params)) {
+	case 2:
+		dev->play_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+		break;
+	case 1:
+		dev->play_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_2_BYTES;
+		break;
+	default:
+		dev_err(dai->dev, "%d channels not supported\n",
+				params_channels(params));
+		return -EINVAL;
+	}
+
+	dev->play_dma_data.fifo_size = 1;
+	dev->play_dma_data.maxburst = 16;
+
+	snd_soc_dai_init_dma_data(dai, &dev->play_dma_data, NULL);
+	snd_soc_dai_set_drvdata(dai, dev);
+
+	return 0;
+}
+
+static int sf_pwmdac_clks_get(struct platform_device *pdev,
+			      struct sf_pwmdac_dev *dev)
+{
+	static const char *const clock_names[PWMDAC_CLK_NUM] = {
+		[PWMDAC_CLK_AUDIO_ROOT]  = "audio_root",
+		[PWMDAC_CLK_AUDIO_SRC]   = "audio_src",
+		[PWMDAC_CLK_AUDIO_12288] = "audio_12288",
+		[PWMDAC_CLK_DMA1P_AHB]   = "dma1p_ahb",
+		[PWMDAC_CLK_PWMDAC_APB]  = "pwmdac_apb",
+		[PWMDAC_CLK_DAC_MCLK]    = "dac_mclk",
+	};
+	int i;
+
+	for (i = 0; i < PWMDAC_CLK_NUM; i++)
+		dev->clk[i].id = clock_names[i];
+
+	return devm_clk_bulk_get(&pdev->dev, ARRAY_SIZE(dev->clk), dev->clk);
+}
+
+static int sf_pwmdac_resets_get(struct platform_device *pdev,
+				struct sf_pwmdac_dev *dev)
+{
+	static const char *const reset_names[PWMDAC_RST_NUM] = {
+		[PWMDAC_RST_APB_BUS]    = "apb_bus",
+		[PWMDAC_RST_DMA1P_AHB]  = "dma1p_ahb",
+		[PWMDAC_RST_APB_PWMDAC] = "apb_pwmdac",
+	};
+	int i;
+
+	for (i = 0; i < PWMDAC_RST_NUM; i++)
+		dev->rst[i].id = reset_names[i];
+
+	return devm_reset_control_bulk_get_exclusive(&pdev->dev, ARRAY_SIZE(dev->rst), dev->rst);
+}
+
+static int sf_pwmdac_clk_init(struct platform_device *pdev,
+				struct sf_pwmdac_dev *dev)
+{
+	int ret;
+	int i;
+
+	for (i = 0; i <= PWMDAC_CLK_DMA1P_AHB; i++) {
+		ret = clk_prepare_enable(dev->clk[i].clk);
+		if (ret)
+			return dev_err_probe(&pdev->dev, ret,
+					     "failed to enable %s\n", dev->clk[i].id);
+	}
+
+	for (i = 0; i <= PWMDAC_RST_DMA1P_AHB; i++) {
+		ret = reset_control_deassert(dev->rst[i].rstc);
+		if (ret)
+			return dev_err_probe(&pdev->dev, ret,
+					     "failed to deassert %s\n", dev->rst[i].id);
+	}
+
+	ret = clk_set_rate(dev->clk[PWMDAC_CLK_AUDIO_SRC].clk, 12288000);
+	if (ret)
+		return dev_err_probe(&pdev->dev, ret,
+				     "failed to set 12.288 MHz rate for clk_audio_src\n");
+
+	ret = reset_control_assert(dev->rst[PWMDAC_RST_APB_PWMDAC].rstc);
+	if (ret)
+		return dev_err_probe(&pdev->dev, ret, "failed to assert apb_pwmdac\n");
+
+	ret = clk_prepare_enable(dev->clk[PWMDAC_CLK_DAC_MCLK].clk);
+	if (ret)
+		return dev_err_probe(&pdev->dev, ret, "failed to prepare enable clk_dac_mclk\n");
+
+	/* we want 4096kHz but the clock driver always rounds down so add a little slack */
+	ret = clk_set_rate(dev->clk[PWMDAC_CLK_DAC_MCLK].clk, 4096000 + 64);
+	if (ret)
+		return dev_err_probe(&pdev->dev, ret, "failed to set 4096kHz rate for clk_dac_mclk\n");
+
+	ret = clk_prepare_enable(dev->clk[PWMDAC_CLK_PWMDAC_APB].clk);
+	if (ret)
+		return dev_err_probe(&pdev->dev, ret, "failed to prepare enable clk_pwmdac_apb\n");
+
+	ret = reset_control_deassert(dev->rst[PWMDAC_RST_APB_PWMDAC].rstc);
+	if (ret)
+		return dev_err_probe(&pdev->dev, ret, "failed to deassert apb_pwmdac\n");
+
+	return 0;
+}
+
+#define SOC_PWMDAC_ENUM_DECL(xname, xinfo, xget, xput) \
+{	.iface = SNDRV_CTL_ELEM_IFACE_MIXER, .name = xname, \
+	.info = xinfo, .get = xget, \
+	.put = xput,}
+static const struct snd_kcontrol_new pwmdac_snd_controls[] = {
+	SOC_PWMDAC_ENUM_DECL("shift_bit", pwmdac_shift_bit_info,
+		pwmdac_shift_bit_get, pwmdac_shift_bit_put),
+	SOC_PWMDAC_ENUM_DECL("duty_cycle", pwmdac_duty_cycle_info,
+		pwmdac_duty_cycle_get, pwmdac_duty_cycle_put),
+	SOC_PWMDAC_ENUM_DECL("data_mode", pwmdac_data_mode_info,
+		pwmdac_data_mode_get, pwmdac_data_mode_put),
+	SOC_PWMDAC_ENUM_DECL("shift", pwmdac_shift_info,
+		pwmdac_shift_get, pwmdac_shift_put),
+	SOC_PWMDAC_ENUM_DECL("lr_change", pwmdac_lr_change_info,
+		pwmdac_lr_change_get, pwmdac_lr_change_put),
+};
+
+static int pwmdac_probe(struct snd_soc_component *component)
+{
+//	struct sf_pwmdac_dev *priv = snd_soc_component_get_drvdata(component);
+	snd_soc_add_component_controls(component, pwmdac_snd_controls,
+				ARRAY_SIZE(pwmdac_snd_controls));
+	return 0;
+}
+
+static const struct snd_soc_component_driver sf_pwmdac_component = {
+	.name		= "sf-pwmdac",
+	.probe		= pwmdac_probe,
+};
+
+static int sf_pwmdac_dai_probe(struct snd_soc_dai *dai)
+{
+	struct sf_pwmdac_dev *dev = dev_get_drvdata(dai->dev);
+
+	dev->play_dma_data.addr = dev->mapbase + PWMDAC_WDATA;
+	dev->play_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	dev->play_dma_data.fifo_size = 1;
+	dev->play_dma_data.maxburst = 16;
+
+	snd_soc_dai_init_dma_data(dai, &dev->play_dma_data, NULL);
+	snd_soc_dai_set_drvdata(dai, dev);
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops sf_pwmdac_dai_ops = {
+	.probe		= sf_pwmdac_dai_probe,
+	.hw_params	= sf_pwmdac_hw_params,
+	.prepare	= sf_pwmdac_prepare,
+	.trigger	= sf_pwmdac_trigger,
+};
+
+static struct snd_soc_dai_driver pwmdac_dai = {
+	.name = "pwmdac",
+	.id = 0,
+	.playback = {
+		.channels_min = 1,
+		.channels_max = 2,
+		.rates = SNDRV_PCM_RATE_16000,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE,
+	},
+	.ops = &sf_pwmdac_dai_ops,
+};
+
+static int sf_pwmdac_probe(struct platform_device *pdev)
+{
+	struct sf_pwmdac_dev *dev;
+	struct resource *res;
+	int ret;
+
+	dev = devm_kzalloc(&pdev->dev, sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	dev->mapbase = res->start;
+	dev->pwmdac_base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(dev->pwmdac_base))
+		return PTR_ERR(dev->pwmdac_base);
+
+	ret = sf_pwmdac_clks_get(pdev, dev);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to get audio clock\n");
+		return ret;
+	}
+
+	ret = sf_pwmdac_resets_get(pdev, dev);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to get audio reset controls\n");
+		return ret;
+        }
+
+	ret = sf_pwmdac_clk_init(pdev, dev);
+	if (ret) {
+		dev_err(&pdev->dev, "failed to enable audio clock\n");
+		return ret;
+	}
+
+	dev->dev = &pdev->dev;
+	dev->mode = shift_8Bit_inverter;
+	dev->fifo_th = 1;//8byte
+	pwmdac_config(dev);
+
+	dev->use_pio = false;
+	dev_set_drvdata(&pdev->dev, dev);
+	ret = devm_snd_soc_register_component(&pdev->dev, &sf_pwmdac_component,
+					 &pwmdac_dai, 1);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "not able to register dai\n");
+		return ret;
+	}
+
+	if (dev->use_pio) {
+		ret = sf_pwmdac_pcm_register(pdev);
+	} else {
+		ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL,
+				0);
+	}
+	return 0;
+}
+
+
+static void sf_pwmdac_remove(struct platform_device *pdev)
+{
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id sf_pwmdac_of_match[] = {
+	{ .compatible = "starfive,pwmdac",	 },
+	{},
+};
+
+MODULE_DEVICE_TABLE(of, sf_pwmdac_of_match);
+#endif
+
+
+static struct platform_driver sf_pwmdac_driver = {
+	.probe		= sf_pwmdac_probe,
+	.remove		= sf_pwmdac_remove,
+	.driver		= {
+		.name	= "sf-pwmdac",
+		.of_match_table = of_match_ptr(sf_pwmdac_of_match),
+	},
+};
+
+module_platform_driver(sf_pwmdac_driver);
+
+MODULE_AUTHOR("jenny.zhang <jenny.zhang@starfivetech.com>");
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("starfive pwmdac SoC Interface");
+MODULE_ALIAS("platform:starfive-pwmdac");
diff --git a/sound/soc/starfive/pwmdac.h b/sound/soc/starfive/pwmdac.h
new file mode 100644
index 0000000000..b9f651fc59
--- /dev/null
+++ b/sound/soc/starfive/pwmdac.h
@@ -0,0 +1,161 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#ifndef __SND_SOC_STARFIVE_PWMDAC_H
+#define __SND_SOC_STARFIVE_PWMDAC_H
+
+#include <linux/clk.h>
+#include <linux/reset.h>
+#include <linux/device.h>
+#include <linux/types.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/pcm.h>
+
+#define PWMDAC_WDATA	0	// PWMDAC_BASE_ADDR
+#define PWMDAC_CTRL	0x04	// PWMDAC_BASE_ADDR + 0x04
+#define PWMDAC_SATAE	0x08	// PWMDAC_BASE_ADDR + 0x08
+#define PWMDAC_RESERVED	0x0C	// PWMDAC_BASE_ADDR + 0x0C
+
+#define SFC_PWMDAC_SHIFT	BIT(1)
+#define SFC_PWMDAC_DUTY_CYCLE	BIT(2)
+#define SFC_PWMDAC_CNT_N	BIT(4)
+
+#define SFC_PWMDAC_LEFT_RIGHT_DATA_CHANGE	BIT(13)
+#define SFC_PWMDAC_DATA_MODE			BIT(14)
+
+#define FIFO_UN_FULL	0
+#define FIFO_FULL	1
+
+enum pwmdac_lr_change{
+	NO_CHANGE = 0,
+	CHANGE,
+};
+
+enum pwmdac_d_mode{
+	UNSINGED_DATA = 0,
+	INVERTER_DATA_MSB,
+};
+
+enum pwmdac_shift_bit{
+	PWMDAC_SHIFT_8 = 8,	/* pwmdac shift 8 bit */
+	PWMDAC_SHIFT_10 = 10,	/* pwmdac shift 10 bit */
+};
+
+enum pwmdac_duty_cycle{
+	PWMDAC_CYCLE_LEFT = 0,		/* pwmdac duty cycle left */
+	PWMDAC_CYCLE_RIGHT = 1,		/* pwmdac duty cycle right */
+	PWMDAC_CYCLE_CENTER = 2,	/* pwmdac duty cycle center */
+};
+
+/*sample count [12:4] <511*/
+enum pwmdac_sample_count{
+	PWMDAC_SAMPLE_CNT_1 = 1,
+	PWMDAC_SAMPLE_CNT_2,
+	PWMDAC_SAMPLE_CNT_3,
+	PWMDAC_SAMPLE_CNT_4,
+	PWMDAC_SAMPLE_CNT_5,
+	PWMDAC_SAMPLE_CNT_6,
+	PWMDAC_SAMPLE_CNT_7,
+	PWMDAC_SAMPLE_CNT_8 = 1,	//(32.468/8) == (12.288/3) == 4.096
+	PWMDAC_SAMPLE_CNT_9,
+	PWMDAC_SAMPLE_CNT_10,
+	PWMDAC_SAMPLE_CNT_11,
+	PWMDAC_SAMPLE_CNT_12,
+	PWMDAC_SAMPLE_CNT_13,
+	PWMDAC_SAMPLE_CNT_14,
+	PWMDAC_SAMPLE_CNT_15,
+	PWMDAC_SAMPLE_CNT_16,
+	PWMDAC_SAMPLE_CNT_17,
+	PWMDAC_SAMPLE_CNT_18,
+	PWMDAC_SAMPLE_CNT_19,
+	PWMDAC_SAMPLE_CNT_20 = 20,
+	PWMDAC_SAMPLE_CNT_30 = 30,
+	PWMDAC_SAMPLE_CNT_511 = 511,
+};
+
+
+enum data_shift{
+	PWMDAC_DATA_LEFT_SHIFT_BIT_0 = 0,
+	PWMDAC_DATA_LEFT_SHIFT_BIT_1,
+	PWMDAC_DATA_LEFT_SHIFT_BIT_2,
+	PWMDAC_DATA_LEFT_SHIFT_BIT_3,
+	PWMDAC_DATA_LEFT_SHIFT_BIT_4,
+	PWMDAC_DATA_LEFT_SHIFT_BIT_5,
+	PWMDAC_DATA_LEFT_SHIFT_BIT_6,
+	PWMDAC_DATA_LEFT_SHIFT_BIT_7,
+	PWMDAC_DATA_LEFT_SHIFT_BIT_ALL,
+};
+
+enum pwmdac_config_list{
+	shift_8Bit_unsigned = 0,
+	shift_8Bit_unsigned_dataShift,
+	shift_10Bit_unsigned,
+	shift_10Bit_unsigned_dataShift,
+
+	shift_8Bit_inverter,
+	shift_8Bit_inverter_dataShift,
+	shift_10Bit_inverter,
+	shift_10Bit_inverter_dataShift,
+};
+
+enum pwmdac_clocks {
+	PWMDAC_CLK_AUDIO_ROOT,
+	PWMDAC_CLK_AUDIO_SRC,
+	PWMDAC_CLK_AUDIO_12288,
+	PWMDAC_CLK_DMA1P_AHB,
+	PWMDAC_CLK_PWMDAC_APB,
+	PWMDAC_CLK_DAC_MCLK,
+	PWMDAC_CLK_NUM,
+};
+
+enum pwmdac_resets {
+	PWMDAC_RST_APB_BUS,
+	PWMDAC_RST_DMA1P_AHB,
+	PWMDAC_RST_APB_PWMDAC,
+	PWMDAC_RST_NUM,
+};
+
+struct sf_pwmdac_dev {
+	void __iomem *pwmdac_base;
+	resource_size_t	mapbase;
+	u8  mode;
+	u8 shift_bit;
+	u8 duty_cycle;
+	u8 datan;
+	u8 data_mode;
+	u8 lr_change;
+	u8 shift;
+	u8 fifo_th;
+	bool use_pio;
+	spinlock_t lock;
+	int active;
+
+	struct clk_bulk_data clk[PWMDAC_CLK_NUM];
+	struct reset_control_bulk_data rst[PWMDAC_RST_NUM];
+
+	struct device *dev;
+	struct snd_dmaengine_dai_dma_data play_dma_data;
+	struct snd_pcm_substream __rcu *tx_substream;
+	unsigned int (*tx_fn)(struct sf_pwmdac_dev *dev,
+			struct snd_pcm_runtime *runtime, unsigned int tx_ptr,
+			bool *period_elapsed);
+	unsigned int tx_ptr;
+	struct task_struct *tx_thread;
+	bool tx_thread_exit;
+};
+
+
+
+#if IS_ENABLED(CONFIG_SND_STARFIVE_PWMDAC_PCM)
+void sf_pwmdac_pcm_push_tx(struct sf_pwmdac_dev *dev);
+int sf_pwmdac_pcm_register(struct platform_device *pdev);
+#else
+static void sf_pwmdac_pcm_push_tx(struct sf_pwmdac_dev *dev) { }
+static int sf_pwmdac_pcm_register(struct platform_device *pdev)
+{
+	return -EINVAL;
+}
+#endif
+
+#endif
diff --git a/sound/soc/starfive/spdif-pcm.c b/sound/soc/starfive/spdif-pcm.c
new file mode 100644
index 0000000000..1763adc197
--- /dev/null
+++ b/sound/soc/starfive/spdif-pcm.c
@@ -0,0 +1,288 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#include <linux/io.h>
+#include <linux/rcupdate.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+
+#include "spdif.h"
+
+#define BUFFER_BYTES_MAX	(3 * 2 * 8 * PERIOD_BYTES_MIN)
+#define PERIOD_BYTES_MIN	4096
+#define PERIODS_MIN			2
+
+static unsigned int sf_spdif_pcm_tx(struct sf_spdif_dev *dev,
+		struct snd_pcm_runtime *runtime, unsigned int tx_ptr,
+		bool *period_elapsed, snd_pcm_format_t format)
+{
+	const u16 (*p16)[2] = (void *)runtime->dma_area;
+	const u32 (*p32)[2] = (void *)runtime->dma_area;
+	u32 data[2];
+	unsigned int period_pos = tx_ptr % runtime->period_size;
+	int i;
+
+	for (i = 0; i < dev->fifo_th; i++) {
+		if (SNDRV_PCM_FORMAT_S16_LE == format) {
+			data[0] = p16[tx_ptr][0];
+			data[1] = p16[tx_ptr][1];
+			data[0] = data[0]<<8;
+			data[1] = data[1]<<8;
+		} else if (SNDRV_PCM_FORMAT_S24_LE == format) {
+			data[0] = p32[tx_ptr][0];
+			data[1] = p32[tx_ptr][1];
+		} else if (SNDRV_PCM_FORMAT_S32_LE == format) {
+			data[0] = p32[tx_ptr][0];
+			data[1] = p32[tx_ptr][1];
+			data[0] = data[0]>>8;
+			data[1] = data[1]>>8;
+		}
+
+		iowrite32(data[0], dev->spdif_base + SPDIF_FIFO_ADDR);
+		iowrite32(data[1], dev->spdif_base + SPDIF_FIFO_ADDR);
+		period_pos++;
+		if (++tx_ptr >= runtime->buffer_size) {
+			tx_ptr = 0;
+		}
+	}
+
+	*period_elapsed = period_pos >= runtime->period_size;
+	return tx_ptr;
+}
+
+static unsigned int sf_spdif_pcm_rx(struct sf_spdif_dev *dev,
+		struct snd_pcm_runtime *runtime, unsigned int rx_ptr,
+		bool *period_elapsed, snd_pcm_format_t format)
+{
+	u16 (*p16)[2] = (void *)runtime->dma_area;
+	u32 (*p32)[2] = (void *)runtime->dma_area;
+	u32 data[2];
+	unsigned int period_pos = rx_ptr % runtime->period_size;
+	int i;
+
+	for (i = 0; i < dev->fifo_th; i++) {
+		data[0] = ioread32(dev->spdif_base + SPDIF_FIFO_ADDR);
+		data[1] = ioread32(dev->spdif_base + SPDIF_FIFO_ADDR);
+		if (SNDRV_PCM_FORMAT_S16_LE == format) {
+			p16[rx_ptr][0] = data[0]>>8;
+			p16[rx_ptr][1] = data[1]>>8;
+		} else if (SNDRV_PCM_FORMAT_S24_LE == format) {
+			p32[rx_ptr][0] = data[0];
+			p32[rx_ptr][1] = data[1];
+		} else if (SNDRV_PCM_FORMAT_S32_LE == format) {
+			p32[rx_ptr][0] = data[0]<<8;
+			p32[rx_ptr][1] = data[1]<<8;
+		}
+
+		period_pos++;
+		if (++rx_ptr >= runtime->buffer_size)
+			rx_ptr = 0;
+	}
+
+	*period_elapsed = period_pos >= runtime->period_size;
+	return rx_ptr;
+}
+
+static const struct snd_pcm_hardware sf_pcm_hardware = {
+	.info = SNDRV_PCM_INFO_INTERLEAVED |
+		SNDRV_PCM_INFO_MMAP |
+		SNDRV_PCM_INFO_MMAP_VALID |
+		SNDRV_PCM_INFO_BLOCK_TRANSFER,
+	.rates = SNDRV_PCM_RATE_8000 |
+		SNDRV_PCM_RATE_11025 |
+		SNDRV_PCM_RATE_16000 |
+		SNDRV_PCM_RATE_22050 |
+		SNDRV_PCM_RATE_32000 |
+		SNDRV_PCM_RATE_44100 |
+		SNDRV_PCM_RATE_48000,
+	.rate_min = 8000,
+	.rate_max = 48000,
+	.formats = SNDRV_PCM_FMTBIT_S16_LE |
+		SNDRV_PCM_FMTBIT_S24_LE |
+		SNDRV_PCM_FMTBIT_S32_LE,
+	.channels_min = 2,
+	.channels_max = 2,
+	.buffer_bytes_max = BUFFER_BYTES_MAX,
+	.period_bytes_min = PERIOD_BYTES_MIN,
+	.period_bytes_max = BUFFER_BYTES_MAX / PERIODS_MIN,
+	.periods_min = PERIODS_MIN,
+	.periods_max = BUFFER_BYTES_MAX / PERIOD_BYTES_MIN,
+	.fifo_size = 16,
+};
+
+static void sf_spdif_pcm_transfer(struct sf_spdif_dev *dev, bool push)
+{
+	struct snd_pcm_substream *substream;
+	bool active, period_elapsed;
+
+	rcu_read_lock();
+	if (push)
+		substream = rcu_dereference(dev->tx_substream);
+	else
+		substream = rcu_dereference(dev->rx_substream);
+	active = substream && snd_pcm_running(substream);
+	if (active) {
+		unsigned int ptr;
+		unsigned int new_ptr;
+
+		if (push) {
+			ptr = READ_ONCE(dev->tx_ptr);
+			new_ptr = dev->tx_fn(dev, substream->runtime, ptr,
+					&period_elapsed, dev->format);
+			cmpxchg(&dev->tx_ptr, ptr, new_ptr);
+		} else {
+			ptr = READ_ONCE(dev->rx_ptr);
+			new_ptr = dev->rx_fn(dev, substream->runtime, ptr,
+					&period_elapsed, dev->format);
+			cmpxchg(&dev->rx_ptr, ptr, new_ptr);
+		}
+
+		if (period_elapsed)
+			snd_pcm_period_elapsed(substream);
+	}
+	rcu_read_unlock();
+}
+
+void sf_spdif_pcm_push_tx(struct sf_spdif_dev *dev)
+{
+	sf_spdif_pcm_transfer(dev, true);
+}
+
+void sf_spdif_pcm_pop_rx(struct sf_spdif_dev *dev)
+{
+	sf_spdif_pcm_transfer(dev, false);
+}
+
+static int sf_pcm_open(struct snd_soc_component *component,
+			struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct snd_soc_pcm_runtime *rtd = snd_soc_substream_to_rtd(substream);
+	struct sf_spdif_dev *dev = snd_soc_dai_get_drvdata(snd_soc_rtd_to_cpu(rtd, 0));
+
+	snd_soc_set_runtime_hwparams(substream, &sf_pcm_hardware);
+	snd_pcm_hw_constraint_integer(runtime, SNDRV_PCM_HW_PARAM_PERIODS);
+	runtime->private_data = dev;
+
+	return 0;
+}
+
+static int sf_pcm_close(struct snd_soc_component *component,
+			struct snd_pcm_substream *substream)
+{
+	synchronize_rcu();
+	return 0;
+}
+
+static int sf_pcm_hw_params(struct snd_soc_component *component,
+			struct snd_pcm_substream *substream,
+			struct snd_pcm_hw_params *hw_params)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct sf_spdif_dev *dev = runtime->private_data;
+
+	switch (params_channels(hw_params)) {
+	case 2:
+		break;
+	default:
+		dev_err(dev->dev, "invalid channels number\n");
+		return -EINVAL;
+	}
+
+	dev->format = params_format(hw_params);
+	switch (dev->format) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+	case SNDRV_PCM_FORMAT_S24_LE:
+	case SNDRV_PCM_FORMAT_S32_LE:
+		break;
+	default:
+		dev_err(dev->dev, "invalid format\n");
+		return -EINVAL;
+	}
+
+	dev->tx_fn = sf_spdif_pcm_tx;
+	dev->rx_fn = sf_spdif_pcm_rx;
+
+	return 0;
+}
+
+static int sf_pcm_trigger(struct snd_soc_component *component,
+			struct snd_pcm_substream *substream, int cmd)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct sf_spdif_dev *dev = runtime->private_data;
+	int ret = 0;
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+			WRITE_ONCE(dev->tx_ptr, 0);
+			rcu_assign_pointer(dev->tx_substream, substream);
+		} else {
+			WRITE_ONCE(dev->rx_ptr, 0);
+			rcu_assign_pointer(dev->rx_substream, substream);
+		}
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+			rcu_assign_pointer(dev->tx_substream, NULL);
+		else
+			rcu_assign_pointer(dev->rx_substream, NULL);
+		break;
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	return ret;
+}
+
+static snd_pcm_uframes_t sf_pcm_pointer(struct snd_soc_component *component,
+					struct snd_pcm_substream *substream)
+{
+	struct snd_pcm_runtime *runtime = substream->runtime;
+	struct sf_spdif_dev *dev = runtime->private_data;
+	snd_pcm_uframes_t pos;
+
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		pos = READ_ONCE(dev->tx_ptr);
+	}
+	else {
+		pos = READ_ONCE(dev->rx_ptr);
+	}
+
+	return pos < runtime->buffer_size ? pos : 0;
+}
+
+static int sf_pcm_new(struct snd_soc_component *component,
+			struct snd_soc_pcm_runtime *rtd)
+{
+	size_t size = sf_pcm_hardware.buffer_bytes_max;
+
+	snd_pcm_set_managed_buffer_all(rtd->pcm,
+			SNDRV_DMA_TYPE_CONTINUOUS,
+			NULL, size, size);
+
+	return 0;
+}
+
+static const struct snd_soc_component_driver sf_pcm_component = {
+	.open		= sf_pcm_open,
+	.close		= sf_pcm_close,
+	.hw_params	= sf_pcm_hw_params,
+	.trigger	= sf_pcm_trigger,
+	.pointer	= sf_pcm_pointer,
+	.pcm_construct	= sf_pcm_new,
+};
+
+int sf_spdif_pcm_register(struct platform_device *pdev)
+{
+	return devm_snd_soc_register_component(&pdev->dev, &sf_pcm_component,
+					NULL, 0);
+}
+
diff --git a/sound/soc/starfive/spdif.c b/sound/soc/starfive/spdif.c
new file mode 100644
index 0000000000..f021e99bf7
--- /dev/null
+++ b/sound/soc/starfive/spdif.c
@@ -0,0 +1,384 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <linux/clk.h>
+#include <linux/regmap.h>
+
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/initval.h>
+#include <sound/dmaengine_pcm.h>
+
+#include "spdif.h"
+
+static irqreturn_t spdif_irq_handler(int irq, void *dev_id)
+{
+	struct sf_spdif_dev *dev = dev_id;
+	bool irq_valid = false;
+	unsigned int intr;
+	unsigned int stat;
+
+	regmap_read(dev->regmap, SPDIF_INT_REG, &intr);
+	regmap_read(dev->regmap, SPDIF_STAT_REG, &stat);
+	regmap_update_bits(dev->regmap, SPDIF_CTRL,
+		SPDIF_MASK_ENABLE, 0);
+	regmap_update_bits(dev->regmap, SPDIF_INT_REG,
+		SPDIF_INT_REG_BIT, 0);
+
+	if ((stat & SPDIF_EMPTY_FLAG) || (stat & SPDIF_AEMPTY_FLAG)) {
+		sf_spdif_pcm_push_tx(dev);
+		irq_valid = true;
+	}
+
+	if ((stat & SPDIF_FULL_FLAG) || (stat & SPDIF_AFULL_FLAG)) {
+		sf_spdif_pcm_pop_rx(dev);
+		irq_valid = true;
+	}
+
+	if (stat & SPDIF_PARITY_FLAG) {
+		irq_valid = true;
+	}
+
+	if (stat & SPDIF_UNDERR_FLAG) {
+		irq_valid = true;
+	}
+
+	if (stat & SPDIF_OVRERR_FLAG) {
+		irq_valid = true;
+	}
+
+	if (stat & SPDIF_SYNCERR_FLAG) {
+		irq_valid = true;
+	}
+
+	if (stat & SPDIF_LOCK_FLAG) {
+		irq_valid = true;
+	}
+
+	if (stat & SPDIF_BEGIN_FLAG) {
+		irq_valid = true;
+	}
+
+	if (stat & SPDIF_RIGHT_LEFT) {
+		irq_valid = true;
+	}
+
+	regmap_update_bits(dev->regmap, SPDIF_CTRL,
+		SPDIF_MASK_ENABLE, SPDIF_MASK_ENABLE);
+
+	if (irq_valid)
+		return IRQ_HANDLED;
+	else
+		return IRQ_NONE;
+}
+
+static int sf_spdif_trigger(struct snd_pcm_substream *substream, int cmd,
+	struct snd_soc_dai *dai)
+{
+	struct sf_spdif_dev *spdif = snd_soc_dai_get_drvdata(dai);
+	bool tx;
+
+	tx = substream->stream == SNDRV_PCM_STREAM_PLAYBACK;
+	if (tx) {
+		/* tx mode */
+		regmap_update_bits(spdif->regmap, SPDIF_CTRL,
+			SPDIF_TR_MODE, SPDIF_TR_MODE);
+
+		regmap_update_bits(spdif->regmap, SPDIF_CTRL,
+			SPDIF_MASK_FIFO, SPDIF_EMPTY_MASK | SPDIF_AEMPTY_MASK);
+	} else {
+		/* rx mode */
+		regmap_update_bits(spdif->regmap, SPDIF_CTRL,
+			SPDIF_TR_MODE, 0);
+
+		regmap_update_bits(spdif->regmap, SPDIF_CTRL,
+			SPDIF_MASK_FIFO, SPDIF_FULL_MASK | SPDIF_AFULL_MASK);
+	}
+
+	switch (cmd) {
+	case SNDRV_PCM_TRIGGER_START:
+	case SNDRV_PCM_TRIGGER_RESUME:
+	case SNDRV_PCM_TRIGGER_PAUSE_RELEASE:
+		/* clock recovery form the SPDIF data stream  0:clk_enable */
+		regmap_update_bits(spdif->regmap, SPDIF_CTRL,
+			SPDIF_CLK_ENABLE, 0);
+
+		regmap_update_bits(spdif->regmap, SPDIF_CTRL,
+			SPDIF_ENABLE, SPDIF_ENABLE);
+		break;
+	case SNDRV_PCM_TRIGGER_STOP:
+	case SNDRV_PCM_TRIGGER_SUSPEND:
+	case SNDRV_PCM_TRIGGER_PAUSE_PUSH:
+		/* clock recovery form the SPDIF data stream  1:power save mode */
+		regmap_update_bits(spdif->regmap, SPDIF_CTRL,
+			SPDIF_CLK_ENABLE, SPDIF_CLK_ENABLE);
+
+		regmap_update_bits(spdif->regmap, SPDIF_CTRL,
+			SPDIF_ENABLE, 0);
+		break;
+	default:
+		printk(KERN_ERR "%s L.%d cmd:%d\n", __func__, __LINE__, cmd);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int sf_spdif_hw_params(struct snd_pcm_substream *substream,
+	struct snd_pcm_hw_params *params, struct snd_soc_dai *dai)
+{
+	struct sf_spdif_dev *spdif = snd_soc_dai_get_drvdata(dai);
+	unsigned int channels;
+	unsigned int rate;
+	snd_pcm_format_t format;
+	unsigned int tsamplerate;
+
+	channels = params_channels(params);
+	rate = params_rate(params);
+	format = params_format(params);
+
+	switch (channels) {
+	case 2:
+		break;
+	default:
+		dev_err(dai->dev, "invalid channels number\n");
+		return -EINVAL;
+	}
+
+	switch (format) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+	case SNDRV_PCM_FORMAT_S24_LE:
+	case SNDRV_PCM_FORMAT_S32_LE:
+		break;
+	default:
+		dev_err(spdif->dev, "invalid format\n");
+		return -EINVAL;
+	}
+
+	switch (rate) {
+	case 8000:
+	case 11025:
+	case 16000:
+	case 22050:
+		break;
+	default:
+		printk(KERN_ERR "channel:%d sample rate:%d\n", channels, rate);
+		return -EINVAL;
+	}
+
+	/* 12288000/128=96000 */
+	tsamplerate = (96000 + rate/2)/rate - 1;
+
+	if (rate < 3) {
+		return -EINVAL;
+	}
+
+	/* transmission sample rate */
+	regmap_update_bits(spdif->regmap, SPDIF_CTRL, 0xFF, tsamplerate);
+
+	return 0;
+}
+
+static int sf_spdif_dai_probe(struct snd_soc_dai *dai)
+{
+	struct sf_spdif_dev *spdif = snd_soc_dai_get_drvdata(dai);
+
+	#if 0
+	spdif->play_dma_data.addr = (dma_addr_t)spdif->spdif_base + SPDIF_FIFO_ADDR;
+	spdif->play_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	spdif->play_dma_data.fifo_size = 16;
+	spdif->play_dma_data.maxburst = 16;
+	spdif->capture_dma_data.addr = (dma_addr_t)spdif->spdif_base + SPDIF_FIFO_ADDR;
+	spdif->capture_dma_data.addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+	spdif->capture_dma_data.fifo_size = 16;
+	spdif->capture_dma_data.maxburst = 16;
+	snd_soc_dai_init_dma_data(dai, &spdif->play_dma_data, &spdif->capture_dma_data);
+	snd_soc_dai_set_drvdata(dai, spdif);
+	#endif
+
+	/* reset */
+	regmap_update_bits(spdif->regmap, SPDIF_CTRL,
+		SPDIF_ENABLE | SPDIF_SFR_ENABLE | SPDIF_FIFO_ENABLE, 0);
+
+	/* clear irq */
+	regmap_update_bits(spdif->regmap, SPDIF_INT_REG,
+		SPDIF_INT_REG_BIT, 0);
+
+	/* power save mode */
+	regmap_update_bits(spdif->regmap, SPDIF_CTRL,
+		SPDIF_CLK_ENABLE, SPDIF_CLK_ENABLE);
+
+	/* power save mode */
+	regmap_update_bits(spdif->regmap, SPDIF_CTRL,
+		SPDIF_CLK_ENABLE, SPDIF_CLK_ENABLE);
+
+	regmap_update_bits(spdif->regmap, SPDIF_CTRL,
+		SPDIF_PARITCHECK|SPDIF_VALIDITYCHECK|SPDIF_DUPLICATE,
+		SPDIF_PARITCHECK|SPDIF_VALIDITYCHECK|SPDIF_DUPLICATE);
+
+	regmap_update_bits(spdif->regmap, SPDIF_CTRL,
+		SPDIF_SETPREAMBB, SPDIF_SETPREAMBB);
+
+	regmap_update_bits(spdif->regmap, SPDIF_INT_REG,
+		0x1FFF<<SPDIF_PREAMBLEDEL, 0x3<<SPDIF_PREAMBLEDEL);
+
+	regmap_update_bits(spdif->regmap, SPDIF_FIFO_CTRL,
+		0xFFFFFFFF, 0x20|(0x20<<SPDIF_AFULL_THRESHOLD));
+
+	regmap_update_bits(spdif->regmap, SPDIF_CTRL,
+		SPDIF_PARITYGEN, SPDIF_PARITYGEN);
+
+	regmap_update_bits(spdif->regmap, SPDIF_CTRL,
+		SPDIF_MASK_ENABLE, SPDIF_MASK_ENABLE);
+
+	/* APB access to FIFO enable, disable if use DMA/FIFO */
+	regmap_update_bits(spdif->regmap, SPDIF_CTRL,
+		SPDIF_USE_FIFO_IF, 0);
+
+	/* two channel */
+	regmap_update_bits(spdif->regmap, SPDIF_CTRL,
+		SPDIF_CHANNEL_MODE, 0);
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops sf_spdif_dai_ops = {
+	.probe = sf_spdif_dai_probe,
+	.trigger = sf_spdif_trigger,
+	.hw_params = sf_spdif_hw_params,
+};
+
+#define SF_PCM_RATE_44100_192000  (SNDRV_PCM_RATE_44100 | \
+									SNDRV_PCM_RATE_48000 | \
+									SNDRV_PCM_RATE_96000 | \
+									SNDRV_PCM_RATE_192000)
+
+#define SF_PCM_RATE_8000_22050  (SNDRV_PCM_RATE_8000 | \
+									SNDRV_PCM_RATE_11025 | \
+									SNDRV_PCM_RATE_16000 | \
+									SNDRV_PCM_RATE_22050)
+
+static struct snd_soc_dai_driver sf_spdif_dai = {
+	.name = "spdif",
+	.id = 0,
+	.playback = {
+		.stream_name = "Playback",
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = SF_PCM_RATE_8000_22050,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE \
+					|SNDRV_PCM_FMTBIT_S24_LE \
+					|SNDRV_PCM_FMTBIT_S32_LE,
+	},
+	.capture = {
+		.stream_name = "Capture",
+		.channels_min = 2,
+		.channels_max = 2,
+		.rates = SF_PCM_RATE_8000_22050,
+		.formats = SNDRV_PCM_FMTBIT_S16_LE \
+					|SNDRV_PCM_FMTBIT_S24_LE \
+					|SNDRV_PCM_FMTBIT_S32_LE,
+	},
+	.ops = &sf_spdif_dai_ops,
+	.symmetric_rate = 1,
+};
+
+static const struct snd_soc_component_driver sf_spdif_component = {
+	.name = "sf-spdif",
+};
+
+static const struct regmap_config sf_spdif_regmap_config = {
+	.reg_bits = 32,
+	.reg_stride = 4,
+	.val_bits = 32,
+	.max_register = 0x200,
+};
+
+static int sf_spdif_probe(struct platform_device *pdev)
+{
+	struct sf_spdif_dev *spdif;
+	struct resource *res;
+	void __iomem *base;
+	int ret;
+	int irq;
+
+	spdif = devm_kzalloc(&pdev->dev, sizeof(*spdif), GFP_KERNEL);
+	if (!spdif)
+		return -ENOMEM;
+
+	platform_set_drvdata(pdev, spdif);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	base = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(base))
+		return PTR_ERR(base);
+
+	spdif->spdif_base = base;
+	spdif->regmap = devm_regmap_init_mmio(&pdev->dev, spdif->spdif_base,
+					&sf_spdif_regmap_config);
+	if (IS_ERR(spdif->regmap))
+		return PTR_ERR(spdif->regmap);
+
+	spdif->dev = &pdev->dev;
+	spdif->fifo_th = 16;
+
+	irq = platform_get_irq(pdev, 0);
+	if (irq >= 0) {
+		ret = devm_request_irq(&pdev->dev, irq, spdif_irq_handler, 0,
+				pdev->name, spdif);
+		if (ret < 0) {
+			dev_err(&pdev->dev, "failed to request irq\n");
+			return ret;
+		}
+	}
+
+	ret = devm_snd_soc_register_component(&pdev->dev, &sf_spdif_component,
+					 &sf_spdif_dai, 1);
+	if (ret)
+		goto err_clk_disable;
+
+	if (irq >= 0) {
+		ret = sf_spdif_pcm_register(pdev);
+		spdif->use_pio = true;
+	} else {
+		ret = devm_snd_dmaengine_pcm_register(&pdev->dev, NULL,
+					0);
+		spdif->use_pio = false;
+	}
+
+	if (ret)
+		goto err_clk_disable;
+
+	return 0;
+
+err_clk_disable:
+	return ret;
+}
+
+static const struct of_device_id sf_spdif_of_match[] = {
+	{ .compatible = "starfive,sf-spdif", },
+	{},
+};
+MODULE_DEVICE_TABLE(of, sf_spdif_of_match);
+
+static struct platform_driver sf_spdif_driver = {
+	.driver = {
+		.name = "sf-spdif",
+		.of_match_table = sf_spdif_of_match,
+	},
+	.probe = sf_spdif_probe,
+};
+module_platform_driver(sf_spdif_driver);
+
+MODULE_AUTHOR("michael.yan <michael.yan@starfive.com>");
+MODULE_DESCRIPTION("starfive SPDIF driver");
+MODULE_LICENSE("GPL v2");
diff --git a/sound/soc/starfive/spdif.h b/sound/soc/starfive/spdif.h
new file mode 100644
index 0000000000..b9b856db70
--- /dev/null
+++ b/sound/soc/starfive/spdif.h
@@ -0,0 +1,154 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#ifndef __SND_SOC_STARFIVE_SPDIF_H
+#define __SND_SOC_STARFIVE_SPDIF_H
+
+#include <linux/clk.h>
+#include <linux/device.h>
+#include <linux/types.h>
+#include <sound/dmaengine_pcm.h>
+#include <sound/pcm.h>
+#include <linux/dmaengine.h>
+#include <linux/types.h>
+
+#define SPDIF_CTRL		(0x0)
+#define SPDIF_INT_REG		(0x4)
+#define SPDIF_FIFO_CTRL		(0x8)
+#define SPDIF_STAT_REG		(0xC)
+
+#define SPDIF_FIFO_ADDR		(0x100)
+#define DMAC_SPDIF_POLLING_LEN	(256)
+
+///ctrl: sampled on the rising clock edge
+#define SPDIF_TSAMPLERATE	0///[SRATEW-1:0]
+#define SPDIF_SFR_ENABLE	(1<<8)	///0:SFR reg reset to defualt value; auto set back to '1' after reset
+#define SPDIF_ENABLE		(1<<9)	///0:reset of SPDIF block, SRF bits are unchanged; 1:enables SPDIF module
+#define SPDIF_FIFO_ENABLE	(1<<10)	///0:FIFO pointers are reset to zero,threshold levels for FIFO are unchaned; auto set back to '1'
+#define SPDIF_CLK_ENABLE	(1<<11)	///1:blocked and the modules are in power save mode; 0:block feeds the modules
+#define SPDIF_TR_MODE		(1<<12)	///0:rx; 1:tx
+#define SPDIF_PARITCHECK	(1<<13)	///0:party bit rx in a sub-frame is repeated on the parity; 1:check on a parity error
+#define SPDIF_PARITYGEN		(1<<14)	///0:parity bit from FIFO is transmitted in sub-frame;1:parity bit generated inside the core and added to a transmitted sub-frame
+#define SPDIF_VALIDITYCHECK	(1<<15)	///0:validity bit in frame isn't checked and all frame are written; 1:validity bit rx is checked
+#define SPDIF_CHANNEL_MODE	(1<<16)	///0:two-channel; 1:single-channel
+#define SPDIF_DUPLICATE		(1<<17)	///only tx -single-channel mode; 0:secondary channel; 1: left(primary) channel
+#define SPDIF_SETPREAMBB	(1<<18)	///only tx; 0:first preamble B after reset tx valid sub-frame; 1:first preamble B is tx after preambleddel(INT_REG)
+#define SPDIF_USE_FIFO_IF	(1<<19)	///0:FIFO disabled ,APB accese FIFO; 1:FIFO enable, APB access to FIFO disable;
+///#define RESERVED		(1<<20)
+#define SPDIF_PARITY_MASK	(1<<21)
+#define SPDIF_UNDERR_MASK	(1<<22)
+#define SPDIF_OVRERR_MASK	(1<<23)
+#define SPDIF_EMPTY_MASK	(1<<24)
+#define SPDIF_AEMPTY_MASK	(1<<25)
+#define SPDIF_FULL_MASK		(1<<26)
+#define SPDIF_AFULL_MASK	(1<<27)
+#define SPDIF_SYNCERR_MASK	(1<<28)
+#define SPDIF_LOCK_MASK		(1<<29)
+#define SPDIF_BEGIN_MASK	(1<<30)
+#define SPDIF_INTEREQ_MAKS	(1<<31)
+
+#define SPDIF_MASK_ENABLE	(SPDIF_PARITY_MASK | SPDIF_UNDERR_MASK | SPDIF_OVRERR_MASK | SPDIF_EMPTY_MASK |	\
+							 SPDIF_AEMPTY_MASK | SPDIF_FULL_MASK | SPDIF_AFULL_MASK | SPDIF_SYNCERR_MASK |	\
+							 SPDIF_LOCK_MASK | SPDIF_BEGIN_MASK | SPDIF_INTEREQ_MAKS)
+
+#define SPDIF_MASK_FIFO		(SPDIF_EMPTY_MASK | SPDIF_AEMPTY_MASK | SPDIF_FULL_MASK | SPDIF_AFULL_MASK)
+
+////INT_REG
+#define SPDIF_RSAMPLERATE	0		///[SRATEW-1:0]
+#define SPDIF_PREAMBLEDEL	8		///[PDELAYW+7:8]	first B delay
+#define SPDIF_PARITYO		(1<<21)	///0:clear parity error
+#define SPDIF_TDATA_UNDERR	(1<<22)	///tx data underrun error;0:clear
+#define SPDIF_RDATA_OVRERR	(1<<23)	///rx data overrun error; 0:clear
+#define SPDIF_FIFO_EMPTY	(1<<24)	///empty; 0:clear
+#define SPDIF_FIOF_AEMPTY	(1<<25)	///almost empty; 0:clear
+#define SPDIF_FIFO_FULL		(1<<26)	///FIFO full; 0:clear
+#define SPDIF_FIFO_AFULL	(1<<27)	///FIFO almost full; 0:clear
+#define SPDIF_SYNCERR		(1<<28)	///sync error; 0:clear
+#define SPDIF_LOCK			(1<<29)	///sync; 0:clear
+#define SPDIF_BLOCK_BEGIN	(1<<30)	///new start block rx data
+
+#define SPDIF_INT_REG_BIT	(SPDIF_PARITYO | SPDIF_TDATA_UNDERR | SPDIF_RDATA_OVRERR | SPDIF_FIFO_EMPTY |	\
+							 SPDIF_FIOF_AEMPTY | SPDIF_FIFO_FULL | SPDIF_FIFO_AFULL | SPDIF_SYNCERR | 	\
+							 SPDIF_LOCK | SPDIF_BLOCK_BEGIN)
+
+#define SPDIF_ERROR_INT_STATUS	(SPDIF_PARITYO | SPDIF_TDATA_UNDERR | SPDIF_RDATA_OVRERR)
+#define SPDIF_FIFO_INT_STATUS	(SPDIF_FIFO_EMPTY | SPDIF_FIOF_AEMPTY | SPDIF_FIFO_FULL | SPDIF_FIFO_AFULL)
+
+#define SPDIF_INT_PARITY_ERROR	(-1)
+#define SPDIF_INT_TDATA_UNDERR	(-2)
+#define SPDIF_INT_RDATA_OVRERR	(-3)
+#define SPDIF_INT_FIFO_EMPTY	1
+#define SPDIF_INT_FIFO_AEMPTY	2
+#define SPDIF_INT_FIFO_FULL	3
+#define SPDIF_INT_FIFO_AFULL	4
+#define SPDIF_INT_SYNCERR	(-4)
+#define SPDIF_INT_LOCK		5	// reciever has become synchronized with input data stream
+#define SPDIF_INT_BLOCK_BEGIN	6	// start a new block in recieve data, written into FIFO
+
+///FIFO_CTRL
+#define SPDIF_AEMPTY_THRESHOLD	0	// [depth-1:0]
+#define SPDIF_AFULL_THRESHOLD	16	// [depth+15:16]
+
+///STAT_REG
+#define SPDIF_FIFO_LEVEL	(1<<0)
+#define SPDIF_PARITY_FLAG	(1<<21)	// 1:error; 0:repeated
+#define SPDIF_UNDERR_FLAG	(1<<22)	// 1:error
+#define SPDIF_OVRERR_FLAG	(1<<23)	// 1:error
+#define SPDIF_EMPTY_FLAG	(1<<24)	// 1:fifo empty
+#define SPDIF_AEMPTY_FLAG	(1<<25)	// 1:fifo almost empty
+#define SPDIF_FULL_FLAG		(1<<26)	// 1:fifo full
+#define SPDIF_AFULL_FLAG	(1<<27)	// 1:fifo almost full
+#define SPDIF_SYNCERR_FLAG	(1<<28)	// 1:rx sync error
+#define SPDIF_LOCK_FLAG		(1<<29)	// 1:RX sync
+#define SPDIF_BEGIN_FLAG	(1<<30)	// 1:start a new block
+#define SPDIF_RIGHT_LEFT	(1<<31)	// 1:left channel received and tx into FIFO; 0:right channel received and tx into FIFO
+
+#define SPDIF_STAT		(SPDIF_PARITY_FLAG | SPDIF_UNDERR_FLAG | SPDIF_OVRERR_FLAG | SPDIF_EMPTY_FLAG |		\
+						 SPDIF_AEMPTY_FLAG | SPDIF_FULL_FLAG | SPDIF_AFULL_FLAG | SPDIF_SYNCERR_FLAG | 		\
+						 SPDIF_LOCK_FLAG | SPDIF_BEGIN_FLAG | SPDIF_RIGHT_LEFT)
+struct sf_spdif_dev {
+	void __iomem *spdif_base;
+	struct regmap *regmap;
+	struct device *dev;
+	u32 fifo_th;
+	int active;
+
+	/* data related to DMA transfers b/w i2s and DMAC */
+	struct snd_dmaengine_dai_dma_data play_dma_data;
+	struct snd_dmaengine_dai_dma_data capture_dma_data;
+
+	bool use_pio;
+	struct snd_pcm_substream __rcu *tx_substream;
+	struct snd_pcm_substream __rcu *rx_substream;
+
+	unsigned int (*tx_fn)(struct sf_spdif_dev *dev,
+			struct snd_pcm_runtime *runtime, unsigned int tx_ptr,
+			bool *period_elapsed, snd_pcm_format_t format);
+	unsigned int (*rx_fn)(struct sf_spdif_dev *dev,
+			struct snd_pcm_runtime *runtime, unsigned int rx_ptr,
+			bool *period_elapsed, snd_pcm_format_t format);
+
+	snd_pcm_format_t format;
+	//unsigned int sample_bits;
+	unsigned int tx_ptr;
+	unsigned int rx_ptr;
+
+	struct snd_dmaengine_dai_dma_data dma_data;
+};
+
+#if IS_ENABLED(CONFIG_SND_STARFIVE_SPDIF_PCM)
+void sf_spdif_pcm_push_tx(struct sf_spdif_dev *dev);
+void sf_spdif_pcm_pop_rx(struct sf_spdif_dev *dev);
+int sf_spdif_pcm_register(struct platform_device *pdev);
+#else
+static inline void sf_spdif_pcm_push_tx(struct sf_spdif_dev *dev) { }
+static inline void sf_spdif_pcm_pop_rx(struct sf_spdif_dev *dev) { }
+static inline int sf_spdif_pcm_register(struct platform_device *pdev)
+{
+	return -EINVAL;
+}
+#endif
+
+
+#endif	/* __SND_SOC_STARFIVE_SPDIF_H */
-- 
2.49.0


From d69611c62f846399c273589784a2e9a3bb3b1524 Mon Sep 17 00:00:00 2001
From: "sw.multimedia" <sw.multimedia@starfivetech.com>
Date: Tue, 31 Aug 2021 16:48:57 +0800
Subject: [PATCH 27/31] drm/starfive: Add StarFive drm driver
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Add starfive DRM Display driver framework

Signed-off-by: jack.zhu <jack.zhu@starfivetech.com>
Signed-off-by: keith.zhao <keith.zhao@starfivetech.com>
Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
Signed-off-by: José Expósito <jose.exposito89@gmail.com>
Signed-off-by: Emil Renner Berthing <kernel@esmil.dk>
---
 drivers/cache/sifive_ccache.c                 |   6 +
 drivers/gpu/drm/Kconfig                       |   2 +
 drivers/gpu/drm/Makefile                      |   1 +
 drivers/gpu/drm/starfive/Kconfig              |  18 +
 drivers/gpu/drm/starfive/Makefile             |  13 +
 drivers/gpu/drm/starfive/README.txt           |  56 ++
 drivers/gpu/drm/starfive/starfive_drm_crtc.c  | 510 ++++++++++++
 drivers/gpu/drm/starfive/starfive_drm_crtc.h  |  86 ++
 drivers/gpu/drm/starfive/starfive_drm_drv.c   | 261 ++++++
 drivers/gpu/drm/starfive/starfive_drm_drv.h   |  25 +
 .../gpu/drm/starfive/starfive_drm_encoder.c   | 128 +++
 .../gpu/drm/starfive/starfive_drm_encoder.h   |  18 +
 drivers/gpu/drm/starfive/starfive_drm_gem.c   | 348 ++++++++
 drivers/gpu/drm/starfive/starfive_drm_gem.h   |  40 +
 drivers/gpu/drm/starfive/starfive_drm_lcdc.c  | 512 ++++++++++++
 drivers/gpu/drm/starfive/starfive_drm_lcdc.h  | 160 ++++
 drivers/gpu/drm/starfive/starfive_drm_plane.c | 227 ++++++
 drivers/gpu/drm/starfive/starfive_drm_plane.h |  12 +
 drivers/gpu/drm/starfive/starfive_drm_vpp.c   | 766 ++++++++++++++++++
 drivers/gpu/drm/starfive/starfive_drm_vpp.h   | 201 +++++
 include/soc/sifive/sifive_ccache.h            |   2 +
 21 files changed, 3392 insertions(+)
 create mode 100644 drivers/gpu/drm/starfive/Kconfig
 create mode 100644 drivers/gpu/drm/starfive/Makefile
 create mode 100644 drivers/gpu/drm/starfive/README.txt
 create mode 100644 drivers/gpu/drm/starfive/starfive_drm_crtc.c
 create mode 100644 drivers/gpu/drm/starfive/starfive_drm_crtc.h
 create mode 100644 drivers/gpu/drm/starfive/starfive_drm_drv.c
 create mode 100644 drivers/gpu/drm/starfive/starfive_drm_drv.h
 create mode 100644 drivers/gpu/drm/starfive/starfive_drm_encoder.c
 create mode 100644 drivers/gpu/drm/starfive/starfive_drm_encoder.h
 create mode 100644 drivers/gpu/drm/starfive/starfive_drm_gem.c
 create mode 100644 drivers/gpu/drm/starfive/starfive_drm_gem.h
 create mode 100644 drivers/gpu/drm/starfive/starfive_drm_lcdc.c
 create mode 100644 drivers/gpu/drm/starfive/starfive_drm_lcdc.h
 create mode 100644 drivers/gpu/drm/starfive/starfive_drm_plane.c
 create mode 100644 drivers/gpu/drm/starfive/starfive_drm_plane.h
 create mode 100644 drivers/gpu/drm/starfive/starfive_drm_vpp.c
 create mode 100644 drivers/gpu/drm/starfive/starfive_drm_vpp.h

diff --git a/drivers/cache/sifive_ccache.c b/drivers/cache/sifive_ccache.c
index 6874b72ec5..9a3bf329b0 100644
--- a/drivers/cache/sifive_ccache.c
+++ b/drivers/cache/sifive_ccache.c
@@ -161,6 +161,12 @@ static void ccache_flush_range(phys_addr_t start, size_t len)
 	}
 }
 
+void sifive_ccache_flush_range(phys_addr_t start, size_t len)
+{
+	ccache_flush_range(start, len);
+}
+EXPORT_SYMBOL_GPL(sifive_ccache_flush_range);
+
 static const struct riscv_nonstd_cache_ops ccache_mgmt_ops __initconst = {
 	.wback = &ccache_flush_range,
 	.inv = &ccache_flush_range,
diff --git a/drivers/gpu/drm/Kconfig b/drivers/gpu/drm/Kconfig
index fbef3f471b..65786e2638 100644
--- a/drivers/gpu/drm/Kconfig
+++ b/drivers/gpu/drm/Kconfig
@@ -375,6 +375,8 @@ source "drivers/gpu/drm/renesas/Kconfig"
 
 source "drivers/gpu/drm/sun4i/Kconfig"
 
+source "drivers/gpu/drm/starfive/Kconfig"
+
 source "drivers/gpu/drm/omapdrm/Kconfig"
 
 source "drivers/gpu/drm/tilcdc/Kconfig"
diff --git a/drivers/gpu/drm/Makefile b/drivers/gpu/drm/Makefile
index 19fb370fbc..da38ebf371 100644
--- a/drivers/gpu/drm/Makefile
+++ b/drivers/gpu/drm/Makefile
@@ -186,6 +186,7 @@ obj-$(CONFIG_DRM_ATMEL_HLCDC)	+= atmel-hlcdc/
 obj-y			+= renesas/
 obj-y			+= omapdrm/
 obj-$(CONFIG_DRM_SUN4I) += sun4i/
+obj-$(CONFIG_DRM_STARFIVE) += starfive/
 obj-y			+= tilcdc/
 obj-$(CONFIG_DRM_QXL) += qxl/
 obj-$(CONFIG_DRM_VIRTIO_GPU) += virtio/
diff --git a/drivers/gpu/drm/starfive/Kconfig b/drivers/gpu/drm/starfive/Kconfig
new file mode 100644
index 0000000000..62e2451565
--- /dev/null
+++ b/drivers/gpu/drm/starfive/Kconfig
@@ -0,0 +1,18 @@
+# SPDX-License-Identifier: GPL-2.0
+# Copyright (C) 2021 StarFive Technology Co., Ltd.
+
+config DRM_STARFIVE
+	tristate "DRM Support for StarFive SoCs"
+	depends on DRM
+	depends on SIFIVE_CCACHE && RISCV_NONSTANDARD_CACHE_OPS
+	depends on SOC_STARFIVE || COMPILE_TEST
+	select DRM_CLIENT_SELECTION
+	select DRM_GEM_DMA_HELPER
+	select DRM_KMS_HELPER
+	select DRM_MIPI_DSI
+	select DRM_PANEL
+	help
+	  Choose this option if you have a StarFive SoCs.
+	  The module will be called starfive-drm
+	  This driver provides kernel mode setting and
+	  buffer management to userspace.
diff --git a/drivers/gpu/drm/starfive/Makefile b/drivers/gpu/drm/starfive/Makefile
new file mode 100644
index 0000000000..8ef9e5f469
--- /dev/null
+++ b/drivers/gpu/drm/starfive/Makefile
@@ -0,0 +1,13 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Copyright (C) 2021 StarFive Technology Co., Ltd.
+#
+starfive-drm-y := starfive_drm_drv.o \
+		  starfive_drm_gem.o \
+		  starfive_drm_crtc.o \
+		  starfive_drm_encoder.o \
+		  starfive_drm_plane.o \
+		  starfive_drm_lcdc.o \
+		  starfive_drm_vpp.o
+
+obj-$(CONFIG_DRM_STARFIVE) += starfive-drm.o
diff --git a/drivers/gpu/drm/starfive/README.txt b/drivers/gpu/drm/starfive/README.txt
new file mode 100644
index 0000000000..dadec80c98
--- /dev/null
+++ b/drivers/gpu/drm/starfive/README.txt
@@ -0,0 +1,56 @@
+Display Subsystem:(default FBdev)
+
+Steps switch to DRM:
+1、Disable fbdev,close below config items：
+CONFIG_FB_STARFIVE=y
+CONFIG_FB_STARFIVE_HDMI_TDA998X=y
+CONFIG_FB_STARFIVE_VIDEO=y
+
+2、open DRM hdmi pipeline,enable items:
+CONFIG_DRM_I2C_NXP_TDA998X=y
+CONFIG_DRM_I2C_NXP_TDA9950=y
+CONFIG_DRM_STARFIVE=y
+CONFIG_FRAMEBUFFER_CONSOLE=y
+
+Precautions：when use DRM hdmi pipeline,please make sure CONFIG_DRM_STARFIVE_MIPI_DSI is disable ,
+			 or will cause color abnormal.
+
+3、open DRM mipi pipeline
+
+enable items:
+	CONFIG_PHY_M31_DPHY_RX0=y
+	CONFIG_DRM_STARFIVE_MIPI_DSI=y
+
+
+change jh7100.dtsi display-encoder as below：
+
+	display-encoder {
+		compatible = "starfive,display-encoder";
+		encoder-type = <6>; //2-TMDS, 3-LVDS, 6-DSI, 8-DPI
+		status = "okay";
+
+		ports {
+			port@0 {
+				endpoint {
+					remote-endpoint = <&dsi_out_port>;
+				};
+			};
+
+			port@1 {
+				endpoint {
+					remote-endpoint = <&crtc_0_out>;
+				};
+			};
+		};
+	};
+
+install libdrm:
+make buildroot_initramfs-menuconfig
+choose:
+BR2_PACKAGE_LIBDRM=y
+BR2_PACKAGE_LIBDRM_RADEON=y
+BR2_PACKAGE_LIBDRM_AMDGPU=y
+BR2_PACKAGE_LIBDRM_NOUVEAU=y
+BR2_PACKAGE_LIBDRM_ETNAVIV=y
+BR2_PACKAGE_LIBDRM_INSTALL_TESTS=y
+
diff --git a/drivers/gpu/drm/starfive/starfive_drm_crtc.c b/drivers/gpu/drm/starfive/starfive_drm_crtc.c
new file mode 100644
index 0000000000..dfea3c3575
--- /dev/null
+++ b/drivers/gpu/drm/starfive/starfive_drm_crtc.c
@@ -0,0 +1,510 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#include <linux/clk.h>
+#include <linux/component.h>
+#include <linux/platform_device.h>
+#include <linux/reset.h>
+#include <linux/delay.h>
+#include <drm/drm_atomic.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_atomic_uapi.h>
+#include <drm/drm_fb_dma_helper.h>
+#include <drm/drm_print.h>
+#include <drm/drm_probe_helper.h>
+#include <drm/drm_vblank.h>
+#include <drm/drm_gem_atomic_helper.h>
+#include "starfive_drm_drv.h"
+#include "starfive_drm_crtc.h"
+#include "starfive_drm_plane.h"
+#include "starfive_drm_lcdc.h"
+#include "starfive_drm_vpp.h"
+//#include <video/sys_comm_regs.h>
+
+static inline struct drm_encoder *
+starfive_head_atom_get_encoder(struct starfive_crtc *sf_crtc)
+{
+	struct drm_encoder *encoder = NULL;
+
+	/* We only ever have a single encoder */
+	drm_for_each_encoder_mask(encoder, sf_crtc->crtc.dev,
+				  sf_crtc->crtc.state->encoder_mask)
+		break;
+
+	return encoder;
+}
+
+static int ddrfmt_to_ppfmt(struct starfive_crtc *sf_crtc)
+{
+	int ddrfmt = sf_crtc->ddr_format;
+	int ret = 0;
+
+	sf_crtc->lcdcfmt = WIN_FMT_XRGB8888; //lcdc default used
+	sf_crtc->pp_conn_lcdc = 1;//default config
+	switch (ddrfmt) {
+	case DRM_FORMAT_UYVY:
+		sf_crtc->vpp_format = COLOR_YUV422_UYVY;
+		break;
+	case DRM_FORMAT_VYUY:
+		sf_crtc->vpp_format = COLOR_YUV422_VYUY;
+		break;
+	case DRM_FORMAT_YUYV:
+		sf_crtc->vpp_format = COLOR_YUV422_YUYV;
+		break;
+	case DRM_FORMAT_YVYU:
+		sf_crtc->vpp_format = COLOR_YUV422_YVYU;
+		break;
+	case DRM_FORMAT_YUV420:
+		sf_crtc->vpp_format = COLOR_YUV420P;
+		break;
+	case DRM_FORMAT_NV21:
+		sf_crtc->vpp_format = COLOR_YUV420_NV21;
+		break;
+	case DRM_FORMAT_NV12:
+		sf_crtc->vpp_format = COLOR_YUV420_NV12;
+		break;
+	case DRM_FORMAT_ARGB8888:
+		sf_crtc->vpp_format = COLOR_RGB888_ARGB;
+		break;
+	case DRM_FORMAT_ABGR8888:
+		sf_crtc->vpp_format = COLOR_RGB888_ABGR;
+		break;
+	case DRM_FORMAT_RGBA8888:
+		sf_crtc->vpp_format = COLOR_RGB888_RGBA;
+		break;
+	case DRM_FORMAT_BGRA8888:
+		sf_crtc->vpp_format = COLOR_RGB888_BGRA;
+		break;
+	case DRM_FORMAT_RGB565:
+		sf_crtc->vpp_format = COLOR_RGB565;
+		//sf_crtc->lcdcfmt = WIN_FMT_RGB565;
+		//this format no need pp, lcdc can direct read ddr buff
+		//sf_crtc->pp_conn_lcdc = -1;
+		break;
+	case DRM_FORMAT_XRGB1555:
+		sf_crtc->lcdcfmt = WIN_FMT_XRGB1555;
+		sf_crtc->pp_conn_lcdc = -1;//this format no need pp, lcdc can direct read ddr buff;
+		break;
+	case DRM_FORMAT_XRGB4444:
+		sf_crtc->lcdcfmt = WIN_FMT_XRGB4444;
+		sf_crtc->pp_conn_lcdc = -1;//this format no need pp, lcdc can direct read ddr buff;
+		break;
+
+	default:
+		ret = -1;
+		break;
+	}
+
+	return ret;
+}
+
+void starfive_crtc_hw_config_simple(struct starfive_crtc *starfive_crtc)
+{
+}
+
+static void starfive_crtc_destroy(struct drm_crtc *crtc)
+{
+	drm_crtc_cleanup(crtc);
+}
+
+static void starfive_crtc_destroy_state(struct drm_crtc *crtc,
+					struct drm_crtc_state *state)
+{
+	struct starfive_crtc_state *s = to_starfive_crtc_state(state);
+
+	__drm_atomic_helper_crtc_destroy_state(&s->base);
+	kfree(s);
+}
+
+static void starfive_crtc_reset(struct drm_crtc *crtc)
+{
+	struct starfive_crtc_state *crtc_state =
+	kzalloc(sizeof(*crtc_state), GFP_KERNEL);
+
+	if (crtc->state)
+		starfive_crtc_destroy_state(crtc, crtc->state);
+
+	__drm_atomic_helper_crtc_reset(crtc, &crtc_state->base);
+}
+
+static struct drm_crtc_state *starfive_crtc_duplicate_state(struct drm_crtc *crtc)
+{
+	struct starfive_crtc_state *starfive_state;
+
+	starfive_state = kzalloc(sizeof(*starfive_state), GFP_KERNEL);
+	if (!starfive_state)
+		return NULL;
+
+	__drm_atomic_helper_crtc_duplicate_state(crtc, &starfive_state->base);
+
+	return &starfive_state->base;
+}
+
+static int starfive_crtc_enable_vblank(struct drm_crtc *crtc)
+{
+	//need set hw
+	return 0;
+}
+
+static void starfive_crtc_disable_vblank(struct drm_crtc *crtc)
+{
+	//need set hw
+}
+
+static const struct drm_crtc_funcs starfive_crtc_funcs = {
+	.set_config = drm_atomic_helper_set_config,
+	.page_flip = drm_atomic_helper_page_flip,
+	.destroy = starfive_crtc_destroy,
+	.set_property = NULL,
+	.cursor_set = NULL, /* handled by drm_mode_cursor_universal */
+	.cursor_move = NULL, /* handled by drm_mode_cursor_universal */
+	.reset = starfive_crtc_reset,
+	.atomic_duplicate_state = starfive_crtc_duplicate_state,
+	.atomic_destroy_state = starfive_crtc_destroy_state,
+	//.gamma_set = drm_atomic_helper_legacy_gamma_set,
+	.enable_vblank = starfive_crtc_enable_vblank,
+	.disable_vblank = starfive_crtc_disable_vblank,
+	//.set_crc_source = starfive_crtc_set_crc_source,
+	//.get_vblank_timestamp = drm_crtc_vblank_helper_get_vblank_timestamp,
+	//.verify_crc_source = starfive_crtc_verify_crc_source,
+};
+
+static bool starfive_crtc_mode_fixup(struct drm_crtc *crtc,
+				     const struct drm_display_mode *mode,
+				     struct drm_display_mode *adjusted_mode)
+{
+	/* Nothing to do here, but this callback is mandatory. */
+	return true;
+}
+
+static int starfive_crtc_atomic_check(struct drm_crtc *crtc,
+				      struct drm_atomic_state *state)
+{
+	//state->no_vblank = true;	// hardware without VBLANK interrupt ???
+	struct drm_crtc_state *crtc_state = drm_atomic_get_new_crtc_state(state,
+										crtc);
+	crtc_state->no_vblank = true;
+
+	return 0;
+}
+
+static void starfive_crtc_atomic_begin(struct drm_crtc *crtc,
+				       struct drm_atomic_state *old_crtc_state)
+{
+	//starfive_crtc_gamma_set(crtcp, crtc, old_crtc_state);
+}
+
+static void starfive_crtc_atomic_flush(struct drm_crtc *crtc,
+				       struct drm_atomic_state *old_crtc_state)
+{
+	struct starfive_crtc *crtcp = to_starfive_crtc(crtc);
+
+	//starfive_flush_dcache(crtcp->dma_addr, 1920*1080*2);
+	DRM_DEBUG_DRIVER("ddr_format_change [%d], dma_addr_change [%d]\n",
+			 crtcp->ddr_format_change, crtcp->dma_addr_change);
+	if (crtcp->ddr_format_change || crtcp->dma_addr_change) {
+		ddrfmt_to_ppfmt(crtcp);
+		starfive_pp_update(crtcp);
+	} else {
+		DRM_DEBUG_DRIVER("%s with no change\n", __func__);
+	}
+}
+
+static void starfive_crtc_atomic_enable(struct drm_crtc *crtc,
+					struct drm_atomic_state *state)
+{
+	struct starfive_crtc *crtcp = to_starfive_crtc(crtc);
+
+// enable crtc HW
+#ifdef CONFIG_DRM_STARFIVE_MIPI_DSI
+	dsitx_vout_init(crtcp);
+	lcdc_dsi_sel(crtcp);
+#else
+	vout_reset(crtcp);
+#endif
+	ddrfmt_to_ppfmt(crtcp);
+	starfive_pp_enable(crtcp);
+	starfive_lcdc_enable(crtcp);
+	crtcp->is_enabled = true;  // should before
+}
+
+static void starfive_crtc_atomic_disable(struct drm_crtc *crtc,
+					 struct drm_atomic_state *state)
+{
+	struct starfive_crtc *crtcp = to_starfive_crtc(crtc);
+	int pp_id;
+
+	for (pp_id = 0; pp_id < PP_NUM; pp_id++) {
+		if (crtcp->pp[pp_id].inited == 1) {
+			pp_disable_intr(crtcp, pp_id);
+			vout_disable(crtcp); // disable crtc HW
+		}
+	}
+	crtcp->is_enabled = false;
+}
+
+static enum drm_mode_status starfive_crtc_mode_valid(struct drm_crtc *crtc,
+						     const struct drm_display_mode *mode)
+{
+	int refresh = drm_mode_vrefresh(mode);
+
+	if (refresh > 60) //lcdc miss support 60+ fps
+		return MODE_BAD;
+	else
+		return MODE_OK;
+}
+
+static const struct drm_crtc_helper_funcs starfive_crtc_helper_funcs = {
+	.mode_fixup = starfive_crtc_mode_fixup,
+	.atomic_check = starfive_crtc_atomic_check,
+	.atomic_begin = starfive_crtc_atomic_begin,
+	.atomic_flush = starfive_crtc_atomic_flush,
+	.atomic_enable = starfive_crtc_atomic_enable,
+	.atomic_disable = starfive_crtc_atomic_disable,
+	.mode_valid = starfive_crtc_mode_valid,
+};
+
+static int starfive_crtc_create(struct drm_device *drm_dev,
+				struct starfive_crtc *starfive_crtc,
+				const struct drm_crtc_funcs *crtc_funcs,
+				const struct drm_crtc_helper_funcs *crtc_helper_funcs)
+{
+	struct drm_crtc *crtc = &starfive_crtc->crtc;
+	struct device *dev = drm_dev->dev;
+	struct device_node *port;
+	int ret;
+
+	starfive_crtc->planes = devm_kzalloc(dev, sizeof(struct drm_plane), GFP_KERNEL);
+	ret = starfive_plane_init(drm_dev, starfive_crtc, DRM_PLANE_TYPE_PRIMARY);
+	if (ret) {
+		dev_err(drm_dev->dev, "failed to construct primary plane\n");
+		return ret;
+	}
+
+	drm_crtc_init_with_planes(drm_dev, crtc, starfive_crtc->planes, NULL,
+				  crtc_funcs, NULL);
+	drm_crtc_helper_add(crtc, crtc_helper_funcs);
+	port = of_get_child_by_name(starfive_crtc->dev->of_node, "port");
+	if (!port) {
+		DRM_ERROR("no port node found in %s\n", dev->of_node->full_name);
+		ret = -ENOENT;
+	}
+
+	crtc->port = port;
+	return ret;
+}
+
+static int starfive_crtc_get_memres(struct platform_device *pdev, struct starfive_crtc *sf_crtc)
+{
+	static const char *const mem_res_name[] = {
+		"lcdc", "vpp0", "vpp1", "vpp2", "clk", "rst", "sys"
+	};
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(mem_res_name); i++) {
+		const char *name = mem_res_name[i];
+		void __iomem *regs = devm_platform_ioremap_resource_byname(pdev, name);
+
+		if (IS_ERR(regs))
+			return PTR_ERR(regs);
+
+		if (!strcmp(name, "lcdc"))
+			sf_crtc->base_lcdc = regs;
+		else if (!strcmp(name, "vpp0"))
+			sf_crtc->base_vpp0 = regs;
+		else if (!strcmp(name, "vpp1"))
+			sf_crtc->base_vpp1 = regs;
+		else if (!strcmp(name, "vpp2"))
+			sf_crtc->base_vpp2 = regs;
+		else if (!strcmp(name, "clk"))
+			sf_crtc->base_clk = regs;
+		else if (!strcmp(name, "rst"))
+			sf_crtc->base_rst = regs;
+		else if (!strcmp(name, "sys"))
+			sf_crtc->base_syscfg = regs;
+		else
+			dev_err(&pdev->dev, "Could not match resource name\n");
+	}
+
+	return 0;
+}
+
+static int starfive_parse_dt(struct device *dev, struct starfive_crtc *sf_crtc)
+{
+	int ret;
+	struct device_node *np = dev->of_node;
+	struct device_node *child;
+	int pp_num = 0;
+
+	if (!np)
+		return -EINVAL;
+
+	sf_crtc->pp = devm_kzalloc(dev, sizeof(struct pp_mode) * PP_NUM, GFP_KERNEL);
+	if (!sf_crtc->pp)
+		return -ENOMEM;
+
+	for_each_child_of_node(np, child) {
+		if (of_property_read_u32(child, "pp-id", &pp_num)) {
+			ret = -EINVAL;
+			continue;
+		}
+		if (pp_num >= PP_NUM)
+			dev_err(dev, " pp-id number %d is not support!\n", pp_num);
+
+		sf_crtc->pp[pp_num].pp_id = pp_num;
+		sf_crtc->pp[pp_num].bus_out = of_property_read_bool(child, "sys-bus-out");
+		sf_crtc->pp[pp_num].fifo_out = of_property_read_bool(child, "fifo-out");
+		if (of_property_read_u32(child, "src-format", &sf_crtc->pp[pp_num].src.format)) {
+			dev_err(dev, "Missing src-format property in the DT.\n");
+			ret = -EINVAL;
+		}
+		if (of_property_read_u32(child, "src-width", &sf_crtc->pp[pp_num].src.width)) {
+			dev_err(dev, "Missing src-width property in the DT. w %d\n",
+				sf_crtc->pp[pp_num].src.width);
+			ret = -EINVAL;
+		}
+		if (of_property_read_u32(child, "src-height", &sf_crtc->pp[pp_num].src.height)) {
+			dev_err(dev, "Missing src-height property in the DT.\n");
+			ret = -EINVAL;
+		}
+		if (of_property_read_u32(child, "dst-format", &sf_crtc->pp[pp_num].dst.format)) {
+			dev_err(dev, "Missing dst-format property in the DT.\n");
+			ret = -EINVAL;
+		}
+		if (of_property_read_u32(child, "dst-width", &sf_crtc->pp[pp_num].dst.width)) {
+			dev_err(dev, "Missing dst-width property in the DT.\n");
+			ret = -EINVAL;
+		}
+		if (of_property_read_u32(child, "dst-height", &sf_crtc->pp[pp_num].dst.height)) {
+			dev_err(dev, "Missing dst-height property in the DT.\n");
+			ret = -EINVAL;
+		}
+		sf_crtc->pp[pp_num].inited = 1;
+	}
+
+	return ret;
+}
+
+static int starfive_crtc_bind(struct device *dev, struct device *master, void *data)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct drm_device *drm_dev = data;
+	struct starfive_crtc *crtcp;
+	int ret;
+
+	crtcp = devm_kzalloc(dev, sizeof(*crtcp), GFP_KERNEL);
+	if (!crtcp)
+		return -ENOMEM;
+
+	crtcp->dev = dev;
+	crtcp->drm_dev = drm_dev;
+	dev_set_drvdata(dev, crtcp);
+
+	spin_lock_init(&crtcp->reg_lock);
+
+	ret = starfive_crtc_get_memres(pdev, crtcp);
+	if (ret)
+		return ret;
+
+	crtcp->clk_disp_axi = devm_clk_get(dev, "disp_axi");
+	if (IS_ERR(crtcp->clk_disp_axi))
+		return dev_err_probe(dev, PTR_ERR(crtcp->clk_disp_axi),
+				     "error getting axi clock\n");
+
+	crtcp->clk_vout_src = devm_clk_get(dev, "disp_axi");
+	if (IS_ERR(crtcp->clk_vout_src))
+		return dev_err_probe(dev, PTR_ERR(crtcp->clk_vout_src),
+				     "error getting vout clock\n");
+
+	crtcp->rst_disp_axi = devm_reset_control_get_exclusive(dev, "disp_axi");
+	if (IS_ERR(crtcp->rst_disp_axi))
+		return dev_err_probe(dev, PTR_ERR(crtcp->rst_disp_axi),
+				     "error getting axi reset\n");
+
+	crtcp->rst_vout_src = devm_reset_control_get_exclusive(dev, "vout_src");
+	if (IS_ERR(crtcp->rst_vout_src))
+		return dev_err_probe(dev, PTR_ERR(crtcp->rst_vout_src),
+				     "error getting vout reset\n");
+
+	ret = starfive_parse_dt(dev, crtcp);
+
+	crtcp->pp_conn_lcdc = starfive_pp_get_2lcdc_id(crtcp);
+
+	crtcp->lcdc_irq = platform_get_irq_byname(pdev, "lcdc_irq");
+	if (crtcp->lcdc_irq < 0)
+		return dev_err_probe(dev, crtcp->lcdc_irq, "error getting lcdc irq\n");
+
+	crtcp->vpp1_irq = platform_get_irq_byname(pdev, "vpp1_irq");
+	if (crtcp->vpp1_irq < 0)
+		return dev_err_probe(dev, crtcp->vpp1_irq, "error getting vpp1 irq\n");
+
+	ret = devm_request_irq(&pdev->dev, crtcp->lcdc_irq, lcdc_isr_handler, 0,
+			       "sf_lcdc", crtcp);
+	if (ret)
+		return dev_err_probe(dev, ret, "error requesting irq %d\n", crtcp->lcdc_irq);
+
+	ret = devm_request_irq(&pdev->dev, crtcp->vpp1_irq, vpp1_isr_handler, 0,
+			       "sf_vpp1", crtcp);
+	if (ret)
+		return dev_err_probe(dev, ret, "error requesting irq %d\n", crtcp->vpp1_irq);
+
+	ret = starfive_crtc_create(drm_dev, crtcp,
+				   &starfive_crtc_funcs,
+				   &starfive_crtc_helper_funcs);
+	if (ret)
+		return ret;
+
+	crtcp->is_enabled = false;
+
+	/* starfive_set_crtc_possible_masks(drm_dev, crtcp); */
+
+	/*
+	ret = drm_self_refresh_helper_init(crtcp);
+	if (ret)
+		DRM_DEV_DEBUG_KMS(crtcp->dev,
+			"Failed to init %s with SR helpers %d, ignoring\n",
+			crtcp->name, ret);
+	*/
+
+	return 0;
+}
+
+static void starfive_crtc_unbind(struct device *dev, struct device *master, void *data)
+{
+	struct platform_device *pdev = to_platform_device(dev);
+	struct starfive_crtc *crtcp = dev_get_drvdata(dev);
+
+	drm_crtc_cleanup(&crtcp->crtc);
+	platform_set_drvdata(pdev, NULL);
+}
+
+static const struct component_ops starfive_crtc_component_ops = {
+	.bind   = starfive_crtc_bind,
+	.unbind = starfive_crtc_unbind,
+};
+
+static const struct of_device_id starfive_crtc_driver_dt_match[] = {
+	{ .compatible = "starfive,jh7100-crtc" },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, starfive_crtc_driver_dt_match);
+
+static int starfive_crtc_probe(struct platform_device *pdev)
+{
+	return component_add(&pdev->dev, &starfive_crtc_component_ops);
+}
+
+static void starfive_crtc_remove(struct platform_device *pdev)
+{
+	component_del(&pdev->dev, &starfive_crtc_component_ops);
+}
+
+struct platform_driver starfive_crtc_driver = {
+	.probe = starfive_crtc_probe,
+	.remove = starfive_crtc_remove,
+	.driver = {
+		.name = "starfive-crtc",
+		.of_match_table = of_match_ptr(starfive_crtc_driver_dt_match),
+	},
+};
diff --git a/drivers/gpu/drm/starfive/starfive_drm_crtc.h b/drivers/gpu/drm/starfive/starfive_drm_crtc.h
new file mode 100644
index 0000000000..b04706ae82
--- /dev/null
+++ b/drivers/gpu/drm/starfive/starfive_drm_crtc.h
@@ -0,0 +1,86 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#ifndef _STARFIVE_DRM_CRTC_H
+#define _STARFIVE_DRM_CRTC_H
+#include <drm/drm_crtc.h>
+
+enum COLOR_FORMAT {
+	COLOR_YUV422_UYVY = 0,  //00={Y1,V0,Y0,U0}
+	COLOR_YUV422_VYUY = 1,  //01={Y1,U0,Y0,V0}
+	COLOR_YUV422_YUYV = 2,  //10={V0,Y1,U0,Y0}
+	COLOR_YUV422_YVYU = 3,  //11={U0,Y1,V0,Y0}
+
+	COLOR_YUV420P,
+	COLOR_YUV420_NV21,
+	COLOR_YUV420_NV12,
+
+	COLOR_RGB888_ARGB,
+	COLOR_RGB888_ABGR,
+	COLOR_RGB888_RGBA,
+	COLOR_RGB888_BGRA,
+	COLOR_RGB565,
+};
+
+struct starfive_crtc_state {
+	struct drm_crtc_state base;
+};
+
+#define to_starfive_crtc_state(s) \
+		container_of(s, struct starfive_crtc_state, base)
+
+struct starfive_crtc {
+	struct drm_crtc		crtc;
+	struct device		*dev;
+	struct drm_device	*drm_dev;
+	bool is_enabled;
+
+	void __iomem	*base_clk;	// 0x12240000
+	void __iomem	*base_rst;	// 0x12250000
+	void __iomem	*base_syscfg;	// 0x12260000
+	void __iomem	*base_vpp0;	// 0x12040000
+	void __iomem	*base_vpp1;	// 0x12080000
+	void __iomem	*base_vpp2;	// 0x120c0000
+	void __iomem	*base_lcdc;	// 0x12000000
+
+	struct clk *clk_disp_axi;
+	struct clk *clk_vout_src;
+
+	struct reset_control *rst_disp_axi;
+	struct reset_control *rst_vout_src;
+
+	int		lcdc_irq;
+	int		vpp0_irq;
+	int		vpp1_irq;
+	int		vpp2_irq;
+
+	struct pp_mode	*pp;
+
+	int		win_num;
+	int		pp_conn_lcdc;
+	unsigned int	ddr_format;
+	bool		ddr_format_change;
+	enum		COLOR_FORMAT vpp_format;
+	int		lcdcfmt;
+
+	/* one time only one process allowed to config the register */
+	spinlock_t	reg_lock;
+
+	struct drm_plane	*planes;
+
+	u8		lut_r[256];
+	u8		lut_g[256];
+	u8		lut_b[256];
+
+	bool		gamma_lut;
+	dma_addr_t	dma_addr;
+	bool		dma_addr_change;
+	size_t		size;
+};
+
+#define to_starfive_crtc(x) container_of(x, struct starfive_crtc, crtc)
+
+void starfive_crtc_hw_config_simple(struct starfive_crtc *starfive_crtc);
+
+#endif /* _STARFIVE_DRM_CRTC_H */
diff --git a/drivers/gpu/drm/starfive/starfive_drm_drv.c b/drivers/gpu/drm/starfive/starfive_drm_drv.c
new file mode 100644
index 0000000000..94ecbdc287
--- /dev/null
+++ b/drivers/gpu/drm/starfive/starfive_drm_drv.c
@@ -0,0 +1,261 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#include <linux/component.h>
+#include <linux/iommu.h>
+#include <linux/module.h>
+#include <linux/of_address.h>
+#include <linux/of_platform.h>
+#include <linux/pm_runtime.h>
+#include <linux/soc/mediatek/mtk-mmsys.h>
+#include <linux/dma-mapping.h>
+#include <drm/clients/drm_client_setup.h>
+#include <drm/drm_atomic.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_drv.h>
+#include <drm/drm_fbdev_dma.h>
+#include <drm/drm_fourcc.h>
+#include <drm/drm_gem.h>
+#include <drm/drm_gem_dma_helper.h>
+#include <drm/drm_gem_framebuffer_helper.h>
+#include <drm/drm_of.h>
+#include <drm/drm_probe_helper.h>
+#include <drm/drm_vblank.h>
+#include "starfive_drm_drv.h"
+#include "starfive_drm_gem.h"
+
+#define DRIVER_NAME	"starfive"
+#define DRIVER_DESC	"starfive Soc DRM"
+#define DRIVER_MAJOR	1
+#define DRIVER_MINOR	0
+
+static struct drm_framebuffer *
+starfive_drm_mode_fb_create(struct drm_device *dev, struct drm_file *file,
+			    const struct drm_mode_fb_cmd2 *mode_cmd)
+{
+	return drm_gem_fb_create(dev, file, mode_cmd);
+}
+
+static const struct drm_mode_config_funcs starfive_drm_mode_config_funcs = {
+	.fb_create = starfive_drm_mode_fb_create,
+	.atomic_check = drm_atomic_helper_check,
+	.atomic_commit = drm_atomic_helper_commit,
+};
+
+static const struct drm_mode_config_helper_funcs starfive_drm_mode_config_helpers = {
+	.atomic_commit_tail = drm_atomic_helper_commit_tail_rpm,
+};
+
+static const struct file_operations starfive_drm_driver_fops = {
+	.owner = THIS_MODULE,
+	.open = drm_open,
+	.mmap = starfive_drm_gem_mmap,
+	.poll = drm_poll,
+	.read = drm_read,
+	.unlocked_ioctl = drm_ioctl,
+	.compat_ioctl = drm_compat_ioctl,
+	.release = drm_release,
+};
+
+static struct drm_driver starfive_drm_driver = {
+	.driver_features = DRIVER_MODESET | DRIVER_GEM | DRIVER_ATOMIC,
+	DRM_GEM_DMA_DRIVER_OPS_WITH_DUMB_CREATE(starfive_drm_gem_dumb_create),
+	DRM_FBDEV_DMA_DRIVER_OPS,
+	.gem_prime_import_sg_table = starfive_drm_gem_prime_import_sg_table,
+	.fops = &starfive_drm_driver_fops,
+	.name = DRIVER_NAME,
+	.desc = DRIVER_DESC,
+	.major = DRIVER_MAJOR,
+	.minor = DRIVER_MINOR,
+};
+
+static int compare_dev(struct device *dev, void *data)
+{
+	return dev == (struct device *)data;
+}
+
+static void starfive_drm_match_add(struct device *dev,
+				   struct component_match **match,
+				   struct platform_driver *const *drivers,
+				   int count)
+{
+	int i;
+
+	for (i = 0; i < count; i++) {
+		struct device_driver *drv = &drivers[i]->driver;
+		struct device *p = NULL, *d;
+
+		while ((d = platform_find_device_by_driver(p, drv))) {
+			put_device(p);
+			component_match_add(dev, match, compare_dev, d);
+			p = d;
+		}
+		put_device(p);
+	}
+}
+
+static void starfive_cleanup(struct drm_device *ddev)
+{
+	struct starfive_drm_private *private = ddev->dev_private;
+
+	drm_kms_helper_poll_fini(ddev);
+	drm_atomic_helper_shutdown(ddev);
+	drm_mode_config_cleanup(ddev);
+	component_unbind_all(ddev->dev, ddev);
+	kfree(private);
+	ddev->dev_private = NULL;
+}
+
+static int starfive_drm_bind(struct device *dev)
+{
+	struct drm_device *drm_dev;
+	struct starfive_drm_private *private;
+	int ret;
+
+	drm_dev = drm_dev_alloc(&starfive_drm_driver, dev);
+	if (IS_ERR(drm_dev))
+		return PTR_ERR(drm_dev);
+
+	dev_set_drvdata(dev, drm_dev);
+
+	private = devm_kzalloc(drm_dev->dev, sizeof(*private), GFP_KERNEL);
+	if (!private) {
+		ret = -ENOMEM;
+		goto err_free;
+	}
+
+	drm_dev->dev_private = private;
+
+	/*
+	ret = starfive_drm_init_iommu(drm_dev);
+	if (ret)
+		goto err_free;
+	*/
+
+	ret = drmm_mode_config_init(drm_dev);
+	if (ret)
+		goto err_free;
+
+	drm_dev->mode_config.min_width = 64;
+	drm_dev->mode_config.min_height = 64;
+
+	/*
+	 * set max width and height as default value(4096x4096).
+	 * this value would be used to check framebuffer size limitation
+	 * at drm_mode_addfb().
+	 */
+	drm_dev->mode_config.max_width = 4096;
+	drm_dev->mode_config.max_height = 4096;
+	drm_dev->mode_config.funcs = &starfive_drm_mode_config_funcs;
+	drm_dev->mode_config.helper_private = &starfive_drm_mode_config_helpers;
+	drm_dev->mode_config.async_page_flip = 1;
+
+	ret = component_bind_all(dev, drm_dev);
+	if (ret)
+		goto err_free;
+
+	ret = drm_vblank_init(drm_dev, drm_dev->mode_config.num_crtc);
+	if (ret)
+		goto err_cleanup;
+
+	drm_mode_config_reset(drm_dev);
+
+	/* init kms poll for handling hpd */
+	drm_kms_helper_poll_init(drm_dev);
+
+	ret = drm_dev_register(drm_dev, 0);
+	if (ret)
+		goto err_cleanup;
+#ifdef CONFIG_FRAMEBUFFER_CONSOLE
+	drm_client_setup_with_fourcc(drm_dev, DRM_FORMAT_RGB565);
+#endif
+	return 0;
+
+err_cleanup:
+	starfive_cleanup(drm_dev);
+err_free:
+	drm_dev_put(drm_dev);
+	return ret;
+}
+
+static void starfive_drm_unbind(struct device *dev)
+{
+	struct drm_device *drm_dev = dev_get_drvdata(dev);
+
+	drm_dev_unregister(drm_dev);
+}
+
+static const struct component_master_ops starfive_drm_ops = {
+	.bind = starfive_drm_bind,
+	.unbind = starfive_drm_unbind,
+};
+
+static struct platform_driver * const starfive_component_drivers[] = {
+	&starfive_crtc_driver,
+#ifdef CONFIG_DRM_STARFIVE_MIPI_DSI
+	&starfive_dsi_platform_driver,
+#endif
+	&starfive_encoder_driver,
+};
+
+static int starfive_drm_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct component_match *match = NULL;
+
+	starfive_drm_match_add(dev, &match,
+			       starfive_component_drivers,
+			       ARRAY_SIZE(starfive_component_drivers));
+	if (IS_ERR(match))
+		return PTR_ERR(match);
+
+	return component_master_add_with_match(dev, &starfive_drm_ops, match);
+}
+
+static void starfive_drm_remove(struct platform_device *pdev)
+{
+	component_master_del(&pdev->dev, &starfive_drm_ops);
+}
+
+static const struct of_device_id starfive_drm_dt_ids[] = {
+	{ .compatible = "starfive,display-subsystem" },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, starfive_drm_dt_ids);
+
+static struct platform_driver starfive_drm_platform_driver = {
+	.probe	= starfive_drm_probe,
+	.remove = starfive_drm_remove,
+	.driver	= {
+		.name		= "starfive-drm",
+		.of_match_table	= starfive_drm_dt_ids,
+		//.pm     = &starfive_drm_pm_ops,
+	},
+};
+
+static int __init starfive_drm_init(void)
+{
+	int ret;
+
+	ret = platform_register_drivers(starfive_component_drivers,
+					ARRAY_SIZE(starfive_component_drivers));
+	if (ret)
+		return ret;
+
+	return platform_driver_register(&starfive_drm_platform_driver);
+}
+
+static void __exit starfive_drm_exit(void)
+{
+	platform_unregister_drivers(starfive_component_drivers,
+				    ARRAY_SIZE(starfive_component_drivers));
+	platform_driver_unregister(&starfive_drm_platform_driver);
+}
+
+module_init(starfive_drm_init);
+module_exit(starfive_drm_exit);
+
+MODULE_AUTHOR("StarFive <StarFive@starfivetech.com>");
+MODULE_DESCRIPTION("StarFive SoC DRM driver");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/gpu/drm/starfive/starfive_drm_drv.h b/drivers/gpu/drm/starfive/starfive_drm_drv.h
new file mode 100644
index 0000000000..b965fa5f72
--- /dev/null
+++ b/drivers/gpu/drm/starfive/starfive_drm_drv.h
@@ -0,0 +1,25 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#ifndef _STARFIVE_DRM_DRV_H
+#define _STARFIVE_DRM_DRV_H
+
+#include <drm/drm_fb_helper.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_gem.h>
+#include <linux/module.h>
+#include <linux/component.h>
+
+struct starfive_drm_private {
+	struct drm_fb_helper fbdev_helper;
+	struct drm_gem_object *fbdev_bo;
+	struct mutex mm_lock;
+	struct drm_mm mm;
+};
+
+extern struct platform_driver starfive_crtc_driver;
+extern struct platform_driver starfive_encoder_driver;
+extern struct platform_driver starfive_dsi_platform_driver;
+
+#endif /* _STARFIVE_DRM_DRV_H_ */
diff --git a/drivers/gpu/drm/starfive/starfive_drm_encoder.c b/drivers/gpu/drm/starfive/starfive_drm_encoder.c
new file mode 100644
index 0000000000..0bd5f752fb
--- /dev/null
+++ b/drivers/gpu/drm/starfive/starfive_drm_encoder.c
@@ -0,0 +1,128 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#include <linux/clk.h>
+#include <linux/component.h>
+#include <linux/platform_device.h>
+#include <drm/drm_atomic.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_atomic_uapi.h>
+#include <drm/drm_fb_dma_helper.h>
+#include <drm/drm_print.h>
+#include <drm/drm_probe_helper.h>
+#include <drm/drm_vblank.h>
+#include <drm/drm_of.h>
+#include "starfive_drm_drv.h"
+#include "starfive_drm_encoder.h"
+
+static void starfive_encoder_destroy(struct drm_encoder *encoder)
+{
+	drm_encoder_cleanup(encoder);
+	kfree(encoder);
+}
+
+static const struct drm_encoder_funcs starfive_encoder_funcs = {
+	.destroy = starfive_encoder_destroy,
+};
+
+static int starfive_encoder_bind(struct device *dev, struct device *master, void *data)
+{
+	struct drm_device *drm_dev = data;
+	struct device_node *np = dev->of_node;
+	struct starfive_encoder *encoderp;
+	int ret;
+	struct drm_panel *tmp_panel;
+	struct drm_bridge *tmp_bridge;
+	u32 crtcs = 0;
+
+	encoderp = devm_kzalloc(dev, sizeof(*encoderp), GFP_KERNEL);
+	if (!encoderp)
+		return -ENOMEM;
+
+	encoderp->dev = dev;
+	encoderp->drm_dev = drm_dev;
+	dev_set_drvdata(dev, encoderp);
+
+	if (dev->of_node) {
+		crtcs = drm_of_find_possible_crtcs(drm_dev, dev->of_node);
+
+		if (of_property_read_u32(np, "encoder-type", &encoderp->encoder_type)) {
+			DRM_ERROR("Missing encoder-type property in the DT.\n");
+			encoderp->encoder_type = DRM_MODE_ENCODER_TMDS;
+		}
+	}
+
+	/* If no CRTCs were found, fall back to our old behaviour */
+	if (crtcs == 0) {
+		dev_warn(dev, "Falling back to first CRTC\n");
+		crtcs = 1 << 0;
+	}
+
+	encoderp->encoder.possible_crtcs = crtcs;
+
+	ret = drm_encoder_init(drm_dev, &encoderp->encoder,
+			       &starfive_encoder_funcs,
+			       encoderp->encoder_type, NULL);
+	if (ret)
+		return dev_err_probe(dev, ret, "error initializing encoder\n");
+
+	ret = drm_of_find_panel_or_bridge(dev->of_node, 0, 0,
+					  &tmp_panel, &tmp_bridge);
+	if (ret) {
+		dev_err_probe(dev, ret, "endpoint returns %d\n", ret);
+		goto err_bridge;
+	}
+
+	if (tmp_panel)
+		DRM_INFO("found panel on endpoint\n");
+	if (tmp_bridge)
+		DRM_INFO("found bridge on endpoint\n");
+
+	ret = drm_bridge_attach(&encoderp->encoder, tmp_bridge, NULL, 0);
+	if (ret)
+		goto err_bridge;
+
+	return 0;
+
+err_bridge:
+	drm_encoder_cleanup(&encoderp->encoder);
+	return ret;
+}
+
+static void starfive_encoder_unbind(struct device *dev, struct device *master, void *data)
+{
+	struct starfive_encoder *encoderp = dev_get_drvdata(dev);
+
+	starfive_encoder_destroy(&encoderp->encoder);
+}
+
+static const struct component_ops starfive_encoder_component_ops = {
+	.bind   = starfive_encoder_bind,
+	.unbind = starfive_encoder_unbind,
+};
+
+static const struct of_device_id starfive_encoder_driver_dt_match[] = {
+	{ .compatible = "starfive,display-encoder" },
+	{ /* sentinel */ },
+};
+MODULE_DEVICE_TABLE(of, starfive_encoder_driver_dt_match);
+
+static int starfive_encoder_probe(struct platform_device *pdev)
+{
+	return component_add(&pdev->dev, &starfive_encoder_component_ops);
+}
+
+static void starfive_encoder_remove(struct platform_device *pdev)
+{
+	component_del(&pdev->dev, &starfive_encoder_component_ops);
+}
+
+struct platform_driver starfive_encoder_driver = {
+	.probe = starfive_encoder_probe,
+	.remove = starfive_encoder_remove,
+	.driver = {
+		.name = "display-encoder",
+		.of_match_table = of_match_ptr(starfive_encoder_driver_dt_match),
+	},
+};
diff --git a/drivers/gpu/drm/starfive/starfive_drm_encoder.h b/drivers/gpu/drm/starfive/starfive_drm_encoder.h
new file mode 100644
index 0000000000..5ea21441e5
--- /dev/null
+++ b/drivers/gpu/drm/starfive/starfive_drm_encoder.h
@@ -0,0 +1,18 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#ifndef _STARFIVE_DRM_ENCODER_H
+#define _STARFIVE_DRM_ENCODER_H
+
+struct starfive_encoder {
+	struct drm_encoder	encoder;
+	struct device		*dev;
+	struct drm_device	*drm_dev;
+	bool			is_enabled;
+	int			encoder_type;
+};
+
+#define to_starfive_encoder(x) container_of(x, struct starfive_encoder, encoder)
+
+#endif /* _STARFIVE_DRM_CRTC_H */
diff --git a/drivers/gpu/drm/starfive/starfive_drm_gem.c b/drivers/gpu/drm/starfive/starfive_drm_gem.c
new file mode 100644
index 0000000000..fc6da9275f
--- /dev/null
+++ b/drivers/gpu/drm/starfive/starfive_drm_gem.c
@@ -0,0 +1,348 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#include <linux/dma-buf.h>
+#include <linux/iommu.h>
+#include <linux/vmalloc.h>
+#include <drm/drm.h>
+#include <drm/drm_gem.h>
+#include <drm/drm_prime.h>
+#include <drm/drm_vma_manager.h>
+#include <drm/drm_gem_dma_helper.h>
+#include "starfive_drm_drv.h"
+#include "starfive_drm_gem.h"
+
+static const struct drm_gem_object_funcs starfive_gem_object_funcs;
+#if 0
+static const struct vm_operations_struct mmap_mem_ops = {
+#ifdef CONFIG_HAVE_IOREMAP_PROT
+	.access = generic_access_phys
+#endif
+};
+#endif
+
+static int starfive_drm_gem_object_mmap_dma(struct drm_gem_object *obj,
+					    struct vm_area_struct *vma)
+{
+	struct starfive_drm_gem_obj *starfive_obj = to_starfive_gem_obj(obj);
+	struct drm_device *drm = obj->dev;
+
+	return dma_mmap_attrs(drm->dev, vma, starfive_obj->kvaddr,
+			starfive_obj->dma_addr, obj->size, starfive_obj->dma_attrs);
+}
+
+static int starfive_drm_gem_object_mmap(struct drm_gem_object *obj,
+					struct vm_area_struct *vma)
+{
+	int ret;
+
+	/*
+	 * We allocated a struct page table for rk_obj, so clear
+	 * VM_PFNMAP flag that was set by drm_gem_mmap_obj()/drm_gem_mmap().
+	 */
+	vm_flags_clear(vma, VM_PFNMAP);
+	ret = starfive_drm_gem_object_mmap_dma(obj, vma);
+	if (ret)
+		drm_gem_vm_close(vma);
+
+	return ret;
+}
+
+int starfive_drm_gem_mmap_buf(struct drm_gem_object *obj,
+			      struct vm_area_struct *vma)
+{
+	int ret = drm_gem_mmap_obj(obj, obj->size, vma);
+
+	if (ret)
+		return ret;
+
+	return starfive_drm_gem_object_mmap(obj, vma);
+}
+
+int starfive_drm_gem_mmap(struct file *filp, struct vm_area_struct *vma)
+{
+	struct drm_gem_object *obj;
+	int ret;
+
+	ret = drm_gem_mmap(filp, vma);
+	if (ret)
+		return ret;
+
+	obj = vma->vm_private_data;
+
+	/*
+	 * Set vm_pgoff (used as a fake buffer offset by DRM) to 0 and map the
+	 * whole buffer from the start.
+	 */
+	vma->vm_pgoff = 0;
+
+	return starfive_drm_gem_object_mmap(obj, vma);
+}
+
+void starfive_drm_gem_free_object(struct drm_gem_object *obj)
+{
+	struct starfive_drm_gem_obj *starfive_gem = to_starfive_gem_obj(obj);
+	struct drm_device *drm_dev = obj->dev;
+
+	if (starfive_gem->sg)
+		drm_prime_gem_destroy(obj, starfive_gem->sg);
+	else
+		dma_free_attrs(drm_dev->dev, obj->size, starfive_gem->kvaddr,
+			       starfive_gem->dma_addr, starfive_gem->dma_attrs);
+
+	/* release file pointer to gem object. */
+	drm_gem_object_release(obj);
+
+	kfree(starfive_gem);
+}
+
+static struct starfive_drm_gem_obj *
+starfive_drm_gem_alloc_object(struct drm_device *drm, unsigned int size)
+{
+	struct starfive_drm_gem_obj *starfive_obj;
+	struct drm_gem_object *obj;
+	int ret;
+
+	starfive_obj = kzalloc(sizeof(*starfive_obj), GFP_KERNEL);
+	if (!starfive_obj)
+		return ERR_PTR(-ENOMEM);
+
+	obj = &starfive_obj->base;
+	ret = drm_gem_object_init(drm, obj, round_up(size, PAGE_SIZE));
+	if (ret)
+		return ERR_PTR(ret);
+
+	return starfive_obj;
+}
+
+static int starfive_drm_gem_alloc_dma(struct starfive_drm_gem_obj *starfive_obj,
+				      bool alloc_kmap)
+{
+	struct drm_gem_object *obj = &starfive_obj->base;
+	struct drm_device *drm = obj->dev;
+
+	starfive_obj->dma_attrs = DMA_ATTR_WRITE_COMBINE;
+	if (!alloc_kmap)
+		starfive_obj->dma_attrs |= DMA_ATTR_NO_KERNEL_MAPPING;
+
+	starfive_obj->kvaddr = dma_alloc_attrs(drm->dev, obj->size,
+					       &starfive_obj->dma_addr, GFP_KERNEL,
+					       starfive_obj->dma_attrs);
+
+	DRM_INFO("kvaddr = 0x%px\n", starfive_obj->kvaddr);
+	DRM_INFO("dma_addr = 0x%llx, size = %lu\n", starfive_obj->dma_addr, obj->size);
+	if (!starfive_obj->kvaddr) {
+		DRM_ERROR("failed to allocate %zu byte dma buffer", obj->size);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static int starfive_drm_gem_alloc_buf(struct starfive_drm_gem_obj *starfive_obj,
+				      bool alloc_kmap)
+{
+	return starfive_drm_gem_alloc_dma(starfive_obj, alloc_kmap);
+}
+
+static void starfive_drm_gem_release_object(struct starfive_drm_gem_obj *starfive_obj)
+{
+	drm_gem_object_release(&starfive_obj->base);
+	kfree(starfive_obj);
+}
+
+static struct starfive_drm_gem_obj *
+starfive_drm_gem_create_object(struct drm_device *drm, unsigned int size,
+			       bool alloc_kmap)
+{
+	struct starfive_drm_gem_obj *starfive_obj;
+	int ret;
+
+	starfive_obj = starfive_drm_gem_alloc_object(drm, size);
+	if (IS_ERR(starfive_obj))
+		return starfive_obj;
+
+	ret = starfive_drm_gem_alloc_buf(starfive_obj, alloc_kmap);
+	if (ret)
+		goto err_free_obj;
+
+	starfive_obj->base.funcs = &starfive_gem_object_funcs;
+
+	return starfive_obj;
+
+err_free_obj:
+	starfive_drm_gem_release_object(starfive_obj);
+	return ERR_PTR(ret);
+}
+
+static struct starfive_drm_gem_obj *
+starfive_drm_gem_create_with_handle(struct drm_file *file_priv,
+				    struct drm_device *drm,
+				    unsigned int size,
+				    unsigned int *handle)
+{
+	struct starfive_drm_gem_obj *starfive_gem;
+	struct drm_gem_object *gem;
+	int ret;
+#ifdef CONFIG_FRAMEBUFFER_CONSOLE
+	//config true, for console display
+	starfive_gem = starfive_drm_gem_create_object(drm, size, true);
+#else
+	starfive_gem = starfive_drm_gem_create_object(drm, size, false);
+#endif
+	if (IS_ERR(starfive_gem))
+		return ERR_CAST(starfive_gem);
+
+	gem = &starfive_gem->base;
+
+	/*
+	 * allocate a id of idr table where the obj is registered
+	 * and handle has the id what user can see.
+	 */
+	ret = drm_gem_handle_create(file_priv, gem, handle);
+	if (ret)
+		goto err_handle_create;
+
+	/* drop reference from allocate - handle holds it now. */
+	drm_gem_object_put(gem);
+
+	return starfive_gem;
+
+err_handle_create:
+	starfive_drm_gem_free_object(gem);
+
+	return ERR_PTR(ret);
+}
+
+int starfive_drm_gem_dumb_create(struct drm_file *file_priv,
+				 struct drm_device *dev,
+				 struct drm_mode_create_dumb *args)
+{
+	struct starfive_drm_gem_obj *starfive_gem;
+
+	args->pitch = DIV_ROUND_UP(args->width * args->bpp, 8);
+	args->size = args->pitch * args->height;
+
+	starfive_gem = starfive_drm_gem_create_with_handle(file_priv, dev,
+							   args->size,
+							   &args->handle);
+
+	return PTR_ERR_OR_ZERO(starfive_gem);
+}
+
+struct sg_table *starfive_drm_gem_prime_get_sg_table(struct drm_gem_object *obj)
+{
+	struct starfive_drm_gem_obj *starfive_obj = to_starfive_gem_obj(obj);
+	struct drm_device *drm = obj->dev;
+	struct sg_table *sgt;
+	int ret;
+
+	if (starfive_obj->pages)
+		return drm_prime_pages_to_sg(obj->dev, starfive_obj->pages,
+					     starfive_obj->num_pages);
+
+	sgt = kzalloc(sizeof(*sgt), GFP_KERNEL);
+	if (!sgt)
+		return ERR_PTR(-ENOMEM);
+
+	ret = dma_get_sgtable_attrs(drm->dev, sgt, starfive_obj->kvaddr,
+				    starfive_obj->dma_addr, obj->size,
+				    starfive_obj->dma_attrs);
+	if (ret) {
+		DRM_ERROR("failed to allocate sgt, %d\n", ret);
+		kfree(sgt);
+		return ERR_PTR(ret);
+	}
+
+	return sgt;
+}
+
+static int
+starfive_drm_gem_dma_map_sg(struct drm_device *drm,
+			    struct dma_buf_attachment *attach,
+			    struct sg_table *sg,
+			    struct starfive_drm_gem_obj *starfive_obj)
+{
+	int err;
+
+	err = dma_map_sgtable(drm->dev, sg, DMA_BIDIRECTIONAL, 0);
+	if (err)
+		return err;
+
+	if (drm_prime_get_contiguous_size(sg) < attach->dmabuf->size) {
+		DRM_ERROR("failed to map sg_table to contiguous linear address.\n");
+		dma_unmap_sgtable(drm->dev, sg, DMA_BIDIRECTIONAL, 0);
+		return -EINVAL;
+	}
+
+	starfive_obj->dma_addr = sg_dma_address(sg->sgl);
+	starfive_obj->sg = sg;
+
+	return 0;
+}
+
+struct drm_gem_object *
+starfive_drm_gem_prime_import_sg_table(struct drm_device *drm,
+				       struct dma_buf_attachment *attach,
+				       struct sg_table *sg)
+{
+	struct starfive_drm_gem_obj *starfive_obj;
+	int ret;
+
+	starfive_obj = starfive_drm_gem_alloc_object(drm, attach->dmabuf->size);
+	if (IS_ERR(starfive_obj))
+		return ERR_CAST(starfive_obj);
+
+	ret = starfive_drm_gem_dma_map_sg(drm, attach, sg, starfive_obj);
+	if (ret < 0) {
+		DRM_ERROR("failed to import sg table: %d\n", ret);
+		goto err_free_obj;
+	}
+
+	return &starfive_obj->base;
+
+err_free_obj:
+	starfive_drm_gem_release_object(starfive_obj);
+	return ERR_PTR(ret);
+}
+
+int starfive_drm_gem_prime_vmap(struct drm_gem_object *obj, struct iosys_map *map)
+{
+	struct starfive_drm_gem_obj *starfive_obj = to_starfive_gem_obj(obj);
+
+	if (starfive_obj->pages) {
+		void *vaddr = vmap(starfive_obj->pages, starfive_obj->num_pages, VM_MAP,
+						pgprot_writecombine(PAGE_KERNEL));
+		if (!vaddr)
+			return -ENOMEM;
+		iosys_map_set_vaddr(map, vaddr);
+		return 0;
+	}
+
+	if (starfive_obj->dma_attrs & DMA_ATTR_NO_KERNEL_MAPPING)
+		return -ENOMEM;
+
+	iosys_map_set_vaddr(map, starfive_obj->kvaddr);
+
+	return 0;
+}
+
+void starfive_drm_gem_prime_vunmap(struct drm_gem_object *obj, struct iosys_map *map)
+{
+	struct starfive_drm_gem_obj *starfive_obj = to_starfive_gem_obj(obj);
+
+	if (starfive_obj->pages) {
+		vunmap(map->vaddr);
+		return;
+	}
+	/* Nothing to do if allocated by DMA mapping API. */
+}
+
+static const struct drm_gem_object_funcs starfive_gem_object_funcs = {
+	.free		= starfive_drm_gem_free_object,
+	.get_sg_table	= starfive_drm_gem_prime_get_sg_table,
+	.vmap		= starfive_drm_gem_prime_vmap,
+	.vunmap		= starfive_drm_gem_prime_vunmap,
+	.vm_ops		= &drm_gem_dma_vm_ops,
+};
diff --git a/drivers/gpu/drm/starfive/starfive_drm_gem.h b/drivers/gpu/drm/starfive/starfive_drm_gem.h
new file mode 100644
index 0000000000..13a222a26e
--- /dev/null
+++ b/drivers/gpu/drm/starfive/starfive_drm_gem.h
@@ -0,0 +1,40 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#ifndef _STARFIVE_DRM_GEM_H
+#define _STARFIVE_DRM_GEM_H
+
+#include <drm/drm_gem.h>
+
+struct starfive_drm_gem_obj {
+	struct drm_gem_object	base;
+	//void			*cookie; //mtk
+	void			*kvaddr;
+	dma_addr_t		dma_addr;
+	unsigned long		dma_attrs;
+
+	/* Used when IOMMU is enabled */
+	unsigned long		num_pages;
+	struct sg_table		*sg;
+	struct page		**pages;
+};
+
+#define to_starfive_gem_obj(x)	container_of(x, struct starfive_drm_gem_obj, base)
+
+void starfive_drm_gem_free_object(struct drm_gem_object *obj);
+int starfive_drm_gem_mmap(struct file *filp, struct vm_area_struct *vma);
+int starfive_drm_gem_mmap_buf(struct drm_gem_object *obj,
+			      struct vm_area_struct *vma);
+int starfive_drm_gem_dumb_create(struct drm_file *file_priv,
+				 struct drm_device *dev,
+				 struct drm_mode_create_dumb *args);
+struct sg_table *starfive_drm_gem_prime_get_sg_table(struct drm_gem_object *obj);
+struct drm_gem_object *
+starfive_drm_gem_prime_import_sg_table(struct drm_device *dev,
+				       struct dma_buf_attachment *attach,
+				       struct sg_table *sg);
+int starfive_drm_gem_prime_vmap(struct drm_gem_object *obj, struct iosys_map *map);
+void starfive_drm_gem_prime_vunmap(struct drm_gem_object *obj, struct iosys_map *map);
+
+#endif /* _STARFIVE_DRM_GEM_H */
diff --git a/drivers/gpu/drm/starfive/starfive_drm_lcdc.c b/drivers/gpu/drm/starfive/starfive_drm_lcdc.c
new file mode 100644
index 0000000000..7e9bcbde30
--- /dev/null
+++ b/drivers/gpu/drm/starfive/starfive_drm_lcdc.c
@@ -0,0 +1,512 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#include <linux/clk.h>
+#include <linux/module.h>
+#include <linux/units.h>
+#include <drm/drm_crtc.h>
+#include "starfive_drm_lcdc.h"
+#include "starfive_drm_vpp.h"
+
+static u32 sf_fb_clkread32(struct starfive_crtc *sf_crtc, u32 reg)
+{
+	return ioread32(sf_crtc->base_clk + reg);
+}
+
+static void sf_fb_clkwrite32(struct starfive_crtc *sf_crtc, u32 reg, u32 val)
+{
+	iowrite32(val, sf_crtc->base_clk + reg);
+}
+
+static u32 sf_fb_lcdcread32(struct starfive_crtc *sf_crtc, u32 reg)
+{
+	return ioread32(sf_crtc->base_lcdc + reg);
+}
+
+static void sf_fb_lcdcwrite32(struct starfive_crtc *sf_crtc, u32 reg, u32 val)
+{
+	iowrite32(val, sf_crtc->base_lcdc + reg);
+}
+
+static u32 starfive_lcdc_rstread32(struct starfive_crtc *sf_crtc, u32 reg)
+{
+	return ioread32(sf_crtc->base_rst + reg);
+}
+
+static void starfive_lcdc_rstwrite32(struct starfive_crtc *sf_crtc, u32 reg, u32 val)
+{
+	iowrite32(val, sf_crtc->base_rst + reg);
+}
+
+static void lcdc_mode_cfg(struct starfive_crtc *sf_crtc, u32 work_mode, int dot_edge,
+			  int sync_edge, int r2y_bypass, int src_sel, int int_src, int int_freq)
+{
+	u32 lcdc_en = 0x1;
+	u32 cfg = lcdc_en |
+		work_mode << LCDC_WORK_MODE |
+		dot_edge << LCDC_DOTCLK_P |
+		sync_edge << LCDC_HSYNC_P |
+		sync_edge << LCDC_VSYNC_P |
+		0x0 << LCDC_DITHER_EN |
+		r2y_bypass << LCDC_R2Y_BPS |
+		src_sel << LCDC_TV_LCD_PATHSEL |
+		int_src << LCDC_INT_SEL |
+		int_freq << LCDC_INT_FREQ;
+
+	sf_fb_lcdcwrite32(sf_crtc, LCDC_GCTRL, cfg);
+	dev_dbg(sf_crtc->dev, "LCDC WorkMode: 0x%x, LCDC Path: %d\n", work_mode, src_sel);
+}
+
+static void lcdc_timing_cfg(struct starfive_crtc *sf_crtc,
+			    struct drm_crtc_state *state, int vunit)
+{
+	int hpw, hbk, hfp, vpw, vbk, vfp;
+	u32 htiming, vtiming, hvwid;
+
+	//h-sync
+	int hsync_len = state->adjusted_mode.crtc_hsync_end -
+		state->adjusted_mode.crtc_hsync_start;
+	//h-bp
+	int left_margin = state->adjusted_mode.crtc_htotal -
+		state->adjusted_mode.crtc_hsync_end;
+	//h-fp
+	int right_margin = state->adjusted_mode.crtc_hsync_start -
+		state->adjusted_mode.crtc_hdisplay;
+	//v-sync
+	int vsync_len = state->adjusted_mode.crtc_vsync_end -
+		state->adjusted_mode.crtc_vsync_start;
+	//v-bp
+	int upper_margin = state->adjusted_mode.crtc_vtotal -
+		state->adjusted_mode.crtc_vsync_end;
+	//v-fp
+	int lower_margin = state->adjusted_mode.crtc_vsync_start -
+		state->adjusted_mode.crtc_vdisplay;
+
+	hpw = hsync_len - 1;
+	hbk = hsync_len + left_margin;
+	hfp = right_margin;
+	vpw = vsync_len - 1;
+	vbk = vsync_len + upper_margin;
+	vfp = lower_margin;
+
+	dev_dbg(sf_crtc->dev, "%s: h-sync = %d, h-bp = %d, h-fp = %d", __func__,
+		hsync_len, left_margin, right_margin);
+	dev_dbg(sf_crtc->dev, "%s: v-sync = %d, v-bp = %d, v-fp = %d", __func__,
+		vsync_len, upper_margin, lower_margin);
+
+	htiming = hbk | hfp << LCDC_RGB_HFP;
+	vtiming = vbk | vfp << LCDC_RGB_VFP;
+	hvwid = hpw | vpw << LCDC_RGB_VPW | vunit << LCDC_RGB_UNIT;
+
+	sf_fb_lcdcwrite32(sf_crtc, LCDC_RGB_H_TMG, htiming);
+	sf_fb_lcdcwrite32(sf_crtc, LCDC_RGB_V_TMG, vtiming);
+	sf_fb_lcdcwrite32(sf_crtc, LCDC_RGB_W_TMG, hvwid);
+	dev_dbg(sf_crtc->dev, "LCDC HPW: %d, HBK: %d, HFP: %d\n", hpw, hbk, hfp);
+	dev_dbg(sf_crtc->dev, "LCDC VPW: %d, VBK: %d, VFP: %d\n", vpw, vbk, vfp);
+	dev_dbg(sf_crtc->dev, "LCDC V-Unit: %d, 0-HSYNC and 1-dotClk period\n", vunit);
+}
+
+//? background size
+//lcdc_desize_cfg(sf_dev, sf_dev->display_info.xres-1, sf_dev->display_info.yres-1);
+static void lcdc_desize_cfg(struct starfive_crtc *sf_crtc, struct drm_crtc_state *state)
+{
+	int hsize = state->adjusted_mode.crtc_hdisplay - 1;
+	int vsize = state->adjusted_mode.crtc_vdisplay - 1;
+	u32 sizecfg = hsize | vsize << LCDC_BG_VSIZE;
+
+	sf_fb_lcdcwrite32(sf_crtc, LCDC_BACKGROUND, sizecfg);
+	dev_dbg(sf_crtc->dev, "LCDC Dest H-Size: %d, V-Size: %d\n", hsize, vsize);
+}
+
+static void lcdc_rgb_dclk_cfg(struct starfive_crtc *sf_crtc, int dot_clk_sel)
+{
+	u32 cfg = dot_clk_sel << 16;
+
+	sf_fb_lcdcwrite32(sf_crtc, LCDC_RGB_DCLK, cfg);
+	dev_dbg(sf_crtc->dev, "LCDC Dot_clock_output_sel: 0x%x\n", cfg);
+}
+
+// color table
+//win0, no lock transfer
+//win3, no src_sel and addr_mode, 0 assigned to them
+//lcdc_win_cfgA(sf_dev, win_num, sf_dev->display_info.xres-1, sf_dev->display_info.yres-1,
+//		0x1, 0x0, 0x0, 0x1, 0x0, 0x0);
+static void lcdc_win_cfgA(struct starfive_crtc *sf_crtc, struct drm_crtc_state *state,
+			  int win_num, int lay_en, int clor_tab,
+			  int color_en, int addr_mode, int lock)
+{
+	int hsize = state->adjusted_mode.crtc_hdisplay - 1;
+	int vsize = state->adjusted_mode.crtc_vdisplay - 1;
+	int src_sel_v = 1;
+	u32 cfg;
+
+	if (sf_crtc->pp_conn_lcdc < 0)
+		src_sel_v = 0;
+
+	cfg = hsize | vsize << LCDC_WIN_VSIZE | lay_en << LCDC_WIN_EN |
+		clor_tab << LCDC_CC_EN | color_en << LCDC_CK_EN |
+		src_sel_v << LCDC_WIN_ISSEL | addr_mode << LCDC_WIN_PM |
+		lock << LCDC_WIN_CLK;
+
+	sf_fb_lcdcwrite32(sf_crtc, LCDC_WIN0_CFG_A + win_num * 0xC, cfg);
+	dev_dbg(sf_crtc->dev,
+		"LCDC Win%d H-Size: %d, V-Size: %d, lay_en: %d, Src: %d, AddrMode: %d\n",
+		win_num, hsize, vsize, lay_en, src_sel_v, addr_mode);
+}
+
+static void lcdc_win_cfgB(struct starfive_crtc *sf_crtc,
+			  int win_num, int xpos, int ypos, int argb_ord)
+{
+	int win_format = sf_crtc->lcdcfmt;
+	u32 cfg;
+
+#ifdef CONFIG_DRM_STARFIVE_MIPI_DSI
+	argb_ord = 0;
+#else
+	argb_ord = 1;
+#endif
+
+	cfg = xpos |
+		ypos << LCDC_WIN_VPOS |
+		win_format << LCDC_WIN_FMT |
+		argb_ord << LCDC_WIN_ARGB_ORDER;
+
+	sf_fb_lcdcwrite32(sf_crtc, LCDC_WIN0_CFG_B + win_num * 0xC, cfg);
+	dev_dbg(sf_crtc->dev,
+		"LCDC Win%d Xpos: %d, Ypos: %d, win_format: 0x%x, ARGB Order: 0x%x\n",
+		win_num, xpos, ypos, win_format, argb_ord);
+}
+
+//? Color key
+static void lcdc_win_cfgC(struct starfive_crtc *sf_crtc, int win_num, int color_key)
+{
+	sf_fb_lcdcwrite32(sf_crtc, LCDC_WIN0_CFG_C + win_num * 0xC, color_key);
+	dev_dbg(sf_crtc->dev, "LCDC Win%d Color Key: 0x%6x\n", win_num, color_key);
+}
+
+//? hsize
+//lcdc_win_src_size(sf_dev, win_num, sf_dev->display_info.xres-1);
+static void lcdc_win_src_size(struct starfive_crtc *sf_crtc,
+			      struct drm_crtc_state *state, int win_num)
+{
+	int addr, off, winsize, pre_cfg, cfg;
+	int hsize = state->adjusted_mode.crtc_hdisplay - 1;
+
+	switch (win_num) {
+	case 0:
+		addr = LCDC_WIN01_HSIZE;
+		off = 0xfffff000;
+		winsize = hsize;
+		break;
+	case 1:
+		addr = LCDC_WIN01_HSIZE;
+		off = 0xff000fff;
+		winsize = hsize << LCDC_IMG_HSIZE;
+		break;
+	case 2:
+		addr = LCDC_WIN23_HSIZE;
+		off = 0xfffff000;
+		winsize = hsize;
+		break;
+	case 3:
+		addr = LCDC_WIN23_HSIZE;
+		off = 0xff000fff;
+		winsize = hsize << LCDC_IMG_HSIZE;
+		break;
+	case 4:
+		addr = LCDC_WIN45_HSIZE;
+		off = 0xfffff000;
+		winsize = hsize;
+		break;
+	case 5:
+		addr = LCDC_WIN45_HSIZE;
+		off = 0xff000fff;
+		winsize = hsize << LCDC_IMG_HSIZE;
+		break;
+	case 6:
+		addr = LCDC_WIN67_HSIZE;
+		off = 0xfffff000;
+		winsize = hsize;
+		break;
+	case 7:
+		addr = LCDC_WIN67_HSIZE;
+		off = 0xff000fff;
+		winsize = hsize << LCDC_IMG_HSIZE;
+		break;
+	default:
+		addr = LCDC_WIN01_HSIZE;
+		off = 0xfffff000;
+		winsize = hsize;
+		break;
+	}
+	pre_cfg = sf_fb_lcdcread32(sf_crtc, addr) & off;
+	cfg = winsize | pre_cfg;
+	sf_fb_lcdcwrite32(sf_crtc, addr, cfg);
+	dev_dbg(sf_crtc->dev, "LCDC Win%d Src Hsize: %d\n", win_num, hsize);
+}
+
+static void lcdc_alpha_val_cfg(struct starfive_crtc *sf_crtc,
+			       int val1, int val2, int val3, int val4, int sel)
+{
+	u32 val = val1 |
+		val2 << LCDC_ALPHA2 |
+		val3 << LCDC_ALPHA3 |
+		val4 << LCDC_ALPHA4 |
+		sel << LCDC_01_ALPHA_SEL;
+	u32 pre_val = sf_fb_lcdcread32(sf_crtc, LCDC_ALPHA_VALUE) & 0xfffb0000U;
+
+	sf_fb_lcdcwrite32(sf_crtc, LCDC_ALPHA_VALUE, pre_val | val);
+	dev_dbg(sf_crtc->dev, "LCDC Alpha 1: %x, 2: %x, 3: %x, 4: %x\n", val1, val2, val3, val4);
+}
+
+static void lcdc_panel_cfg(struct starfive_crtc *sf_crtc,
+			   int buswid, int depth, int txcycle, int pixpcycle,
+			   int rgb565sel, int rgb888sel)
+{
+	u32 cfg = buswid |
+		depth << LCDC_COLOR_DEP |
+		txcycle << LCDC_TCYCLES |
+		pixpcycle << LCDC_PIXELS |
+		rgb565sel << LCDC_565RGB_SEL |
+		rgb888sel << LCDC_888RGB_SEL;
+
+	sf_fb_lcdcwrite32(sf_crtc, LCDC_PANELDATAFMT, cfg);
+	dev_dbg(sf_crtc->dev, "LCDC bus bit: :%d, pixDep: 0x%x, txCyle: %d, %dpix/cycle, RGB565 2cycle_%d, RGB888 3cycle_%d\n",
+		buswid, depth, txcycle, pixpcycle, rgb565sel, rgb888sel);
+}
+
+//win_num: 0-2
+static void lcdc_win02_addr_cfg(struct starfive_crtc *sf_crtc, int addr0, int addr1)
+{
+	sf_fb_lcdcwrite32(sf_crtc, LCDC_WIN0STARTADDR0 + sf_crtc->win_num * 0x8, addr0);
+	sf_fb_lcdcwrite32(sf_crtc, LCDC_WIN0STARTADDR1 + sf_crtc->win_num * 0x8, addr1);
+	dev_dbg(sf_crtc->dev, "LCDC Win%d Start Addr0: 0x%8x, Addr1: 0x%8x\n",
+		sf_crtc->win_num, addr0, addr1);
+}
+
+void starfive_set_win_addr(struct starfive_crtc *sf_crtc, int addr)
+{
+	lcdc_win02_addr_cfg(sf_crtc, addr, 0x0);
+}
+
+void lcdc_enable_intr(struct starfive_crtc *sf_crtc)
+{
+	u32 cfg = ~(1U << LCDC_OUT_FRAME_END);
+
+	sf_fb_lcdcwrite32(sf_crtc, LCDC_INT_MSK, cfg);
+}
+
+void lcdc_disable_intr(struct starfive_crtc *sf_crtc)
+{
+	sf_fb_lcdcwrite32(sf_crtc, LCDC_INT_MSK, 0xff);
+	sf_fb_lcdcwrite32(sf_crtc, LCDC_INT_CLR, 0xff);
+}
+
+int lcdc_win_sel(struct starfive_crtc *sf_crtc, enum lcdc_in_mode sel)
+{
+	int win_num;
+
+	switch (sel) {
+	case LCDC_IN_LCD_AXI:
+		win_num = LCDC_WIN_0;
+		break;
+	case LCDC_IN_VPP2:
+		win_num = LCDC_WIN_0;
+		break;
+	case LCDC_IN_VPP1:
+		win_num = LCDC_WIN_2;
+		break;
+	case LCDC_IN_VPP0:
+		win_num = LCDC_WIN_1;
+		//mapconv_pp0_sel(sf_dev, 0x0);
+		break;
+	case LCDC_IN_MAPCONVERT:
+		win_num = LCDC_WIN_1;
+		//mapconv_pp0_sel(sf_dev, 0x1);
+		break;
+	default:
+		win_num = 2;
+	}
+
+	return win_num;
+}
+
+void lcdc_dsi_sel(struct starfive_crtc *sf_crtc)
+{
+	int temp;
+	u32 lcdc_en = 0x1;
+	u32 work_mode = 0x1;
+	u32 cfg = lcdc_en | work_mode << LCDC_WORK_MODE;
+
+	sf_fb_lcdcwrite32(sf_crtc, LCDC_GCTRL, cfg);
+	temp = starfive_lcdc_rstread32(sf_crtc, SRST_ASSERT0);
+	temp &= ~(0x1 << BIT_RST_DSI_DPI_PIX);
+	starfive_lcdc_rstwrite32(sf_crtc, SRST_ASSERT0, temp);
+}
+
+irqreturn_t lcdc_isr_handler(int this_irq, void *dev_id)
+{
+	struct starfive_crtc *sf_crtc = dev_id;
+	//u32 intr_status = sf_fb_lcdcread32(sf_crtc, LCDC_INT_STATUS);
+
+	sf_fb_lcdcwrite32(sf_crtc, LCDC_INT_CLR, 0xffffffff);
+
+	return IRQ_HANDLED;
+}
+
+void lcdc_int_cfg(struct starfive_crtc *sf_crtc, int mask)
+{
+	u32 cfg;
+
+	if (mask == 0x1)
+		cfg = 0xffffffff;
+	else
+		cfg = ~(1U << LCDC_OUT_FRAME_END); //only frame end interrupt mask
+
+	sf_fb_lcdcwrite32(sf_crtc, LCDC_INT_MSK, cfg);
+}
+
+void lcdc_config(struct starfive_crtc *sf_crtc, struct drm_crtc_state *state, int win_num)
+{
+	lcdc_mode_cfg(sf_crtc, 0x1, 0x1, 0x1, 0x1, 0x1, 0x1, 0x0);
+	lcdc_timing_cfg(sf_crtc, state, 0);
+	lcdc_desize_cfg(sf_crtc, state);
+	lcdc_rgb_dclk_cfg(sf_crtc, 0x1);
+
+	if (sf_crtc->pp_conn_lcdc < 0) //ddr->lcdc
+		lcdc_win02_addr_cfg(sf_crtc, sf_crtc->dma_addr, 0x0);
+
+	lcdc_win_cfgA(sf_crtc, state, win_num, 0x1, 0x0, 0x0, 0x0, 0x0);
+	lcdc_win_cfgB(sf_crtc, win_num, 0x0, 0x0, 0x0);
+	lcdc_win_cfgC(sf_crtc, win_num, 0xffffff);
+
+	lcdc_win_src_size(sf_crtc, state, win_num);
+	lcdc_alpha_val_cfg(sf_crtc, 0xf, 0xf, 0xf, 0xf, 0x0);
+	lcdc_panel_cfg(sf_crtc, 0x3, 0x4, 0x0, 0x0, 0x0, 0x1);  //rgb888sel?
+}
+
+void lcdc_run(struct starfive_crtc *sf_crtc, u32 win_mode, u32 lcd_trig)
+{
+	u32 runcfg = win_mode << LCDC_EN_CFG_MODE | lcd_trig;
+
+	sf_fb_lcdcwrite32(sf_crtc, LCDC_SWITCH, runcfg);
+	dev_dbg(sf_crtc->dev, "Start run LCDC\n");
+}
+
+static int sf_fb_lcdc_clk_cfg(struct starfive_crtc *sf_crtc, struct drm_crtc_state *state)
+{
+	u32 reg_val = clk_get_rate(sf_crtc->clk_vout_src) / (state->mode.clock * HZ_PER_KHZ);
+	u32 tmp_val;
+
+	dev_dbg(sf_crtc->dev, "%s: reg_val = %u\n", __func__, reg_val);
+
+	switch (state->adjusted_mode.crtc_hdisplay) {
+	case 640:
+		tmp_val = sf_fb_clkread32(sf_crtc, CLK_LCDC_OCLK_CTRL);
+		tmp_val &= ~(0x3F);
+		tmp_val |= (59 & 0x3F);
+		sf_fb_clkwrite32(sf_crtc, CLK_LCDC_OCLK_CTRL, tmp_val);
+		break;
+	case 840:
+		tmp_val = sf_fb_clkread32(sf_crtc, CLK_LCDC_OCLK_CTRL);
+		tmp_val &= ~(0x3F);
+		tmp_val |= (54 & 0x3F);
+		sf_fb_clkwrite32(sf_crtc, CLK_LCDC_OCLK_CTRL, tmp_val);
+		break;
+	case 1024:
+		tmp_val = sf_fb_clkread32(sf_crtc, CLK_LCDC_OCLK_CTRL);
+		tmp_val &= ~(0x3F);
+		tmp_val |= (30 & 0x3F);
+		sf_fb_clkwrite32(sf_crtc, CLK_LCDC_OCLK_CTRL, tmp_val);
+		break;
+	case 1280:
+		tmp_val = sf_fb_clkread32(sf_crtc, CLK_LCDC_OCLK_CTRL);
+		tmp_val &= ~(0x3F);
+		tmp_val |= (30 & 0x3F);
+		sf_fb_clkwrite32(sf_crtc, CLK_LCDC_OCLK_CTRL, tmp_val);
+		break;
+	case 1440:
+		tmp_val = sf_fb_clkread32(sf_crtc, CLK_LCDC_OCLK_CTRL);
+		tmp_val &= ~(0x3F);
+		tmp_val |= (30 & 0x3F);
+		sf_fb_clkwrite32(sf_crtc, CLK_LCDC_OCLK_CTRL, tmp_val);
+		break;
+	case 1680:
+		tmp_val = sf_fb_clkread32(sf_crtc, CLK_LCDC_OCLK_CTRL);
+		tmp_val &= ~(0x3F);
+		tmp_val |= (24 & 0x3F);	//24 30MHZ
+		sf_fb_clkwrite32(sf_crtc, CLK_LCDC_OCLK_CTRL, tmp_val);
+		break;
+	case 1920:
+		tmp_val = sf_fb_clkread32(sf_crtc, CLK_LCDC_OCLK_CTRL);
+		tmp_val &= ~(0x3F);
+		tmp_val |= (10 & 0x3F); //20 30MHz , 15  40Mhz, 10 60Mhz
+		sf_fb_clkwrite32(sf_crtc, CLK_LCDC_OCLK_CTRL, tmp_val);
+		break;
+	case 2048:
+		tmp_val = sf_fb_clkread32(sf_crtc, CLK_LCDC_OCLK_CTRL);
+		tmp_val &= ~(0x3F);
+		tmp_val |= (10 & 0x3F);
+		sf_fb_clkwrite32(sf_crtc, CLK_LCDC_OCLK_CTRL, tmp_val);
+		break;
+	default:
+		tmp_val = sf_fb_clkread32(sf_crtc, CLK_LCDC_OCLK_CTRL);
+		tmp_val &= ~(0x3F);
+		tmp_val |= (reg_val & 0x3F);
+		sf_fb_clkwrite32(sf_crtc, CLK_LCDC_OCLK_CTRL, tmp_val);
+	}
+
+	return 0;
+}
+
+static int sf_fb_lcdc_init(struct starfive_crtc *sf_crtc, struct drm_crtc_state *state)
+{
+	int pp_id;
+	int lcd_in_pp;
+	int win_num;
+
+	pp_id = sf_crtc->pp_conn_lcdc;
+	if (pp_id < 0) {
+		dev_dbg(sf_crtc->dev, "DDR to LCDC\n");
+		lcd_in_pp = LCDC_IN_LCD_AXI;
+		win_num = lcdc_win_sel(sf_crtc, lcd_in_pp);
+		sf_crtc->win_num = win_num;
+		lcdc_config(sf_crtc, state, win_num);
+	} else {
+		dev_dbg(sf_crtc->dev, "DDR to VPP to LCDC\n");
+		lcd_in_pp = (pp_id == 0) ? LCDC_IN_VPP0 :
+			((pp_id == 1) ? LCDC_IN_VPP1 : LCDC_IN_VPP2);
+		win_num = lcdc_win_sel(sf_crtc, lcd_in_pp);
+		sf_crtc->win_num = win_num;
+		lcdc_config(sf_crtc, state, win_num);
+	}
+
+	return 0;
+}
+
+int starfive_lcdc_enable(struct starfive_crtc *sf_crtc)
+{
+	struct drm_crtc_state *state = sf_crtc->crtc.state;
+
+	lcdc_disable_intr(sf_crtc);
+
+	if (sf_fb_lcdc_clk_cfg(sf_crtc, state)) {
+		dev_err(sf_crtc->dev, "lcdc clock configure fail\n");
+		return -EINVAL;
+	}
+
+	if (sf_fb_lcdc_init(sf_crtc, state)) {
+		dev_err(sf_crtc->dev, "lcdc init fail\n");
+		return -EINVAL;
+	}
+
+	lcdc_run(sf_crtc, sf_crtc->win_num, LCDC_RUN);
+	lcdc_enable_intr(sf_crtc);
+
+	return 0;
+}
+
+MODULE_AUTHOR("StarFive Technology Co., Ltd.");
+MODULE_DESCRIPTION("loadable LCDC driver for StarFive");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/starfive/starfive_drm_lcdc.h b/drivers/gpu/drm/starfive/starfive_drm_lcdc.h
new file mode 100644
index 0000000000..6d03ef82de
--- /dev/null
+++ b/drivers/gpu/drm/starfive/starfive_drm_lcdc.h
@@ -0,0 +1,160 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#ifndef __SF_FB_LCDC_H__
+#define __SF_FB_LCDC_H__
+
+#include "starfive_drm_crtc.h"
+
+enum lcdc_in_mode {
+	LCDC_IN_LCD_AXI = 0,
+	LCDC_IN_VPP2,
+	LCDC_IN_VPP1,
+	LCDC_IN_VPP0,
+	LCDC_IN_MAPCONVERT,
+};
+
+enum lcdc_win_num {
+	LCDC_WIN_0 = 0,
+	LCDC_WIN_1,
+	LCDC_WIN_2,
+	LCDC_WIN_3,
+	LCDC_WIN_4,
+	LCDC_WIN_5,
+};
+
+enum WIN_FMT {
+	WIN_FMT_RGB565 = 4,
+	WIN_FMT_XRGB1555,
+	WIN_FMT_XRGB4444,
+	WIN_FMT_XRGB8888,
+};
+
+#define LCDC_STOP	0
+#define LCDC_RUN	1
+
+//lcdc registers
+#define LCDC_SWITCH		0x0000
+#define LCDC_GCTRL		0x0004
+#define LCDC_INT_STATUS		0x0008
+#define LCDC_INT_MSK		0x000C
+#define LCDC_INT_CLR		0x0010
+#define LCDC_RGB_H_TMG		0x0014
+#define LCDC_RGB_V_TMG		0x0018
+#define LCDC_RGB_W_TMG		0x001C
+#define LCDC_RGB_DCLK		0x0020
+#define LCDC_M_CS_CTRL		0x0024
+#define LCDC_DeltaRGB_CFG	0x0028
+#define LCDC_BACKGROUND		0x002C
+#define LCDC_WIN0_CFG_A		0x0030
+#define LCDC_WIN0_CFG_B		0x0034
+#define LCDC_WIN0_CFG_C		0x0038
+#define LCDC_WIN1_CFG_A		0x003C
+#define LCDC_WIN1_CFG_B		0x0040
+#define LCDC_WIN1_CFG_C		0x0044
+#define LCDC_WIN2_CFG_A		0x0048
+#define LCDC_WIN2_CFG_B		0x004C
+#define LCDC_WIN2_CFG_C		0x0050
+#define LCDC_WIN3_CFG_A		0x0054
+#define LCDC_WIN3_CFG_B		0x0058
+#define LCDC_WIN3_CFG_C		0x005C
+#define LCDC_WIN01_HSIZE	0x0090
+#define LCDC_WIN23_HSIZE	0x0094
+#define LCDC_WIN45_HSIZE	0x0098
+#define LCDC_WIN67_HSIZE	0x009C
+#define LCDC_ALPHA_VALUE	0x00A0
+#define LCDC_PANELDATAFMT	0x00A4
+#define LCDC_WIN0STARTADDR0	0x00B8
+#define LCDC_WIN0STARTADDR1	0x00BC
+
+/* Definition controller bit for LCDC registers */
+//for LCDC_SWITCH
+#define LCDC_DTRANS_SWITCH		0
+#define LCDC_MPU_START			1
+#define LCDC_EN_CFG_MODE		2
+//for LCDC_GCTRL
+#define LCDC_EN				0
+#define LCDC_WORK_MODE			1
+#define LCDC_A0_P			4
+#define LCDC_ENABLE_P			5
+#define LCDC_DOTCLK_P			6
+#define LCDC_HSYNC_P			7
+#define LCDC_VSYNC_P			8
+#define LCDC_DITHER_EN			9
+#define LCDC_R2Y_BPS			10
+#define LCDC_MS_SEL			11
+#define LCDC_TV_LCD_PATHSEL		12
+#define LCDC_INTERLACE			13
+#define LCDC_CBCR_ORDER			14
+#define LCDC_INT_SEL			15
+#define LCDC_INT_FREQ			24
+//for LCDC_INT_MSK
+#define LCDC_OUT_FRAME_END		5
+//for RGB_H_TMG,RGB_V_TMG,RGB_W_TMG
+#define LCDC_RGB_HBK			0
+#define LCDC_RGB_HFP			16
+#define LCDC_RGB_VBK			0
+#define LCDC_RGB_VFP			16
+#define LCDC_RGB_HPW			0
+#define LCDC_RGB_VPW			8
+#define LCDC_RGB_UNIT			16
+//for BACKGROUND
+#define LCDC_BG_HSIZE			0
+#define LCDC_BG_VSIZE			12
+//for WINx_CFG_A/B/C
+#define LCDC_WIN_HSIZE			0
+#define LCDC_WIN_VSIZE			12
+#define LCDC_WIN_EN			24
+#define LCDC_CC_EN			25
+#define LCDC_CK_EN			26
+#define LCDC_WIN_ISSEL			27
+#define LCDC_WIN_PM			28
+#define LCDC_WIN_CLK			30
+#define LCDC_WIN_HPOS			0
+#define LCDC_WIN_VPOS			12
+#define LCDC_WIN_FMT			24
+#define LCDC_WIN_ARGB_ORDER		27
+#define LCDC_WIN_CC			0
+//for WINxx_HSIZE
+#define LCDC_IMG_HSIZE			12
+//for LCDC_ALPHA_VALUE
+#define LCDC_ALPHA1			0
+#define LCDC_ALPHA2			4
+#define LCDC_ALPHA3			8
+#define LCDC_ALPHA4			12
+#define LCDC_A_GLBL_ALPHA		16
+#define LCDC_B_GLBL_ALPHA		17
+#define LCDC_01_ALPHA_SEL		18
+//for LCDC_PANELDATAFMT
+#define LCDC_BUS_W			0
+#define LCDC_TCYCLES			2
+#define LCDC_COLOR_DEP			4
+#define LCDC_PIXELS			7
+#define LCDC_332RGB_SEL			8
+#define LCDC_444RGB_SEL			9
+#define LCDC_666RGB_SEL			12
+#define LCDC_565RGB_SEL			16
+#define LCDC_888RGB_SEL			18
+
+//sysrst registers
+#define SRST_ASSERT0		0x00
+#define SRST_STATUS0		0x04
+/* Definition controller bit for syd rst registers */
+#define BIT_RST_DSI_DPI_PIX	17
+
+void lcdc_enable_intr(struct starfive_crtc *sf_crtc);
+void lcdc_disable_intr(struct starfive_crtc *sf_crtc);
+irqreturn_t lcdc_isr_handler(int this_irq, void *dev_id);
+void lcdc_int_cfg(struct starfive_crtc *sf_crtc, int mask);
+void lcdc_config(struct starfive_crtc *sf_crtc,
+		 struct drm_crtc_state *old_state,
+		 int win_num);
+int lcdc_win_sel(struct starfive_crtc *sf_crtc, enum lcdc_in_mode sel);
+void lcdc_dsi_sel(struct starfive_crtc *sf_crtc);
+void lcdc_run(struct starfive_crtc *sf_crtc,
+	      u32 win_mode, u32 lcd_trig);
+void starfive_set_win_addr(struct starfive_crtc *sf_crtc, int addr);
+int starfive_lcdc_enable(struct starfive_crtc *sf_crtc);
+
+#endif
diff --git a/drivers/gpu/drm/starfive/starfive_drm_plane.c b/drivers/gpu/drm/starfive/starfive_drm_plane.c
new file mode 100644
index 0000000000..119a9fe327
--- /dev/null
+++ b/drivers/gpu/drm/starfive/starfive_drm_plane.c
@@ -0,0 +1,227 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#include <drm/drm.h>
+#include <drm/drm_atomic.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_fourcc.h>
+#include <drm/drm_atomic_uapi.h>
+#include <drm/drm_framebuffer.h>
+#include <drm/drm_plane_helper.h>
+#include <drm/drm_gem_framebuffer_helper.h>
+#include <drm/drm_gem_atomic_helper.h>
+#include "starfive_drm_crtc.h"
+#include "starfive_drm_plane.h"
+#include "starfive_drm_gem.h"
+#include "starfive_drm_lcdc.h"
+#include "starfive_drm_vpp.h"
+
+static const u32 formats[] = {
+	DRM_FORMAT_RGB565,
+	DRM_FORMAT_UYVY,
+	DRM_FORMAT_VYUY,
+	DRM_FORMAT_YUYV,
+	DRM_FORMAT_YVYU,
+
+	DRM_FORMAT_YUV420,
+	DRM_FORMAT_NV21,
+	DRM_FORMAT_NV12,
+
+	DRM_FORMAT_ARGB8888,
+	DRM_FORMAT_ABGR8888,
+};
+
+static void starfive_plane_destroy(struct drm_plane *plane)
+{
+	drm_plane_cleanup(plane);
+}
+
+static const struct drm_plane_funcs starfive_plane_funcs = {
+	.update_plane = drm_atomic_helper_update_plane,
+	.disable_plane = drm_atomic_helper_disable_plane,
+	.destroy = starfive_plane_destroy,
+	.set_property = NULL,
+	.reset = drm_atomic_helper_plane_reset,
+	.atomic_duplicate_state = drm_atomic_helper_plane_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_plane_destroy_state,
+};
+
+static void starfive_plane_atomic_disable(struct drm_plane *plane,
+					  struct drm_atomic_state *old_state)
+{
+}
+
+static int starfive_plane_atomic_check(struct drm_plane *plane,
+				       struct drm_atomic_state *state)
+{
+	struct drm_plane_state *new_plane_state =
+		drm_atomic_get_new_plane_state(state, plane);
+	struct drm_framebuffer *fb = new_plane_state->fb;
+	struct drm_crtc_state *crtc_state;
+
+	if (!fb)
+		return 0;
+
+	if (WARN_ON(!new_plane_state->crtc))
+		return 0;
+
+	/*
+	ret = starfive_drm_plane_check(state->crtc, plane,
+				       to_starfive_plane_state(state));
+	if (ret)
+		return ret;
+	*/
+
+	//crtc_state = drm_atomic_get_crtc_state(new_plane_state->state, new_plane_state->crtc);
+	crtc_state = drm_atomic_get_crtc_state(state, new_plane_state->crtc);
+	if (IS_ERR(crtc_state))
+		return PTR_ERR(crtc_state);
+
+	return drm_atomic_helper_check_plane_state(new_plane_state, crtc_state,
+				DRM_PLANE_NO_SCALING,
+				DRM_PLANE_NO_SCALING,
+				true, true);
+}
+
+static void starfive_plane_atomic_update(struct drm_plane *plane,
+					 struct drm_atomic_state *old_state)
+{
+	struct drm_plane_state *new_state = drm_atomic_get_new_plane_state(old_state,
+										plane);
+	struct drm_crtc *crtc = new_state->crtc;
+	struct drm_framebuffer *fb = new_state->fb;
+	//struct drm_plane_state *state = plane->state;
+	//struct drm_crtc *crtc = state->crtc;
+	//struct drm_framebuffer *fb = state->fb;
+
+	dma_addr_t dma_addr;
+	struct drm_gem_object *obj;
+	struct starfive_drm_gem_obj *starfive_obj;
+	unsigned int pitch, format;
+
+	struct starfive_crtc *sf_crtc = to_starfive_crtc(crtc);
+
+	if (!crtc || WARN_ON(!fb))
+		return;
+
+	//if (!plane->state->visible) {
+	if (!new_state->visible) {
+		starfive_plane_atomic_disable(plane, old_state);
+		return;
+	}
+
+	obj = fb->obj[0];
+	starfive_obj = to_starfive_gem_obj(obj);
+	dma_addr = starfive_obj->dma_addr;
+	pitch = fb->pitches[0];
+	format = fb->format->format;
+
+	//dma_addr += (plane->state->src.x1 >> 16) * fb->format->cpp[0];
+	//dma_addr += (plane->state->src.y1 >> 16) * pitch;
+	dma_addr += (new_state->src.x1 >> 16) * fb->format->cpp[0];
+	dma_addr += (new_state->src.y1 >> 16) * pitch;
+	if (sf_crtc->ddr_format != format) {
+		sf_crtc->ddr_format = format;
+		sf_crtc->ddr_format_change = true;
+	} else {
+		sf_crtc->ddr_format_change = false;
+	}
+
+	if (sf_crtc->dma_addr != dma_addr) {
+		sf_crtc->dma_addr = dma_addr;
+		sf_crtc->dma_addr_change = true;
+	} else {
+		sf_crtc->dma_addr_change = false;
+	}
+	sf_crtc->size = obj->size;
+}
+
+static int starfive_plane_atomic_async_check(struct drm_plane *plane,
+					     struct drm_atomic_state *state)
+{
+	struct drm_crtc_state *crtc_state;
+	struct drm_plane_state *new_plane_state = drm_atomic_get_new_plane_state(state,
+										 plane);
+
+	if (plane != new_plane_state->crtc->cursor)
+		return -EINVAL;
+
+	if (!plane->state)
+		return -EINVAL;
+
+	if (!plane->state->fb)
+		return -EINVAL;
+
+	//if (new_plane_state->state)
+	//   crtc_state = drm_atomic_get_existing_crtc_state(new_plane_state->state,
+	//						   new_plane_state->crtc);
+	//else /* Special case for asynchronous cursor updates. */
+	//  crtc_state = new_plane_state->crtc->state;
+
+	if (state)
+		crtc_state = drm_atomic_get_existing_crtc_state(state,
+								new_plane_state->crtc);
+	else /* Special case for asynchronous cursor updates. */
+		//crtc_state = plane->crtc->state;
+		crtc_state = new_plane_state->crtc->state;
+
+	return drm_atomic_helper_check_plane_state(plane->state, crtc_state,
+				DRM_PLANE_NO_SCALING,
+				DRM_PLANE_NO_SCALING,
+				true, true);
+}
+
+static void starfive_plane_atomic_async_update(struct drm_plane *plane,
+					       struct drm_atomic_state *new_state)
+{
+	struct drm_plane_state *new_plane_state =
+		drm_atomic_get_new_plane_state(new_state, plane);
+	struct starfive_crtc *crtcp = to_starfive_crtc(plane->state->crtc);
+
+	plane->state->crtc_x = new_plane_state->crtc_x;
+	plane->state->crtc_y = new_plane_state->crtc_y;
+	plane->state->crtc_h = new_plane_state->crtc_h;
+	plane->state->crtc_w = new_plane_state->crtc_w;
+	plane->state->src_x = new_plane_state->src_x;
+	plane->state->src_y = new_plane_state->src_y;
+	plane->state->src_h = new_plane_state->src_h;
+	plane->state->src_w = new_plane_state->src_w;
+	swap(plane->state->fb, new_plane_state->fb);
+
+	if (crtcp->is_enabled) {
+		starfive_plane_atomic_update(plane, new_state);
+		spin_lock(&crtcp->reg_lock);
+		starfive_crtc_hw_config_simple(crtcp);
+		spin_unlock(&crtcp->reg_lock);
+	}
+}
+
+static const struct drm_plane_helper_funcs starfive_plane_helper_funcs = {
+	.atomic_check = starfive_plane_atomic_check,
+	.atomic_update = starfive_plane_atomic_update,
+	//.prepare_fb = drm_gem_fb_prepare_fb,
+	.prepare_fb = drm_gem_plane_helper_prepare_fb,
+	.atomic_disable = starfive_plane_atomic_disable,
+	.atomic_async_check = starfive_plane_atomic_async_check,
+	.atomic_async_update = starfive_plane_atomic_async_update,
+};
+
+int starfive_plane_init(struct drm_device *dev,
+			struct starfive_crtc *starfive_crtc,
+			enum drm_plane_type type)
+{
+	int ret;
+
+	ret = drm_universal_plane_init(dev, starfive_crtc->planes, 0,
+				       &starfive_plane_funcs, formats,
+				       ARRAY_SIZE(formats), NULL, type, NULL);
+	if (ret) {
+		dev_err(dev->dev, "failed to initialize plane\n");
+		return ret;
+	}
+
+	drm_plane_helper_add(starfive_crtc->planes, &starfive_plane_helper_funcs);
+
+	return 0;
+}
diff --git a/drivers/gpu/drm/starfive/starfive_drm_plane.h b/drivers/gpu/drm/starfive/starfive_drm_plane.h
new file mode 100644
index 0000000000..04c3637d4f
--- /dev/null
+++ b/drivers/gpu/drm/starfive/starfive_drm_plane.h
@@ -0,0 +1,12 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#ifndef _STARFIVE_DRM_PLANE_H
+#define _STARFIVE_DRM_PLANE_H
+
+int starfive_plane_init(struct drm_device *dev,
+			struct starfive_crtc *starfive_crtc,
+			enum drm_plane_type type);
+
+#endif /* _STARFIVE_DRM_PLANE_H */
diff --git a/drivers/gpu/drm/starfive/starfive_drm_vpp.c b/drivers/gpu/drm/starfive/starfive_drm_vpp.c
new file mode 100644
index 0000000000..7a118222bd
--- /dev/null
+++ b/drivers/gpu/drm/starfive/starfive_drm_vpp.c
@@ -0,0 +1,766 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#include <linux/clk.h>
+#include <linux/module.h>
+#include <linux/reset.h>
+#include <linux/delay.h>
+#include "starfive_drm_vpp.h"
+#include "starfive_drm_crtc.h"
+#include <soc/sifive/sifive_ccache.h>
+
+static inline void sf_set_clear(void __iomem *addr, u32 reg, u32 set, u32 clear)
+{
+	u32 value = ioread32(addr + reg);
+
+	value &= ~clear;
+	value |= set;
+	iowrite32(value, addr + reg);
+}
+
+static u32 sf_fb_sysread32(struct starfive_crtc *sf_crtc, u32 reg)
+{
+	return ioread32(sf_crtc->base_syscfg + reg);
+}
+
+static void sf_fb_syswrite32(struct starfive_crtc *sf_crtc, u32 reg, u32 val)
+{
+	iowrite32(val, sf_crtc->base_syscfg + reg);
+}
+
+static u32 sf_fb_vppread32(struct starfive_crtc *sf_crtc, int pp_num, u32 reg)
+{
+	void __iomem *base_vpp;
+
+	switch (pp_num) {
+	case 0:
+		base_vpp = sf_crtc->base_vpp0;
+		break;
+	case 1:
+		base_vpp = sf_crtc->base_vpp1;
+		break;
+	case 2:
+		base_vpp = sf_crtc->base_vpp2;
+		break;
+	default:
+		dev_err(sf_crtc->dev, "Err：invalid vpp Number!\n");
+		return 0;
+	}
+
+	return ioread32(base_vpp + reg);
+}
+
+static void sf_fb_vppwrite32(struct starfive_crtc *sf_crtc, int pp_num, u32 reg, u32 val)
+{
+	void __iomem *base_vpp;
+
+	switch (pp_num) {
+	case 0:
+		base_vpp = sf_crtc->base_vpp0;
+		break;
+	case 1:
+		base_vpp = sf_crtc->base_vpp1;
+		break;
+	case 2:
+		base_vpp = sf_crtc->base_vpp2;
+		break;
+	default:
+		dev_err(sf_crtc->dev, "Err：invalid vpp Number!\n");
+		return;
+	}
+	iowrite32(val, base_vpp + reg);
+}
+
+void mapconv_pp0_sel(struct starfive_crtc *sf_crtc, int sel)
+{
+	u32 temp;
+
+	temp = sf_fb_sysread32(sf_crtc, SYS_MAP_CONV);
+	temp &= ~(0x1);
+	temp |= (sel & 0x1);
+	sf_fb_syswrite32(sf_crtc, SYS_MAP_CONV, temp);
+}
+
+static void pp_output_cfg(struct starfive_crtc *sf_crtc,
+			  int pp_num, int out_sel, int prog_inter, int desformat,
+			  int pt_mode)
+{
+	int cfg = out_sel | prog_inter << PP_INTERLACE |
+		desformat << PP_DES_FORMAT |
+		pt_mode << PP_POINTER_MODE;
+	int pre_cfg = sf_fb_vppread32(sf_crtc, pp_num, PP_CTRL1) & 0xffff8f0U;
+
+	sf_fb_vppwrite32(sf_crtc, pp_num, PP_CTRL1, cfg | pre_cfg);
+	dev_dbg(sf_crtc->dev, "PP%d out_sel: %d, outFormat: 0x%x, Out Interlace: %d, pt_mode: %d\n",
+		pp_num, out_sel, desformat, prog_inter, pt_mode);
+}
+
+static void pp_srcfmt_cfg(struct starfive_crtc *sf_crtc, int pp_num, int srcformat,
+			  int yuv420_inter, int yuv422_mode, int yuv420_mode, int argb_ord)
+{
+	int cfg = srcformat << PP_SRC_FORMAT_N |
+		yuv420_inter << PP_420_ITLC |
+		yuv422_mode << PP_SRC_422_YUV_POS |
+		yuv420_mode << PP_SRC_420_YUV_POS |
+		argb_ord << PP_SRC_ARGB_ORDER;
+	int pre_cfg = sf_fb_vppread32(sf_crtc, pp_num, PP_CTRL1) & 0x83ffff0fU;
+
+	sf_fb_vppwrite32(sf_crtc, pp_num, PP_CTRL1, cfg | pre_cfg);
+	dev_dbg(sf_crtc->dev, "PP%d Src Format: 0x%x, YUV420 Interlace: %d, YUV422: %d, YUV420: %d, ARGB Order: %d\n",
+		pp_num, srcformat, yuv420_inter, yuv422_mode, yuv420_mode, argb_ord);
+}
+
+static void pp_r2yscal_bypass(struct starfive_crtc *sf_crtc,
+			      int pp_num, int r2y_byp, int scal_byp, int y2r_byp)
+{
+	int bypass = (r2y_byp | scal_byp << 1 | y2r_byp << 2) << PP_R2Y_BPS;
+	int pre_cfg = sf_fb_vppread32(sf_crtc, pp_num, PP_CTRL1) & 0xffff8fffU;
+
+	sf_fb_vppwrite32(sf_crtc, pp_num, PP_CTRL1, bypass | pre_cfg);
+	dev_dbg(sf_crtc->dev, "PP%d Bypass R2Y: %d, Y2R: %d, MainSacle: %d\n",
+		pp_num, r2y_byp, y2r_byp, scal_byp);
+}
+
+static void pp_argb_alpha(struct starfive_crtc *sf_crtc, int pp_num, int alpha)
+{
+	int pre_cfg = sf_fb_vppread32(sf_crtc, pp_num, PP_CTRL1) & 0xff00ffffU;
+
+	sf_fb_vppwrite32(sf_crtc, pp_num, PP_CTRL1, alpha << PP_ARGB_ALPHA | pre_cfg);
+	dev_dbg(sf_crtc->dev, "PP%d Alpha: 0x%4x\n", pp_num, alpha);
+}
+
+//rgbNum: 1-3
+static void pp_r2y_coeff(struct starfive_crtc *sf_crtc,
+			 int pp_num, int coef_num, int rcoef, int gcoef, int bcoef, int off)
+{
+	int rgcoeff = rcoef | gcoef << PP_COEF_G1;
+	int bcoefoff = bcoef | off << PP_OFFSET_1;
+	u32 addr1 = (coef_num - 1) * 0x8 + PP_R2Y_COEF1;
+	u32 addr2 = (coef_num - 1) * 0x8 + PP_R2Y_COEF2;
+
+	sf_fb_vppwrite32(sf_crtc, pp_num, addr1, rgcoeff);
+	sf_fb_vppwrite32(sf_crtc, pp_num, addr2, bcoefoff);
+	dev_dbg(sf_crtc->dev, "PP%d coef_num: %d, rCoef: 0x%4x, gCoef: 0x%4x, bCoef: 0x%4x, off: 0x%4x\n",
+		pp_num, coef_num, rcoef, gcoef, bcoef, off);
+}
+
+static void pp_output_fmt_cfg(struct starfive_crtc *sf_crtc,
+			      int pp_num, int yuv420_inter, int yuv422_mode)
+{
+	int pre_cfg = sf_fb_vppread32(sf_crtc, pp_num, PP_CTRL2) & 0xfffffffeU;
+
+	pre_cfg = pre_cfg |
+		yuv420_inter << PP_DES_420_ORDER |
+		yuv422_mode << PP_DES_422_ORDER;
+	sf_fb_vppwrite32(sf_crtc, pp_num, PP_CTRL2, pre_cfg);
+	dev_dbg(sf_crtc->dev, "PP%d Lock Transfer: %d\n", pp_num, yuv422_mode);
+}
+
+static void pp_lock_trans_cfg(struct starfive_crtc *sf_crtc, int pp_num, int lock_trans)
+{
+	int pre_cfg = sf_fb_vppread32(sf_crtc, pp_num, PP_CTRL2) & 0xfffffffeU;
+
+	sf_fb_vppwrite32(sf_crtc, pp_num, PP_CTRL2, lock_trans | pre_cfg);
+	dev_dbg(sf_crtc->dev, "PP%d Lock Transfer: %d\n", pp_num, lock_trans);
+}
+
+static void pp_int_interval_cfg(struct starfive_crtc *sf_crtc, int pp_num, int interval)
+{
+	int pre_cfg = sf_fb_vppread32(sf_crtc, pp_num, PP_CTRL2) & 0xffff00ffU;
+
+	sf_fb_vppwrite32(sf_crtc, pp_num, PP_CTRL2, interval << PP_INT_INTERVAL | pre_cfg);
+	dev_dbg(sf_crtc->dev, "PP%d Frame Interrupt interval: %d Frames\n", pp_num, interval);
+}
+
+static void pp_src_size_cfg(struct starfive_crtc *sf_crtc, int pp_num, int hsize, int vsize)
+{
+	int size = hsize | vsize << PP_SRC_VSIZE;
+
+	sf_fb_vppwrite32(sf_crtc, pp_num, PP_SRC_SIZE, size);
+	dev_dbg(sf_crtc->dev, "PP%d HSize: %d, VSize: %d\n", pp_num, hsize, vsize);
+}
+
+//0-no drop, 1-1/2, 2-1/4, down to 1/32
+static void pp_drop_cfg(struct starfive_crtc *sf_crtc, int pp_num, int hdrop, int vdrop)
+{
+	int drop = hdrop | vdrop << PP_DROP_VRATION;
+
+	sf_fb_vppwrite32(sf_crtc, pp_num, PP_DROP_CTRL, drop);
+	dev_dbg(sf_crtc->dev, "PP%d HDrop: %d, VDrop: %d\n", pp_num, hdrop, vdrop);
+}
+
+static void pp_des_size_cfg(struct starfive_crtc *sf_crtc, int pp_num, int hsize, int vsize)
+{
+	int size = hsize | vsize << PP_DES_VSIZE;
+
+	sf_fb_vppwrite32(sf_crtc, pp_num, PP_DES_SIZE, size);
+	dev_dbg(sf_crtc->dev, "PP%d HSize: %d, VSize: %d\n", pp_num, hsize, vsize);
+}
+
+static void pp_des_addr_cfg(struct starfive_crtc *sf_crtc,
+			    int pp_num, int yaddr, int uaddr, int vaddr)
+{
+	sf_fb_vppwrite32(sf_crtc, pp_num, PP_DES_Y_SA, yaddr);
+	sf_fb_vppwrite32(sf_crtc, pp_num, PP_DES_U_SA, uaddr);
+	sf_fb_vppwrite32(sf_crtc, pp_num, PP_DES_V_SA, vaddr);
+	dev_dbg(sf_crtc->dev, "PP%d des-Addr Y: 0x%8x, U: 0x%8x, V: 0x%8x\n",
+		pp_num, yaddr, uaddr, vaddr);
+}
+
+static void pp_des_offset_cfg(struct starfive_crtc *sf_crtc,
+			      int pp_num, int yoff, int uoff, int voff)
+{
+	sf_fb_vppwrite32(sf_crtc, pp_num, PP_DES_Y_OFS, yoff);
+	sf_fb_vppwrite32(sf_crtc, pp_num, PP_DES_U_OFS, uoff);
+	sf_fb_vppwrite32(sf_crtc, pp_num, PP_DES_V_OFS, voff);
+	dev_dbg(sf_crtc->dev, "PP%d des-Offset Y: 0x%4x, U: 0x%4x, V: 0x%4x\n",
+		pp_num, yoff, uoff, voff);
+}
+
+void pp_intcfg(struct starfive_crtc *sf_crtc, int pp_num, int int_mask)
+{
+	int intcfg = ~(0x1 << 0);
+
+	if (int_mask)
+		intcfg = 0xf;
+	sf_fb_vppwrite32(sf_crtc, pp_num, PP_INT_MASK, intcfg);
+}
+
+//next source frame Y/RGB start address, ?
+void pp_src_addr_next(struct starfive_crtc *sf_crtc, int pp_num, int ysa, int usa, int vsa)
+{
+	sf_fb_vppwrite32(sf_crtc, pp_num, PP_SRC_Y_SA_NXT, ysa);
+	sf_fb_vppwrite32(sf_crtc, pp_num, PP_SRC_U_SA_NXT, usa);
+	sf_fb_vppwrite32(sf_crtc, pp_num, PP_SRC_V_SA_NXT, vsa);
+	dev_dbg(sf_crtc->dev,
+		"PP%d next Y startAddr: 0x%8x, U startAddr: 0x%8x, V startAddr: 0x%8x\n",
+		pp_num, ysa, usa, vsa);
+}
+
+void pp_src_offset_cfg(struct starfive_crtc *sf_crtc, int pp_num, int yoff, int uoff, int voff)
+{
+	sf_fb_vppwrite32(sf_crtc, pp_num, PP_SRC_Y_OFS, yoff);
+	sf_fb_vppwrite32(sf_crtc, pp_num, PP_SRC_U_OFS, uoff);
+	sf_fb_vppwrite32(sf_crtc, pp_num, PP_SRC_V_OFS, voff);
+	dev_dbg(sf_crtc->dev, "PP%d src-Offset Y: 0x%4x, U: 0x%4x, V: 0x%4x\n",
+		pp_num, yoff, uoff, voff);
+}
+
+void pp_nxt_addr_load(struct starfive_crtc *sf_crtc, int pp_num, int nxt_par, int nxt_pos)
+{
+	sf_fb_vppwrite32(sf_crtc, pp_num, PP_LOAD_NXT_PAR, nxt_par | nxt_pos);
+	dev_dbg(sf_crtc->dev, "PP%d next addrPointer: %d, %d set Regs\n", pp_num, nxt_par, nxt_pos);
+}
+
+void pp_run(struct starfive_crtc *sf_crtc, int pp_num, int start)
+{
+	sf_fb_vppwrite32(sf_crtc, pp_num, PP_SWITCH, start);
+	//if (start)
+	//	dev_dbg(sf_crtc->dev, "Now start the PP%d\n\n", pp_num);
+}
+
+void pp1_enable_intr(struct starfive_crtc *sf_crtc)
+{
+	sf_fb_vppwrite32(sf_crtc, 1, PP_INT_MASK, 0x0);
+}
+
+void pp_enable_intr(struct starfive_crtc *sf_crtc, int pp_num)
+{
+	u32 cfg = 0xfffe;
+
+	sf_fb_vppwrite32(sf_crtc, pp_num, PP_INT_MASK, cfg);
+}
+
+void pp_disable_intr(struct starfive_crtc *sf_crtc, int pp_num)
+{
+	sf_fb_vppwrite32(sf_crtc, pp_num, PP_INT_MASK, 0xf);
+	sf_fb_vppwrite32(sf_crtc, pp_num, PP_INT_CLR, 0xf);
+}
+
+static void pp_srcfmt_set(struct starfive_crtc *sf_crtc, int pp_num, struct pp_video_mode *src)
+{
+	switch (src->format) {
+	case COLOR_YUV422_YVYU:
+		pp_srcfmt_cfg(sf_crtc, pp_num, PP_SRC_YUV422, 0x0, COLOR_YUV422_YVYU, 0x0, 0x0);
+		break;
+	case COLOR_YUV422_VYUY:
+		pp_srcfmt_cfg(sf_crtc, pp_num, PP_SRC_YUV422, 0x0, COLOR_YUV422_VYUY, 0x0, 0x0);
+		break;
+	case COLOR_YUV422_YUYV:
+		pp_srcfmt_cfg(sf_crtc, pp_num, PP_SRC_YUV422, 0x0, COLOR_YUV422_YUYV, 0x0, 0x0);
+		break;
+	case COLOR_YUV422_UYVY:
+		pp_srcfmt_cfg(sf_crtc, pp_num, PP_SRC_YUV422, 0x0, COLOR_YUV422_UYVY, 0x0, 0x0);
+		break;
+	case COLOR_YUV420P:
+		pp_srcfmt_cfg(sf_crtc, pp_num, PP_SRC_YUV420P, 0x0, 0, 0x0, 0x0);
+		break;
+	case COLOR_YUV420_NV21:
+		pp_srcfmt_cfg(sf_crtc, pp_num, PP_SRC_YUV420I, 0x1, 0,
+			      COLOR_YUV420_NV21 - COLOR_YUV420_NV21, 0x0);
+		break;
+	case COLOR_YUV420_NV12:
+		pp_srcfmt_cfg(sf_crtc, pp_num, PP_SRC_YUV420I, 0x1, 0,
+			      COLOR_YUV420_NV12 - COLOR_YUV420_NV21, 0x0);
+		break;
+	case COLOR_RGB888_ARGB:
+		pp_srcfmt_cfg(sf_crtc, pp_num, PP_SRC_GRB888, 0x0, 0x0,
+			      0x0, COLOR_RGB888_ARGB - COLOR_RGB888_ARGB);
+		break;
+	case COLOR_RGB888_ABGR:
+		pp_srcfmt_cfg(sf_crtc, pp_num, PP_SRC_GRB888, 0x0, 0x0,
+			      0x0, COLOR_RGB888_ABGR - COLOR_RGB888_ARGB);
+		break;
+	case COLOR_RGB888_RGBA:
+		pp_srcfmt_cfg(sf_crtc, pp_num, PP_SRC_GRB888, 0x0, 0x0,
+			      0x0, COLOR_RGB888_RGBA - COLOR_RGB888_ARGB);
+		break;
+	case COLOR_RGB888_BGRA:
+		pp_srcfmt_cfg(sf_crtc, pp_num, PP_SRC_GRB888, 0x0, 0x0,
+			      0x0, COLOR_RGB888_BGRA - COLOR_RGB888_ARGB);
+		break;
+	case COLOR_RGB565:
+		pp_srcfmt_cfg(sf_crtc, pp_num, PP_SRC_RGB565, 0x0, 0x0, 0x0, 0x0);
+		break;
+	}
+}
+
+static void pp_dstfmt_set(struct starfive_crtc *sf_crtc, int pp_num, struct pp_video_mode *dst)
+{
+	unsigned int outsel = 1;
+
+	if (dst->addr)
+		outsel = 0;
+
+	switch (dst->format) {
+	case COLOR_YUV422_YVYU:
+		pp_output_cfg(sf_crtc, pp_num, outsel, 0x0, PP_DST_YUV422, 0x0);
+		pp_output_fmt_cfg(sf_crtc, pp_num, 0, COLOR_YUV422_UYVY - COLOR_YUV422_YVYU);
+		break;
+	case COLOR_YUV422_VYUY:
+		pp_output_cfg(sf_crtc, pp_num, outsel, 0x0, PP_DST_YUV422, 0x0);
+		pp_output_fmt_cfg(sf_crtc, pp_num, 0, COLOR_YUV422_UYVY - COLOR_YUV422_VYUY);
+		break;
+	case COLOR_YUV422_YUYV:
+		pp_output_cfg(sf_crtc, pp_num, outsel, 0x0, PP_DST_YUV422, 0x0);
+		pp_output_fmt_cfg(sf_crtc, pp_num, 0, COLOR_YUV422_UYVY - COLOR_YUV422_YUYV);
+		break;
+	case COLOR_YUV422_UYVY:
+		pp_output_cfg(sf_crtc, pp_num, outsel, 0x0, PP_DST_YUV422, 0x0);
+		pp_output_fmt_cfg(sf_crtc, pp_num, 0, COLOR_YUV422_UYVY - COLOR_YUV422_YVYU);
+		break;
+	case COLOR_YUV420P:
+		pp_output_cfg(sf_crtc, pp_num, outsel, 0x0, PP_DST_YUV420P, 0x0);
+		pp_output_fmt_cfg(sf_crtc, pp_num, 0, 0);
+		break;
+	case COLOR_YUV420_NV21:
+		pp_output_cfg(sf_crtc, pp_num, outsel, 0x0, PP_DST_YUV420I, 0x0);
+		pp_output_fmt_cfg(sf_crtc, pp_num, COLOR_YUV420_NV21 - COLOR_YUV420_NV21, 0);
+		break;
+	case COLOR_YUV420_NV12:
+		pp_output_cfg(sf_crtc, pp_num, outsel, 0x0, PP_DST_YUV420I, 0x0);///0x2, 0x0);
+		//pp_output_fmt_cfg(pp_num, COLOR_YUV420_NV12 - COLOR_YUV420_NV21, 0);
+		break;
+	case COLOR_RGB888_ARGB:
+		pp_output_cfg(sf_crtc, pp_num, outsel, 0x0, PP_DST_ARGB888, 0x0);
+		//pp_output_fmt_cfg(pp_num, 0, 0);
+		break;
+	case COLOR_RGB888_ABGR:
+		pp_output_cfg(sf_crtc, pp_num, outsel, 0x0, PP_DST_ABGR888, 0x0);
+		pp_output_fmt_cfg(sf_crtc, pp_num, 0, 0);
+		break;
+	case COLOR_RGB888_RGBA:
+		pp_output_cfg(sf_crtc, pp_num, outsel, 0x0, PP_DST_RGBA888, 0x0);
+		pp_output_fmt_cfg(sf_crtc, pp_num, 0, 0);
+		break;
+	case COLOR_RGB888_BGRA:
+		pp_output_cfg(sf_crtc, pp_num, outsel, 0x0, PP_DST_BGRA888, 0x0);
+		pp_output_fmt_cfg(sf_crtc, pp_num, 0, 0);
+		break;
+	case COLOR_RGB565:
+		pp_output_cfg(sf_crtc, pp_num, outsel, 0x0, PP_DST_RGB565, 0x0);
+		pp_output_fmt_cfg(sf_crtc, pp_num, 0, 0);
+		break;
+	}
+}
+
+static void pp_format_set(struct starfive_crtc *sf_crtc, int pp_num,
+			  struct pp_video_mode *src, struct pp_video_mode *dst)
+{
+	/* 1:bypass, 0:not bypass */
+	unsigned int scale_byp = 1;
+
+	pp_srcfmt_set(sf_crtc, pp_num, src);
+	pp_dstfmt_set(sf_crtc, pp_num, dst);
+
+	if (src->height != dst->height || src->width != dst->width)
+		scale_byp = 0;
+
+	if (src->format >= COLOR_RGB888_ARGB && dst->format <= COLOR_YUV420_NV12) {
+		/* rgb -> yuv-420 */
+		pp_r2yscal_bypass(sf_crtc, pp_num, NOT_BYPASS, scale_byp, BYPASS);
+		pp_r2y_coeff(sf_crtc, pp_num, 1, R2Y_COEF_R1, R2Y_COEF_G1,
+			     R2Y_COEF_B1, R2Y_OFFSET1);
+		pp_r2y_coeff(sf_crtc, pp_num, 2, R2Y_COEF_R2, R2Y_COEF_G2,
+			     R2Y_COEF_B2, R2Y_OFFSET2);
+		pp_r2y_coeff(sf_crtc, pp_num, 3, R2Y_COEF_R3, R2Y_COEF_G3,
+			     R2Y_COEF_B3, R2Y_OFFSET3);
+	} else if (src->format <= COLOR_YUV420_NV12 && dst->format >= COLOR_RGB888_ARGB) {
+		/* yuv-420 -> rgb */
+		pp_r2yscal_bypass(sf_crtc, pp_num, BYPASS, scale_byp, NOT_BYPASS);
+	} else if (src->format <= COLOR_YUV422_YVYU && dst->format <= COLOR_YUV420_NV12) {
+		/* yuv422 -> yuv420 */
+		pp_r2yscal_bypass(sf_crtc, pp_num, BYPASS, scale_byp, BYPASS);
+	} else {
+		/* rgb565->argb888 */
+		pp_r2yscal_bypass(sf_crtc, pp_num, BYPASS, scale_byp, BYPASS);
+	} //else if ((src->format >= COLOR_RGB888_ARGB) && (dst->format >= COLOR_RGB888_ARGB)) {
+		/* rgb -> rgb */
+		// pp_r2yscal_bypass(pp_num, BYPASS, scale_byp, BYPASS);
+	//}
+	pp_argb_alpha(sf_crtc, pp_num, 0xff);
+
+	if (dst->addr)
+		pp_lock_trans_cfg(sf_crtc, pp_num, SYS_BUS_OUTPUT);
+	else
+		pp_lock_trans_cfg(sf_crtc, pp_num, FIFO_OUTPUT);
+
+	pp_int_interval_cfg(sf_crtc, pp_num, 0x1);
+}
+
+static void pp_size_set(struct starfive_crtc *sf_crtc, int pp_num,
+			struct pp_video_mode *src, struct pp_video_mode *dst)
+{
+	u32 src_addr, dstaddr;
+	unsigned int y_rgb_ofst = 0, uofst = 0, v_uvofst = 0;
+	unsigned int next_y_rgb_addr = 0, next_u_addr = 0, next_v_addr = 0;
+	unsigned int i = 0;
+	unsigned int size;
+
+	pp_src_size_cfg(sf_crtc, pp_num, src->width - 1, src->height - 1);
+	pp_drop_cfg(sf_crtc, pp_num, 0x0, 0x0);///0:no drop
+	pp_des_size_cfg(sf_crtc, pp_num, dst->width - 1, dst->height - 1);
+
+	src_addr = src->addr + (i << 30); //PP_SRC_BASE_ADDR + (i << 30);
+	size = src->width * src->height;
+
+	if (src->format >= COLOR_RGB888_ARGB) {
+		next_y_rgb_addr = src_addr;
+		next_u_addr = 0;
+		next_v_addr = 0;
+
+		//pp_src_addr_next(pp_num, src_addr, 0, 0);
+		//pp_src_offset_cfg(pp_num, 0x0, 0x0, 0x0);
+	} else {
+		if (src->format == COLOR_YUV420_NV21) {    //ok
+			next_y_rgb_addr = src_addr;
+			next_u_addr = src_addr + size + 1;
+			next_v_addr = src_addr + size;
+			v_uvofst = size;
+		} else if (src->format == COLOR_YUV420_NV12) {
+			next_y_rgb_addr = src_addr;
+			next_u_addr = src_addr + size;
+			next_v_addr = src_addr + size + 1;
+			v_uvofst = size;
+		} else if (src->format == COLOR_YUV420P) {
+			next_y_rgb_addr = src_addr;
+			next_u_addr = src_addr + size;
+			next_v_addr = src_addr + size * 5 / 4;
+		} else if (src->format == COLOR_YUV422_YVYU) {   //ok
+			next_y_rgb_addr = src_addr;
+			next_u_addr = src_addr + 1;
+			next_v_addr = src_addr + 3;
+		} else if (src->format == COLOR_YUV422_VYUY) {   //ok
+			next_y_rgb_addr = src_addr + 1;
+			next_u_addr = src_addr + 2;
+			next_v_addr = src_addr;
+		} else if (src->format == COLOR_YUV422_YUYV) {   //ok
+			next_y_rgb_addr = src_addr;
+			next_u_addr = src_addr + 1;
+			next_v_addr = src_addr + 2;
+		} else if (src->format == COLOR_YUV422_UYVY) {  //ok
+			next_y_rgb_addr = src_addr + 1;
+			next_u_addr = src_addr;
+			next_v_addr = src_addr + 2;
+		}
+	}
+	pp_src_addr_next(sf_crtc, pp_num, next_y_rgb_addr, next_u_addr, next_v_addr);
+	pp_src_offset_cfg(sf_crtc, pp_num, y_rgb_ofst, uofst, v_uvofst);
+	/* source addr not change */
+	pp_nxt_addr_load(sf_crtc, pp_num, 0x1, (i & 0x1));
+
+	if (dst->addr) {
+		dstaddr = dst->addr;
+		size = dst->height * dst->width;
+		y_rgb_ofst = 0;
+		uofst = 0;
+		v_uvofst = 0;
+
+		if (dst->format >= COLOR_RGB888_ARGB) {
+			next_y_rgb_addr = dstaddr;
+			next_u_addr = 0;
+			next_v_addr = 0;
+		} else {
+			if (dst->format == COLOR_YUV420_NV21) {
+				/* yyyyvuvuvu */
+				next_y_rgb_addr = dstaddr;
+				next_u_addr = dstaddr + size;
+				next_v_addr = 0;//dstaddr + size;
+			} else if (dst->format == COLOR_YUV420_NV12) {
+				/* yyyyuvuvuv */
+				next_y_rgb_addr = dstaddr;
+				next_u_addr = dstaddr + size;
+				next_v_addr = dstaddr + size + 1;
+				uofst = size;
+			} else if (dst->format == COLOR_YUV420P) {
+				next_y_rgb_addr = dstaddr;
+				next_u_addr = dstaddr + size;
+				next_v_addr = dstaddr + size * 5 / 4;
+			} else if (dst->format == COLOR_YUV422_YVYU) {
+				next_y_rgb_addr = dstaddr;
+				next_u_addr = dstaddr + 1;
+				next_v_addr = dstaddr + 3;
+			} else if (dst->format == COLOR_YUV422_VYUY) {
+				next_y_rgb_addr = dstaddr + 1;
+				next_u_addr = dstaddr + 2;
+				next_v_addr = dstaddr;
+			} else if (dst->format == COLOR_YUV422_YUYV) {
+				next_y_rgb_addr = dstaddr;
+				next_u_addr = dstaddr + 1;
+				next_v_addr = dstaddr + 2;
+			} else if (dst->format == COLOR_YUV422_UYVY) {
+				next_y_rgb_addr = dstaddr + 1;
+				next_u_addr = dstaddr;
+				next_v_addr = dstaddr + 2;
+			}
+		}
+		pp_des_addr_cfg(sf_crtc, pp_num, next_y_rgb_addr, next_u_addr, next_v_addr);
+		pp_des_offset_cfg(sf_crtc, pp_num, y_rgb_ofst, uofst, v_uvofst);
+	}
+}
+
+static void pp_config(struct starfive_crtc *sf_crtc, int pp_num,
+		      struct pp_video_mode *src, struct pp_video_mode *dst)
+{
+	//pp_disable_intr(sf_dev, pp_num);
+	pp_format_set(sf_crtc, pp_num, src, dst);
+	pp_size_set(sf_crtc, pp_num, src, dst);
+}
+
+irqreturn_t vpp1_isr_handler(int this_irq, void *dev_id)
+{
+	struct starfive_crtc *sf_crtc = dev_id;
+
+	sf_fb_vppread32(sf_crtc, 1, PP_INT_STATUS);
+	sf_fb_vppwrite32(sf_crtc, 1, PP_INT_CLR, 0xf);
+	sifive_ccache_flush_range(sf_crtc->dma_addr, sf_crtc->size);
+
+	return IRQ_HANDLED;
+}
+
+static void starfive_pp_enable_intr(struct starfive_crtc *sf_crtc, int enable)
+{
+	int pp_id;
+
+	for (pp_id = 0; pp_id < PP_NUM; pp_id++) {
+		if (sf_crtc->pp[pp_id].inited == 1) {
+			if (enable)
+				pp_enable_intr(sf_crtc, pp_id);
+			else
+				pp_disable_intr(sf_crtc, pp_id);
+		}
+	}
+}
+
+static int starfive_pp_video_mode_init(struct starfive_crtc *sf_crtc,
+				       struct pp_video_mode *src,
+				       struct pp_video_mode *dst,
+				       int pp_id)
+{
+	if (!src || !dst) {
+		dev_err(sf_crtc->dev, "Invalid argument!\n");
+		return -EINVAL;
+	}
+
+	if (pp_id < PP_NUM && pp_id >= 0) {
+		src->format = sf_crtc->vpp_format;
+		src->width = sf_crtc->crtc.state->adjusted_mode.hdisplay;
+		src->height = sf_crtc->crtc.state->adjusted_mode.vdisplay;
+		src->addr = sf_crtc->dma_addr;
+		//src->addr = 0xa0000000;
+		dst->format = sf_crtc->pp[pp_id].dst.format;
+		dst->width = sf_crtc->crtc.state->adjusted_mode.hdisplay;
+		dst->height = sf_crtc->crtc.state->adjusted_mode.vdisplay;
+		if (sf_crtc->pp[pp_id].bus_out) /*out to ddr*/
+			dst->addr = 0xfc000000;
+		else if (sf_crtc->pp[pp_id].fifo_out) /*out to lcdc*/
+			dst->addr = 0;
+	} else {
+		dev_err(sf_crtc->dev, "pp_id %d is not support\n", pp_id);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int starfive_pp_init(struct starfive_crtc *sf_crtc)
+{
+	int pp_id;
+	int ret = 0;
+	struct pp_video_mode src, dst;
+
+	for (pp_id = 0; pp_id < PP_NUM; pp_id++) {
+		if (sf_crtc->pp[pp_id].inited == 1) {
+			ret = starfive_pp_video_mode_init(sf_crtc, &src, &dst, pp_id);
+			if (!ret)
+				pp_config(sf_crtc, pp_id, &src, &dst);
+		}
+	}
+
+	return ret;
+}
+
+static int starfive_pp_run(struct starfive_crtc *sf_crtc)
+{
+	int pp_id;
+	int ret = 0;
+
+	for (pp_id = 0; pp_id < PP_NUM; pp_id++) {
+		if (sf_crtc->pp[pp_id].inited == 1)
+			pp_run(sf_crtc, pp_id, PP_RUN);
+	}
+
+	return ret;
+}
+
+int starfive_pp_enable(struct starfive_crtc *sf_crtc)
+{
+	starfive_pp_enable_intr(sf_crtc, PP_INTR_DISABLE);
+
+	if (starfive_pp_init(sf_crtc))
+		return -ENODEV;
+
+	starfive_pp_run(sf_crtc);
+	starfive_pp_enable_intr(sf_crtc, PP_INTR_ENABLE);
+
+	return 0;
+}
+
+int starfive_pp_update(struct starfive_crtc *sf_crtc)
+{
+	int pp_id;
+	int ret = 0;
+	struct pp_video_mode src, dst;
+
+	for (pp_id = 0; pp_id < PP_NUM; pp_id++) {
+		if (sf_crtc->pp[pp_id].inited == 1) {
+			ret = starfive_pp_video_mode_init(sf_crtc, &src, &dst, pp_id);
+			if (!ret) {
+				if (sf_crtc->ddr_format_change)
+					pp_format_set(sf_crtc, pp_id, &src, &dst);
+
+				if (sf_crtc->dma_addr_change)
+					pp_size_set(sf_crtc, pp_id, &src, &dst);
+			}
+		}
+	}
+
+	return 0;
+}
+
+int starfive_pp_get_2lcdc_id(struct starfive_crtc *sf_crtc)
+{
+	int pp_id;
+
+	for (pp_id = 0; pp_id < PP_NUM; pp_id++) {
+		if (sf_crtc->pp[pp_id].inited == 1) {
+			if (sf_crtc->pp[pp_id].fifo_out == 1 && !sf_crtc->pp[pp_id].bus_out)
+				return pp_id;
+		}
+	}
+
+	if (pp_id == PP_NUM - 1)
+		dev_warn(sf_crtc->dev, "NO pp connect to LCDC\n");
+
+	return -ENODEV;
+}
+
+void dsitx_vout_init(struct starfive_crtc *sf_crtc)
+{
+	u32 temp;
+
+	reset_control_assert(sf_crtc->rst_vout_src);
+	reset_control_assert(sf_crtc->rst_disp_axi);
+	clk_prepare_enable(sf_crtc->clk_disp_axi);
+	clk_prepare_enable(sf_crtc->clk_vout_src);
+	reset_control_deassert(sf_crtc->rst_vout_src);
+	reset_control_deassert(sf_crtc->rst_disp_axi);
+
+	sf_set_clear(sf_crtc->base_clk, clk_disp0_axi_ctrl_REG, BIT(31), BIT(31));
+	sf_set_clear(sf_crtc->base_clk, clk_disp1_axi_ctrl_REG, BIT(31), BIT(31));
+	sf_set_clear(sf_crtc->base_clk, clk_lcdc_oclk_ctrl_REG, BIT(31), BIT(31));
+	sf_set_clear(sf_crtc->base_clk, clk_lcdc_axi_ctrl_REG, BIT(31), BIT(31));
+	sf_set_clear(sf_crtc->base_clk, clk_vpp0_axi_ctrl_REG, BIT(31), BIT(31));
+	sf_set_clear(sf_crtc->base_clk, clk_vpp1_axi_ctrl_REG, BIT(31), BIT(31));
+	sf_set_clear(sf_crtc->base_clk, clk_vpp2_axi_ctrl_REG, BIT(31), BIT(31));
+	sf_set_clear(sf_crtc->base_clk, clk_ppi_tx_esc_clk_ctrl_REG, BIT(31), BIT(31));
+	sf_set_clear(sf_crtc->base_clk, clk_dsi_apb_ctrl_REG, BIT(31), BIT(31));
+	sf_set_clear(sf_crtc->base_clk, clk_dsi_sys_clk_ctrl_REG, BIT(31), BIT(31));
+
+	sf_set_clear(sf_crtc->base_rst, vout_rstgen_assert0_REG, ~0x1981ec, 0x1981ec);
+
+	do {
+		temp = ioread32(sf_crtc->base_rst + vout_rstgen_status0_REG);
+		temp &= 0x1981ec;
+	} while (temp != 0x1981ec);
+}
+
+void vout_reset(struct starfive_crtc *sf_crtc)
+{
+	u32 temp;
+
+	iowrite32(0xFFFFFFFF, sf_crtc->base_rst);
+
+	clk_prepare_enable(sf_crtc->clk_disp_axi);
+	clk_prepare_enable(sf_crtc->clk_vout_src);
+	reset_control_deassert(sf_crtc->rst_vout_src);
+	reset_control_deassert(sf_crtc->rst_disp_axi);
+
+	sf_set_clear(sf_crtc->base_clk, clk_disp0_axi_ctrl_REG, BIT(31), BIT(31));
+	sf_set_clear(sf_crtc->base_clk, clk_disp1_axi_ctrl_REG, BIT(31), BIT(31));
+	sf_set_clear(sf_crtc->base_clk, clk_lcdc_oclk_ctrl_REG, BIT(31), BIT(31));
+	sf_set_clear(sf_crtc->base_clk, clk_lcdc_axi_ctrl_REG, BIT(31), BIT(31));
+	sf_set_clear(sf_crtc->base_clk, clk_vpp0_axi_ctrl_REG, BIT(31), BIT(31));
+	sf_set_clear(sf_crtc->base_clk, clk_vpp1_axi_ctrl_REG, BIT(31), BIT(31));
+	sf_set_clear(sf_crtc->base_clk, clk_vpp2_axi_ctrl_REG, BIT(31), BIT(31));
+	sf_set_clear(sf_crtc->base_clk, clk_mapconv_apb_ctrl_REG, BIT(31), BIT(31));
+	sf_set_clear(sf_crtc->base_clk, clk_mapconv_axi_ctrl_REG, BIT(31), BIT(31));
+	sf_set_clear(sf_crtc->base_clk, clk_pixrawout_apb_ctrl_REG, BIT(31), BIT(31));
+	sf_set_clear(sf_crtc->base_clk, clk_pixrawout_axi_ctrl_REG, BIT(31), BIT(31));
+	sf_set_clear(sf_crtc->base_clk, clk_csi2tx_strm0_apb_ctrl_REG, BIT(31), BIT(31));
+	sf_set_clear(sf_crtc->base_clk, clk_csi2tx_strm0_pixclk_ctrl_REG, BIT(31), BIT(31));
+	sf_set_clear(sf_crtc->base_clk, clk_ppi_tx_esc_clk_ctrl_REG, BIT(31), BIT(31));
+	sf_set_clear(sf_crtc->base_clk, clk_dsi_apb_ctrl_REG, BIT(31), BIT(31));
+	sf_set_clear(sf_crtc->base_clk, clk_dsi_sys_clk_ctrl_REG, BIT(31), BIT(31));
+
+	sf_set_clear(sf_crtc->base_rst, vout_rstgen_assert0_REG, ~0x19bfff, 0x19bfff);
+	do {
+		temp = ioread32(sf_crtc->base_rst + vout_rstgen_status0_REG);
+		temp &= 0x19bfff;
+	} while (temp != 0x19bfff);
+}
+
+void vout_disable(struct starfive_crtc *sf_crtc)
+{
+	iowrite32(0xFFFFFFFF, sf_crtc->base_rst);
+
+	clk_disable_unprepare(sf_crtc->clk_disp_axi);
+	clk_disable_unprepare(sf_crtc->clk_vout_src);
+	reset_control_assert(sf_crtc->rst_vout_src);
+	reset_control_assert(sf_crtc->rst_disp_axi);
+}
+
+MODULE_AUTHOR("StarFive Technology Co., Ltd.");
+MODULE_DESCRIPTION("loadable VPP driver for StarFive");
+MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/starfive/starfive_drm_vpp.h b/drivers/gpu/drm/starfive/starfive_drm_vpp.h
new file mode 100644
index 0000000000..12a1928987
--- /dev/null
+++ b/drivers/gpu/drm/starfive/starfive_drm_vpp.h
@@ -0,0 +1,201 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2021 StarFive Technology Co., Ltd.
+ */
+#ifndef __SF_FB_VPP_H__
+#define __SF_FB_VPP_H__
+
+#include "starfive_drm_crtc.h"
+
+#define PP_ID_0	0
+#define PP_ID_1	1
+#define PP_ID_2	2
+
+#define PP_NUM	3
+
+#define PP_STOP	0
+#define PP_RUN	1
+
+#define PP_INTR_ENABLE	1
+#define PP_INTR_DISABLE	0
+//PP coefficients
+#define R2Y_COEF_R1	77
+#define R2Y_COEF_G1	150
+#define R2Y_COEF_B1	29
+#define R2Y_OFFSET1	0
+#define R2Y_COEF_R2	(0x400 | 43)
+#define R2Y_COEF_G2	(0x400 | 85)
+#define R2Y_COEF_B2	128
+#define R2Y_OFFSET2	128
+#define R2Y_COEF_R3	128
+#define R2Y_COEF_G3	(0x400 | 107)
+#define R2Y_COEF_B3	(0x400 | 21)
+#define R2Y_OFFSET3	128
+
+//sys registers
+#define SYS_CONF_LCDC		0x00
+#define SYS_CONF_PP		0x04
+#define SYS_MAP_CONV		0x08
+
+//vout clk registers
+#define CLK_LCDC_OCLK_CTRL	0x14
+
+enum PP_LCD_PATH {
+	SYS_BUS_OUTPUT = 0,
+	FIFO_OUTPUT = 1,
+};
+
+enum PP_COLOR_CONVERT_SCALE {
+	NOT_BYPASS = 0,
+	BYPASS,
+};
+
+enum PP_SRC_FORMAT {
+	PP_SRC_YUV420P = 0,
+	PP_SRC_YUV422,
+	PP_SRC_YUV420I,
+	PP_RESERVED,
+	PP_SRC_GRB888,
+	PP_SRC_RGB565,
+};
+
+enum PP_DST_FORMAT {
+	PP_DST_YUV420P = 0,
+	PP_DST_YUV422,
+	PP_DST_YUV420I,
+	PP_DST_RGBA888,
+	PP_DST_ARGB888,
+	PP_DST_RGB565,
+	PP_DST_ABGR888,
+	PP_DST_BGRA888,
+};
+
+struct pp_video_mode {
+	enum COLOR_FORMAT format;
+	unsigned int height;
+	unsigned int width;
+	unsigned int addr;
+};
+
+struct pp_mode {
+	char pp_id;
+	bool bus_out;	/*out to ddr*/
+	bool fifo_out;	/*out to lcdc*/
+	bool inited;
+	struct pp_video_mode src;
+	struct pp_video_mode dst;
+};
+
+//vpp registers
+#define PP_SWITCH		0x0000
+#define PP_CTRL1		0x0004
+#define PP_CTRL2		0x0008
+#define PP_SRC_SIZE		0x000C
+#define PP_DROP_CTRL		0x0010
+#define PP_DES_SIZE		0x0014
+#define PP_Scale_Hratio		0x0018
+#define PP_Scale_Vratio		0x001C
+#define PP_Scale_limit		0x0020
+#define PP_SRC_Y_SA_NXT		0x0024
+#define PP_SRC_U_SA_NXT		0x0028
+#define PP_SRC_V_SA_NXT		0x002c
+#define PP_LOAD_NXT_PAR		0x0030
+#define PP_SRC_Y_SA0		0x0034
+#define PP_SRC_U_SA0		0x0038
+#define PP_SRC_V_SA0		0x003c
+#define PP_SRC_Y_OFS		0x0040
+#define PP_SRC_U_OFS		0x0044
+#define PP_SRC_V_OFS		0x0048
+#define PP_SRC_Y_SA1		0x004C
+#define PP_SRC_U_SA1		0x0050
+#define PP_SRC_V_SA1		0x0054
+#define PP_DES_Y_SA		0x0058
+#define PP_DES_U_SA		0x005C
+#define PP_DES_V_SA		0x0060
+#define PP_DES_Y_OFS		0x0064
+#define PP_DES_U_OFS		0x0068
+#define PP_DES_V_OFS		0x006C
+#define PP_INT_STATUS		0x0070
+#define PP_INT_MASK		0x0074
+#define PP_INT_CLR		0x0078
+#define PP_R2Y_COEF1		0x007C
+#define PP_R2Y_COEF2		0x0080
+
+/* Definition controller bit for LCDC registers */
+//for PP_SWITCH
+#define PP_TRIG			0
+//for PP_CTRL1
+#define PP_LCDPATH_EN		0
+#define PP_INTERLACE		1
+#define PP_POINTER_MODE		2
+#define PP_SRC_FORMAT_N		4
+#define PP_420_ITLC		7
+#define PP_DES_FORMAT		8
+#define PP_R2Y_BPS		12
+#define PP_MSCALE_BPS		13
+#define PP_Y2R_BPS		14
+#define PP_ARGB_ALPHA		16
+#define PP_UV_IN_ADD_128	24
+#define PP_UV_OUT_ADD_128	25
+#define PP_SRC_422_YUV_POS	26
+#define PP_SRC_420_YUV_POS	28
+#define PP_SRC_ARGB_ORDER	29
+//for PP_CTRL2
+#define PP_LOCK_EN		0
+#define PP_INT_INTERVAL		8
+#define PP_DES_422_ORDER	16
+#define PP_DES_420_ORDER	18
+//for PP_SRC_SIZE
+#define PP_SRC_HSIZE		0
+#define PP_SRC_VSIZE		16
+//for PP_DROP_CTRL
+#define PP_DROP_HRATION		0
+#define PP_DROP_VRATION		4
+//for PP_DES_SIZE
+#define PP_DES_HSIZE		0
+#define PP_DES_VSIZE		16
+//for PP_R2Y_COEF1
+#define PP_COEF_R1		0
+#define PP_COEF_G1		16
+//for PP_R2Y_COEF2
+#define PP_COEF_B1		0
+#define PP_OFFSET_1		16
+
+#define vout_rstgen_assert0_REG			0x0
+#define vout_rstgen_status0_REG			0x4
+#define clk_vout_apb_ctrl_REG			0x0
+#define clk_mapconv_apb_ctrl_REG		0x4
+#define clk_mapconv_axi_ctrl_REG		0x8
+#define clk_disp0_axi_ctrl_REG			0xC
+#define clk_disp1_axi_ctrl_REG			0x10
+#define clk_lcdc_oclk_ctrl_REG			0x14
+#define clk_lcdc_axi_ctrl_REG			0x18
+#define clk_vpp0_axi_ctrl_REG			0x1C
+#define clk_vpp1_axi_ctrl_REG			0x20
+#define clk_vpp2_axi_ctrl_REG			0x24
+#define clk_pixrawout_apb_ctrl_REG		0x28
+#define clk_pixrawout_axi_ctrl_REG		0x2C
+#define clk_csi2tx_strm0_pixclk_ctrl_REG	0x30
+#define clk_csi2tx_strm0_apb_ctrl_REG		0x34
+#define clk_dsi_sys_clk_ctrl_REG		0x38
+#define clk_dsi_apb_ctrl_REG			0x3C
+#define clk_ppi_tx_esc_clk_ctrl_REG		0x40
+
+void mapconv_pp0_sel(struct starfive_crtc *sf_crtc, int sel);
+void pp_src_addr_next(struct starfive_crtc *sf_crtc, int pp_num, int ysa, int usa, int vsa);
+void pp_src_offset_cfg(struct starfive_crtc *sf_crtc, int pp_num, int yoff, int uoff, int voff);
+void pp_nxt_addr_load(struct starfive_crtc *sf_crtc, int pp_num, int nxt_par, int nxt_pos);
+void pp_intcfg(struct starfive_crtc *sf_crtc, int pp_num, int int_mask);
+irqreturn_t vpp1_isr_handler(int this_irq, void *dev_id);
+void pp1_enable_intr(struct starfive_crtc *sf_crtc);
+void pp_enable_intr(struct starfive_crtc *sf_crtc, int pp_num);
+void pp_disable_intr(struct starfive_crtc *sf_crtc, int pp_num);
+void pp_run(struct starfive_crtc *sf_crtc, int pp_num, int start);
+int starfive_pp_enable(struct starfive_crtc *sf_crtc);
+int starfive_pp_get_2lcdc_id(struct starfive_crtc *sf_crtc);
+int starfive_pp_update(struct starfive_crtc *sf_crtc);
+void vout_disable(struct starfive_crtc *sf_crtc);
+void vout_reset(struct starfive_crtc *sf_crtc);
+void dsitx_vout_init(struct starfive_crtc *sf_crtc);
+
+#endif
diff --git a/include/soc/sifive/sifive_ccache.h b/include/soc/sifive/sifive_ccache.h
index 4d4ed49388..e34d5060eb 100644
--- a/include/soc/sifive/sifive_ccache.h
+++ b/include/soc/sifive/sifive_ccache.h
@@ -13,4 +13,6 @@ extern int unregister_sifive_ccache_error_notifier(struct notifier_block *nb);
 #define SIFIVE_CCACHE_ERR_TYPE_CE 0
 #define SIFIVE_CCACHE_ERR_TYPE_UE 1
 
+void sifive_ccache_flush_range(phys_addr_t start, size_t len);
+
 #endif /* __SOC_SIFIVE_CCACHE_H */
-- 
2.49.0


From 2be41de1520c36f5d913f49530cb72ef3b74b279 Mon Sep 17 00:00:00 2001
From: Emil Renner Berthing <kernel@esmil.dk>
Date: Wed, 22 Sep 2021 16:35:15 +0200
Subject: [PATCH 28/31] [WIP] drm/starfive: Support DRM_FORMAT_XRGB8888

When creating dumb buffers with 32bpp and 24bit colour depth this is
default mode return by drm_mode_legacy_fb_format. So we need to support
this for common dumb buffers to just work.

Signed-off-by: Emil Renner Berthing <kernel@esmil.dk>
---
 drivers/gpu/drm/starfive/starfive_drm_crtc.c  | 1 +
 drivers/gpu/drm/starfive/starfive_drm_plane.c | 1 +
 2 files changed, 2 insertions(+)

diff --git a/drivers/gpu/drm/starfive/starfive_drm_crtc.c b/drivers/gpu/drm/starfive/starfive_drm_crtc.c
index dfea3c3575..0cee7f54d5 100644
--- a/drivers/gpu/drm/starfive/starfive_drm_crtc.c
+++ b/drivers/gpu/drm/starfive/starfive_drm_crtc.c
@@ -64,6 +64,7 @@ static int ddrfmt_to_ppfmt(struct starfive_crtc *sf_crtc)
 	case DRM_FORMAT_NV12:
 		sf_crtc->vpp_format = COLOR_YUV420_NV12;
 		break;
+	case DRM_FORMAT_XRGB8888:
 	case DRM_FORMAT_ARGB8888:
 		sf_crtc->vpp_format = COLOR_RGB888_ARGB;
 		break;
diff --git a/drivers/gpu/drm/starfive/starfive_drm_plane.c b/drivers/gpu/drm/starfive/starfive_drm_plane.c
index 119a9fe327..7ee1d35762 100644
--- a/drivers/gpu/drm/starfive/starfive_drm_plane.c
+++ b/drivers/gpu/drm/starfive/starfive_drm_plane.c
@@ -28,6 +28,7 @@ static const u32 formats[] = {
 	DRM_FORMAT_NV21,
 	DRM_FORMAT_NV12,
 
+	DRM_FORMAT_XRGB8888,
 	DRM_FORMAT_ARGB8888,
 	DRM_FORMAT_ABGR8888,
 };
-- 
2.49.0


From 905568cdfe8c1ca04b5be903348028ebe1ed8b63 Mon Sep 17 00:00:00 2001
From: Andreas Schwab <schwab@suse.de>
Date: Tue, 29 Oct 2024 15:03:06 +0100
Subject: [PATCH 29/31] drm/starfive: set FOP_UNSIGNED_OFFSET in
 starfive_drm_driver_fops

This fixes the error from drm_open:

[  +0.000020] [      C1] WARNING: CPU: 1 PID: 1110 at drivers/gpu/drm/drm_file.c

Signed-off-by: Andreas Schwab <schwab@suse.de>
---
 drivers/gpu/drm/starfive/starfive_drm_drv.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/drivers/gpu/drm/starfive/starfive_drm_drv.c b/drivers/gpu/drm/starfive/starfive_drm_drv.c
index 94ecbdc287..9bffcfe0cd 100644
--- a/drivers/gpu/drm/starfive/starfive_drm_drv.c
+++ b/drivers/gpu/drm/starfive/starfive_drm_drv.c
@@ -56,6 +56,7 @@ static const struct file_operations starfive_drm_driver_fops = {
 	.unlocked_ioctl = drm_ioctl,
 	.compat_ioctl = drm_compat_ioctl,
 	.release = drm_release,
+	.fop_flags = FOP_UNSIGNED_OFFSET,
 };
 
 static struct drm_driver starfive_drm_driver = {
-- 
2.49.0


From a4ec5e716f58ac04f2f3e69e83911fbf344b2ae5 Mon Sep 17 00:00:00 2001
From: "sw.multimedia" <sw.multimedia@starfivetech.com>
Date: Tue, 31 Aug 2021 16:48:57 +0800
Subject: [PATCH 30/31] drm/i2c/tda998x: Hardcode register values for Starlight

A proper solution to this hack should be found.

Signed-off-by: jack.zhu <jack.zhu@starfivetech.com>
Signed-off-by: keith.zhao <keith.zhao@starfivetech.com>
---
 drivers/gpu/drm/i2c/tda998x_drv.c | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/drivers/gpu/drm/i2c/tda998x_drv.c b/drivers/gpu/drm/i2c/tda998x_drv.c
index 82d4a4e206..41537d2f8c 100644
--- a/drivers/gpu/drm/i2c/tda998x_drv.c
+++ b/drivers/gpu/drm/i2c/tda998x_drv.c
@@ -1607,7 +1607,9 @@ static void tda998x_bridge_mode_set(struct drm_bridge *bridge,
 		reg |= VIP_CNTRL_3_H_TGL;
 	if (mode->flags & DRM_MODE_FLAG_NVSYNC)
 		reg |= VIP_CNTRL_3_V_TGL;
-	reg_write(priv, REG_VIP_CNTRL_3, reg);
+	//reg_write(priv, REG_VIP_CNTRL_3, reg);
+	reg_write(priv, REG_VIP_CNTRL_3, 0x26);
+	reg_write(priv, REG_VIDFORMAT, 0x06);
 
 	reg_write(priv, REG_VIDFORMAT, 0x00);
 	reg_write16(priv, REG_REFPIX_MSB, ref_pix);
@@ -1645,7 +1647,8 @@ static void tda998x_bridge_mode_set(struct drm_bridge *bridge,
 		reg |= TBG_CNTRL_1_H_TGL;
 	if (mode->flags & DRM_MODE_FLAG_NVSYNC)
 		reg |= TBG_CNTRL_1_V_TGL;
-	reg_write(priv, REG_TBG_CNTRL_1, reg);
+	//reg_write(priv, REG_TBG_CNTRL_1, reg);
+	reg_write(priv, REG_TBG_CNTRL_1, 0x46);
 
 	/* must be last register set: */
 	reg_write(priv, REG_TBG_CNTRL_0, 0);
-- 
2.49.0


From 73c0d061279e1edb2d593d5383a1a9c9df65d144 Mon Sep 17 00:00:00 2001
From: Emil Renner Berthing <kernel@esmil.dk>
Date: Sun, 31 Oct 2021 17:15:58 +0100
Subject: [PATCH 31/31] riscv: dts: Add full JH7100, Starlight and VisionFive
 support

Based on the device tree in https://github.com/starfive-tech/u-boot/
with contributions from:
yanhong.wang <yanhong.wang@starfivetech.com>
Huan.Feng <huan.feng@starfivetech.com>
ke.zhu <ke.zhu@starfivetech.com>
yiming.li <yiming.li@starfivetech.com>
jack.zhu <jack.zhu@starfivetech.com>
Samin Guo <samin.guo@starfivetech.com>
Chenjieqin <Jessica.Chen@starfivetech.com>
bo.li <bo.li@starfivetech.com>

Rearranged, cleanups, fixes, pins and resets added by Emil.
Cleanups, fixes, clocks added by Geert.
Cleanups and GPIO fixes from Drew.
Thermal zone added by Stephen.
PWM pins added by Jianlong.
cpu-map added by Jonas.

Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
Signed-off-by: Stephen L Arnold <nerdboy@gentoo.org>
Signed-off-by: Drew Fustini <drew@beagleboard.org>
Signed-off-by: Jianlong Huang <jianlong.huang@starfivetech.com>
Signed-off-by: Jonas Hahnfeld <hahnjo@hahnjo.de>
Signed-off-by: Emil Renner Berthing <kernel@esmil.dk>
---
 arch/riscv/boot/dts/starfive/Makefile         |   2 +
 .../starfive/jh7100-beaglev-starlight-a1.dts  |  24 ++
 .../dts/starfive/jh7100-beaglev-starlight.dts |   6 +
 .../boot/dts/starfive/jh7100-common.dtsi      | 177 ++++++++
 .../jh7100-starfive-visionfive-v1.dts         |  13 +
 arch/riscv/boot/dts/starfive/jh7100.dtsi      | 389 ++++++++++++++++++
 6 files changed, 611 insertions(+)
 create mode 100644 arch/riscv/boot/dts/starfive/jh7100-beaglev-starlight-a1.dts

diff --git a/arch/riscv/boot/dts/starfive/Makefile b/arch/riscv/boot/dts/starfive/Makefile
index b3bb12f78e..1a88d79f01 100644
--- a/arch/riscv/boot/dts/starfive/Makefile
+++ b/arch/riscv/boot/dts/starfive/Makefile
@@ -1,10 +1,12 @@
 # SPDX-License-Identifier: GPL-2.0
 # Enables support for device-tree overlays
+DTC_FLAGS_jh7100-beaglev-starlight-a1 := -@
 DTC_FLAGS_jh7100-beaglev-starlight := -@
 DTC_FLAGS_jh7100-starfive-visionfive-v1 := -@
 DTC_FLAGS_jh7110-starfive-visionfive-2-v1.2a := -@
 DTC_FLAGS_jh7110-starfive-visionfive-2-v1.3b := -@
 
+dtb-$(CONFIG_ARCH_STARFIVE) += jh7100-beaglev-starlight-a1.dtb
 dtb-$(CONFIG_ARCH_STARFIVE) += jh7100-beaglev-starlight.dtb
 dtb-$(CONFIG_ARCH_STARFIVE) += jh7100-starfive-visionfive-v1.dtb
 
diff --git a/arch/riscv/boot/dts/starfive/jh7100-beaglev-starlight-a1.dts b/arch/riscv/boot/dts/starfive/jh7100-beaglev-starlight-a1.dts
new file mode 100644
index 0000000000..d307e44590
--- /dev/null
+++ b/arch/riscv/boot/dts/starfive/jh7100-beaglev-starlight-a1.dts
@@ -0,0 +1,24 @@
+// SPDX-License-Identifier: GPL-2.0 OR MIT
+/*
+ * Copyright (C) 2021 Emil Renner Berthing <kernel@esmil.dk>
+ */
+
+/dts-v1/;
+#include "jh7100-common.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+
+/ {
+	model = "BeagleV Starlight Beta A1";
+	compatible = "beagle,beaglev-starlight-jh7100-a1", "starfive,jh7100";
+
+	gpio-restart {
+		compatible = "gpio-restart";
+		gpios = <&gpio 63 GPIO_ACTIVE_HIGH>;
+		priority = <224>;
+	};
+};
+
+&gpio {
+	/* don't reset gpio mux for serial console and reset gpio */
+	starfive,keep-gpiomux = <13 14 63>;
+};
diff --git a/arch/riscv/boot/dts/starfive/jh7100-beaglev-starlight.dts b/arch/riscv/boot/dts/starfive/jh7100-beaglev-starlight.dts
index 168f5d9895..18eb3d5800 100644
--- a/arch/riscv/boot/dts/starfive/jh7100-beaglev-starlight.dts
+++ b/arch/riscv/boot/dts/starfive/jh7100-beaglev-starlight.dts
@@ -6,6 +6,7 @@
 
 /dts-v1/;
 #include "jh7100-common.dtsi"
+#include <dt-bindings/gpio/gpio.h>
 
 / {
 	model = "BeagleV Starlight Beta";
@@ -16,6 +17,11 @@ &gmac {
 	phy-handle = <&phy>;
 };
 
+&gpio {
+	/* don't reset gpio mux for serial console on uart3 */
+	starfive,keep-gpiomux = <13 14>;
+};
+
 &mdio {
 	phy: ethernet-phy@7 {
 		reg = <7>;
diff --git a/arch/riscv/boot/dts/starfive/jh7100-common.dtsi b/arch/riscv/boot/dts/starfive/jh7100-common.dtsi
index 3fad20c55d..758754c4aa 100644
--- a/arch/riscv/boot/dts/starfive/jh7100-common.dtsi
+++ b/arch/riscv/boot/dts/starfive/jh7100-common.dtsi
@@ -15,6 +15,7 @@ aliases {
 		mmc0 = &sdio0;
 		mmc1 = &sdio1;
 		serial0 = &uart3;
+		serial1 = &uart0;
 	};
 
 	chosen {
@@ -47,11 +48,41 @@ reserved-memory {
 		#size-cells = <2>;
 		ranges;
 
+		linux,cma {
+			compatible = "shared-dma-pool";
+			alloc-ranges = <0x0 0xa0000000 0x0 0x28000000>;
+			size = <0x0 0x28000000>;
+			alignment = <0x0 0x1000>;
+			reusable;
+			linux,cma-default;
+		};
+
+		jpu_reserved: framebuffer@c9000000 {
+			reg = <0x0 0xc9000000 0x0 0x4000000>;
+		};
+
+		nvdla_reserved: framebuffer@d0000000 {
+			reg = <0x0 0xd0000000 0x0 0x28000000>;
+			no-map;
+		};
+
+		vin_reserved: framebuffer@f9000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0xf9000000 0x0 0x1000000>;
+			no-map;
+		};
+
 		dma-reserved@fa000000 {
 			reg = <0x0 0xfa000000 0x0 0x1000000>;
 			no-map;
 		};
 
+		sffb_reserved: framebuffer@fb000000 {
+			compatible = "shared-dma-pool";
+			reg = <0x0 0xfb000000 0x0 0x2000000>;
+			no-map;
+		};
+
 		linux,dma@107a000000 {
 			compatible = "shared-dma-pool";
 			reg = <0x10 0x7a000000 0x0 0x1000000>;
@@ -72,6 +103,44 @@ wifi_pwrseq: wifi-pwrseq {
 	};
 };
 
+&display {
+	memory-region = <&sffb_reserved>;
+	status = "okay";
+};
+
+&crtc {
+	ddr-format = <4>; //<WIN_FMT_RGB565>;
+	status = "okay";
+
+	port: port@0 {
+		reg = <0>;
+
+		crtc_0_out: endpoint {
+			remote-endpoint = <&hdmi_input0>;
+		};
+	};
+};
+
+&encoder {
+	encoder-type = <2>; // 2-TMDS, 3-LVDS, 6-DSI, 8-DPI
+	status = "okay";
+
+	ports {
+		port@0 {
+			hdmi_out: endpoint {
+				remote-endpoint = <&tda998x_0_input>;
+			};
+		};
+
+		port@1 {
+			hdmi_input0: endpoint {
+				remote-endpoint = <&crtc_0_out>;
+			};
+		};
+
+	};
+};
+
 &gmac {
 	pinctrl-names = "default";
 	pinctrl-0 = <&gmac_pins>;
@@ -199,6 +268,20 @@ GPO_I2C2_PAD_SDA_OEN,
 		};
 	};
 
+	pwmdac_pins: pwmdac-0 {
+		pwmdac-pins {
+			pinmux = <GPIOMUX(23, GPO_PWMDAC_LEFT_OUT,
+				  GPO_ENABLE, GPI_NONE)>,
+				 <GPIOMUX(24, GPO_PWMDAC_RIGHT_OUT,
+				  GPO_ENABLE, GPI_NONE)>;
+			bias-disable;
+			drive-strength = <35>;
+			input-disable;
+			input-schmitt-disable;
+			slew-rate = <0>;
+		};
+	};
+
 	pwm_pins: pwm-0 {
 		pwm-pins {
 			pinmux = <GPIOMUX(7,
@@ -289,6 +372,39 @@ GPO_SDIO1_PAD_CDATA_OEN_BIT3,
 		};
 	};
 
+	spi2_pins: spi2-0 {
+		mosi-pins {
+			pinmux = <GPIOMUX(18, GPO_SPI2_PAD_TXD,
+				  GPO_ENABLE, GPI_NONE)>;
+			bias-disable;
+			input-disable;
+			input-schmitt-disable;
+		};
+		miso-pins {
+			pinmux = <GPIOMUX(16, GPO_LOW, GPO_DISABLE,
+				  GPI_SPI2_PAD_RXD)>;
+			bias-pull-up;
+			input-enable;
+			input-schmitt-enable;
+		};
+		sck-pins {
+			pinmux = <GPIOMUX(12, GPO_SPI2_PAD_SCK_OUT,
+				  GPO_ENABLE, GPI_NONE)>;
+			bias-disable;
+			input-disable;
+			input-schmitt-disable;
+		};
+		ss-pins {
+			pinmux = <GPIOMUX(15, GPO_SPI2_PAD_SS_0_N,
+				  GPO_ENABLE, GPI_NONE)>,
+				 <GPIOMUX(11, GPO_SPI2_PAD_SS_1_N,
+				  GPO_ENABLE, GPI_NONE)>;
+			bias-disable;
+			input-disable;
+			input-schmitt-disable;
+		};
+	};
+
 	uart0_pins: uart0-0 {
 		rx-pins {
 			pinmux = <GPIOMUX(40, GPO_LOW, GPO_DISABLE,
@@ -364,6 +480,17 @@ pmic@5e {
 		regulators {
 		};
 	};
+
+	tda998x@70 {
+		compatible = "nxp,tda998x";
+		reg = <0x70>;
+
+		port {
+			tda998x_0_input: endpoint {
+				remote-endpoint = <&hdmi_out>;
+			};
+		};
+	};
 };
 
 &i2c1 {
@@ -400,6 +527,44 @@ &pwm {
 	status = "okay";
 };
 
+&pwmdac {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pwmdac_pins>;
+	status = "okay";
+};
+
+&qspi {
+	nor_flash: nor-flash@0 {
+		compatible = "spi-flash";
+		reg = <0>;
+		spi-max-frequency = <31250000>;
+		page-size = <256>;
+		block-size = <16>;
+		cdns,read-delay = <4>;
+		cdns,tshsl-ns = <1>;
+		cdns,tsd2d-ns = <1>;
+		cdns,tchsh-ns = <1>;
+		cdns,tslch-ns = <1>;
+		spi-tx-bus-width = <1>;
+		spi-rx-bus-width = <1>;
+	};
+
+	nand_flash: nand-flash@1 {
+		compatible = "spi-flash-nand";
+		reg = <1>;
+		spi-max-frequency = <31250000>;
+		page-size = <2048>;
+		block-size = <17>;
+		cdns,read-delay = <4>;
+		cdns,tshsl-ns = <1>;
+		cdns,tsd2d-ns = <1>;
+		cdns,tchsh-ns = <1>;
+		cdns,tslch-ns = <1>;
+		spi-tx-bus-width = <1>;
+		spi-rx-bus-width = <1>;
+	};
+};
+
 &sdio0 {
 	broken-cd;
 	bus-width = <4>;
@@ -428,6 +593,18 @@ wifi@1 {
 	};
 };
 
+&spi2 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&spi2_pins>;
+	status = "okay";
+
+	spi_dev0: spi@0 {
+		compatible = "rohm,dh2228fv";
+		spi-max-frequency = <10000000>;
+		reg = <0>;
+	};
+};
+
 &uart0 {
 	pinctrl-names = "default";
 	pinctrl-0 = <&uart0_pins>;
diff --git a/arch/riscv/boot/dts/starfive/jh7100-starfive-visionfive-v1.dts b/arch/riscv/boot/dts/starfive/jh7100-starfive-visionfive-v1.dts
index 692c696e1a..ab8ec5712e 100644
--- a/arch/riscv/boot/dts/starfive/jh7100-starfive-visionfive-v1.dts
+++ b/arch/riscv/boot/dts/starfive/jh7100-starfive-visionfive-v1.dts
@@ -22,6 +22,19 @@ &gmac {
 	phy-handle = <&phy>;
 };
 
+&gpio {
+	/* don't reset gpio mux for serial console and reset gpio */
+	starfive,keep-gpiomux = <13 14 63>;
+};
+
+&i2c0 {
+	eeprom@50 {
+		compatible = "atmel,24c04";
+		reg = <0x50>;
+		pagesize = <16>;
+	};
+};
+
 /*
  * The board uses a Motorcomm YT8521 PHY supporting RGMII-ID, but requires
  * manual adjustment of the RX internal delay to work properly.  The default
diff --git a/arch/riscv/boot/dts/starfive/jh7100.dtsi b/arch/riscv/boot/dts/starfive/jh7100.dtsi
index 7dfb6cc215..85784fb2f2 100644
--- a/arch/riscv/boot/dts/starfive/jh7100.dtsi
+++ b/arch/riscv/boot/dts/starfive/jh7100.dtsi
@@ -6,7 +6,9 @@
 
 /dts-v1/;
 #include <dt-bindings/clock/starfive-jh7100.h>
+#include <dt-bindings/clock/starfive-jh7100-audio.h>
 #include <dt-bindings/reset/starfive-jh7100.h>
+#include <dt-bindings/reset/starfive-jh7100-audio.h>
 
 / {
 	compatible = "starfive,jh7100";
@@ -37,6 +39,7 @@ U74_0: cpu@0 {
 			riscv,isa-base = "rv64i";
 			riscv,isa-extensions = "i", "m", "a", "f", "d", "c", "zicntr", "zicsr",
 					       "zifencei", "zihpm";
+			starfive,itim = <&itim0>;
 			tlb-split;
 
 			cpu0_intc: interrupt-controller {
@@ -66,6 +69,7 @@ U74_1: cpu@1 {
 			riscv,isa-base = "rv64i";
 			riscv,isa-extensions = "i", "m", "a", "f", "d", "c", "zicntr", "zicsr",
 					       "zifencei", "zihpm";
+			starfive,itim = <&itim1>;
 			tlb-split;
 
 			cpu1_intc: interrupt-controller {
@@ -153,6 +157,24 @@ soc {
 		dma-noncoherent;
 		ranges;
 
+		dtim: dtim@1000000 {
+			compatible = "starfive,dtim0";
+			reg = <0x0 0x1000000 0x0 0x2000>;
+			reg-names = "mem";
+		};
+
+		itim0: itim@1808000 {
+			compatible = "starfive,itim0";
+			reg = <0x0 0x1808000 0x0 0x8000>;
+			reg-names = "mem";
+		};
+
+		itim1: itim@1820000 {
+			compatible = "starfive,itim0";
+			reg = <0x0 0x1820000 0x0 0x8000>;
+			reg-names = "mem";
+		};
+
 		clint: clint@2000000 {
 			compatible = "starfive,jh7100-clint", "sifive,clint0";
 			reg = <0x0 0x2000000 0x0 0x10000>;
@@ -239,6 +261,124 @@ stmmac_axi_setup: stmmac-axi-config {
 			};
 		};
 
+		dma2p: dma-controller@100b0000 {
+			compatible = "starfive,jh7100-axi-dma";
+			reg = <0x0 0x100b0000 0x0 0x10000>;
+			clocks = <&clkgen JH7100_CLK_SGDMA2P_AXI>,
+				 <&clkgen JH7100_CLK_SGDMA2P_AHB>;
+			clock-names = "core-clk", "cfgr-clk";
+			resets = <&rstgen JH7100_RSTN_SGDMA2P_AXI>,
+				 <&rstgen JH7100_RSTN_SGDMA2P_AHB>;
+			reset-names = "axi", "ahb";
+			interrupts = <2>;
+			#dma-cells = <1>;
+			dma-channels = <4>;
+			snps,dma-masters = <1>;
+			snps,data-width = <4>;
+			snps,block-size = <4096 4096 4096 4096>;
+			snps,priority = <0 1 2 3>;
+			snps,axi-max-burst-len = <128>;
+			dma-coherent;
+		};
+
+		crypto: crypto@100d0000 {
+			compatible = "starfive,vic-sec";
+			reg = <0x0 0x100d0000 0x0 0x20000>,
+			      <0x0 0x11800234 0x0 0xc>;
+			reg-names = "secmem", "secclk";
+			clocks = <&clkgen JH7100_CLK_SEC_AHB>;
+			interrupts = <31>;
+		};
+
+		i2sadc0: i2sadc0@10400000 {
+			compatible = "snps,designware-i2sadc0";
+			reg = <0x0 0x10400000 0x0 0x1000>;
+			clocks = <&clkgen JH7100_CLK_APB1_BUS>;
+			clock-names = "i2sclk";
+			interrupt-parent = <&plic>;
+			#sound-dai-cells = <0>;
+			dmas = <&dma2p 28>;
+			dma-names = "rx";
+		};
+
+		i2svad: i2svad@10420000 {
+			compatible = "starfive,sf-i2svad";
+			reg = <0x0 0x10420000 0x0 0x1000> ;
+			clocks = <&audclk JH7100_AUDCLK_I2SVAD_APB>;
+			clock-names = "i2svad_apb";
+			resets = <&audrst JH7100_AUDRSTN_I2SVAD_APB>,
+				 <&audrst JH7100_AUDRSTN_I2SVAD_SRST>;
+			reset-names = "apb_i2svad", "i2svad_srst";
+			interrupts = <60>, <61>;
+			interrupt-names = "spintr", "slintr";
+			#sound-dai-cells = <0>;
+		};
+
+		pwmdac: pwmdac@10440000 {
+			compatible = "starfive,pwmdac";
+			reg = <0x0 0x10440000 0x0 0x1000>;
+			clocks = <&clkgen JH7100_CLK_AUDIO_ROOT>,
+				 <&clkgen JH7100_CLK_AUDIO_SRC>,
+				 <&clkgen JH7100_CLK_AUDIO_12288>,
+				 <&audclk JH7100_AUDCLK_DMA1P_AHB>,
+				 <&audclk JH7100_AUDCLK_PWMDAC_APB>,
+				 <&audclk JH7100_AUDCLK_DAC_MCLK>;
+			clock-names = "audio_root",
+				      "audio_src",
+				      "audio_12288",
+				      "dma1p_ahb",
+				      "pwmdac_apb",
+				      "dac_mclk";
+			resets = <&audrst JH7100_AUDRSTN_APB_BUS>,
+				 <&audrst JH7100_AUDRSTN_DMA1P_AHB>,
+				 <&audrst JH7100_AUDRSTN_PWMDAC_APB>;
+			reset-names = "apb_bus", "dma1p_ahb", "apb_pwmdac";
+			dmas = <&dma2p 23>;
+			dma-names = "tx";
+			#sound-dai-cells = <0>;
+		};
+
+		i2sdac0: i2sdac0@10450000 {
+			compatible = "snps,designware-i2sdac0";
+			reg = <0x0 0x10450000 0x0 0x1000>;
+			clocks = <&audclk JH7100_AUDCLK_DAC_MCLK>,
+				 <&audclk JH7100_AUDCLK_I2SDAC_BCLK>,
+				 <&audclk JH7100_AUDCLK_I2SDAC_LRCLK>,
+				 <&audclk JH7100_AUDCLK_I2SDAC_APB>;
+			clock-names = "dac_mclk", "i2sdac0_bclk", "i2sdac0_lrclk", "i2sdac_apb";
+			resets = <&audrst JH7100_AUDRSTN_I2SDAC_APB>,
+				 <&audrst JH7100_AUDRSTN_I2SDAC_SRST>;
+			reset-names = "apb_i2sdac", "i2sdac_srst";
+			#sound-dai-cells = <0>;
+			dmas = <&dma2p 30>;
+			dma-names = "tx";
+		};
+
+		i2sdac1: i2sdac1@10460000 {
+			compatible = "snps,designware-i2sdac1";
+			reg = <0x0 0x10460000 0x0 0x1000>;
+			clocks = <&audclk JH7100_AUDCLK_DAC_MCLK>,
+				 <&audclk JH7100_AUDCLK_I2S1_BCLK>,
+				 <&audclk JH7100_AUDCLK_I2S1_LRCLK>,
+				 <&audclk JH7100_AUDCLK_I2S1_APB>;
+			clock-names = "dac_mclk", "i2sdac1_bclk", "i2sdac1_lrclk", "i2s1_apb";
+			resets = <&audrst JH7100_AUDRSTN_I2S1_APB>,
+				 <&audrst JH7100_AUDRSTN_I2S1_SRST>;
+			#sound-dai-cells = <0>;
+			dmas = <&dma2p 31>;
+			dma-names = "tx";
+		};
+
+		i2sdac16k: i2sdac16k@10470000 {
+			compatible = "snps,designware-i2sdac16k";
+			reg = <0x0 0x10470000 0x0 0x1000>;
+			clocks = <&clkgen JH7100_CLK_APB1_BUS>;
+			clock-names = "i2sclk";
+			#sound-dai-cells = <0>;
+			dmas = <&dma2p 29>;
+			dma-names = "tx";
+		};
+
 		audclk: clock-controller@10480000 {
 			compatible = "starfive,jh7100-audclk";
 			reg = <0x0 0x10480000 0x0 0x10000>;
@@ -255,6 +395,50 @@ audrst: reset-controller@10490000 {
 			#reset-cells = <1>;
 		};
 
+		spdif_transmitter: spdif-transmitter {
+			compatible = "linux,spdif-dit";
+			#sound-dai-cells = <0>;
+		};
+
+		spdif_receiver: spdif-receiver {
+			compatible = "linux,spdif-dir";
+			#sound-dai-cells = <0>;
+		};
+
+		pwmdac_codec: pwmdac-transmitter {
+			compatible = "linux,pwmdac-dit";
+			#sound-dai-cells = <0>;
+		};
+
+		dmic_codec: dmic {
+			compatible = "dmic-codec";
+			#sound-dai-cells = <0>;
+		};
+
+		sound: snd-card {
+			compatible = "simple-audio-card";
+			simple-audio-card,name = "Starfive-Multi-Sound-Card";
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			/* pwmdac */
+			simple-audio-card,dai-link@0 {
+				reg = <0>;
+				status = "okay";
+				format = "left_j";
+				bitclock-master = <&sndcpu0>;
+				frame-master = <&sndcpu0>;
+
+				sndcpu0: cpu {
+					sound-dai = <&pwmdac>;
+				};
+
+				codec {
+					sound-dai = <&pwmdac_codec>;
+				};
+			};
+		};
+
 		sysaudio: syscon@104a0000 {
 			compatible = "starfive,jh7100-sysaudio", "syscon";
 			reg = <0x0 0x104a0000 0x0 0x10000>;
@@ -287,6 +471,25 @@ usb_cdns3: usb@0 {
 			};
 		};
 
+		dma1p: dma-controller@10500000 {
+			compatible = "starfive,jh7100-axi-dma";
+			reg = <0x0 0x10500000 0x0 0x10000>;
+			clocks = <&clkgen JH7100_CLK_SGDMA1P_AXI>,
+				 <&clkgen JH7100_CLK_SGDMA1P_BUS>;
+			clock-names = "core-clk", "cfgr-clk";
+			resets = <&rstgen JH7100_RSTN_DMA1P_AXI>,
+				 <&rstgen JH7100_RSTN_SGDMA1P_AXI>;
+			reset-names = "axi", "ahb";
+			interrupts = <1>;
+			#dma-cells = <1>;
+			dma-channels = <16>;
+			snps,dma-masters = <1>;
+			snps,data-width = <3>;
+			snps,block-size = <4096 4096 4096 4096 4096 4096 4096 4096 4096 4096 4096 4096 4096 4096 4096 4096>;
+			snps,priority = <0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15>;
+			snps,axi-max-burst-len = <64>;
+		};
+
 		clkgen: clock-controller@11800000 {
 			compatible = "starfive,jh7100-clkgen";
 			reg = <0x0 0x11800000 0x0 0x10000>;
@@ -295,6 +498,13 @@ clkgen: clock-controller@11800000 {
 			#clock-cells = <1>;
 		};
 
+		otp: otp@11810000 {
+			compatible = "starfive,fu740-otp";
+			reg = <0x0 0x11810000 0x0 0x10000>;
+			clocks = <&clkgen JH7100_CLK_OTP_APB>;
+			fuse-count = <0x200>;
+		};
+
 		rstgen: reset-controller@11840000 {
 			compatible = "starfive,jh7100-reset";
 			reg = <0x0 0x11840000 0x0 0x10000>;
@@ -306,6 +516,21 @@ sysmain: syscon@11850000 {
 			reg = <0x0 0x11850000 0x0 0x10000>;
 		};
 
+		qspi: spi@11860000 {
+			compatible = "cdns,qspi-nor";
+			reg = <0x0 0x11860000 0x0 0x10000>,
+			      <0x0 0x20000000 0x0 0x20000000>;
+			clocks = <&clkgen JH7100_CLK_QSPI_AHB>;
+			interrupts = <3>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			cdns,fifo-depth = <256>;
+			cdns,fifo-width = <4>;
+			cdns,trigger-address = <0x0>;
+			spi-max-frequency = <250000000>;
+			status = "disabled";
+		};
+
 		uart0: serial@11870000 {
 			compatible = "starfive,jh7100-hsuart", "snps,dw-apb-uart";
 			reg = <0x0 0x11870000 0x0 0x10000>;
@@ -332,6 +557,34 @@ uart1: serial@11880000 {
 			status = "disabled";
 		};
 
+		spi0: spi@11890000 {
+			compatible = "snps,dw-apb-ssi";
+			reg = <0x0 0x11890000 0x0 0x10000>;
+			clocks = <&clkgen JH7100_CLK_SPI0_CORE>,
+				 <&clkgen JH7100_CLK_SPI0_APB>;
+			clock-names = "ssi_clk", "pclk";
+			resets = <&rstgen JH7100_RSTN_SPI0_APB>;
+			reset-names = "spi";
+			interrupts = <94>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		spi1: spi@118a0000 {
+			compatible = "snps,dw-apb-ssi";
+			reg = <0x0 0x118a0000 0x0 0x10000>;
+			clocks = <&clkgen JH7100_CLK_SPI1_CORE>,
+				 <&clkgen JH7100_CLK_SPI1_APB>;
+			clock-names = "ssi_clk", "pclk";
+			resets = <&rstgen JH7100_RSTN_SPI1_APB>;
+			reset-names = "spi";
+			interrupts = <95>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
 		i2c0: i2c@118b0000 {
 			compatible = "snps,designware-i2c";
 			reg = <0x0 0x118b0000 0x0 0x10000>;
@@ -358,6 +611,41 @@ i2c1: i2c@118c0000 {
 			status = "disabled";
 		};
 
+		trng: trng@118d0000 {
+			compatible = "starfive,vic-rng";
+			reg = <0x0 0x118d0000 0x0 0x10000>;
+			clocks = <&clkgen JH7100_CLK_TRNG_APB>;
+			interrupts = <98>;
+		};
+
+		vpu_enc: vpu_enc@118e0000 {
+			compatible = "cm,cm521-vpu";
+			reg = <0x0 0x118e0000 0x0 0x4000>;
+			reg-names = "control";
+			clocks = <&clkgen JH7100_CLK_VP6_CORE>;
+			clock-names = "vcodec";
+			interrupts = <26>;
+		};
+
+		vpu_dec: vpu_dec@118f0000 {
+			compatible = "c&m,cm511-vpu";
+			reg = <0 0x118f0000 0 0x10000>;
+			clocks = <&clkgen JH7100_CLK_VP6_CORE>;
+			clock-names = "vcodec";
+			interrupts = <23>;
+			//memory-region = <&vpu_reserved>;
+		};
+
+		jpu: coadj12@11900000 {
+			compatible = "cm,codaj12-jpu-1";
+			reg = <0x0 0x11900000 0x0 0x300>;
+			reg-names = "control";
+			clocks = <&clkgen JH7100_CLK_JPEG_APB>;
+			clock-names = "jpege";
+			interrupts = <24>;
+			memory-region = <&jpu_reserved>;
+		};
+
 		gpio: pinctrl@11910000 {
 			compatible = "starfive,jh7100-pinctrl";
 			reg = <0x0 0x11910000 0x0 0x10000>,
@@ -372,6 +660,86 @@ gpio: pinctrl@11910000 {
 			#interrupt-cells = <2>;
 		};
 
+		nvdla@11940000 {
+			compatible = "nvidia,nvdla_os_initial";
+			interrupts = <22>;
+			memory-region = <&nvdla_reserved>;
+			reg = <0x0 0x11940000 0x0 0x40000>;
+			status = "okay";
+		};
+
+		display: display-subsystem {
+			compatible = "starfive,display-subsystem";
+			dma-coherent;
+			status = "disabled";
+		};
+
+		encoder: display-encoder {
+			compatible = "starfive,display-encoder";
+			status = "disabled";
+		};
+
+		crtc: crtc@12000000 {
+			compatible = "starfive,jh7100-crtc";
+			reg = <0x0 0x12000000 0x0 0x10000>,
+			      <0x0 0x12040000 0x0 0x10000>,
+			      <0x0 0x12080000 0x0 0x10000>,
+			      <0x0 0x120c0000 0x0 0x10000>,
+			      <0x0 0x12240000 0x0 0x10000>,
+			      <0x0 0x12250000 0x0 0x10000>,
+			      <0x0 0x12260000 0x0 0x10000>;
+			reg-names = "lcdc", "vpp0", "vpp1", "vpp2", "clk", "rst", "sys";
+			clocks = <&clkgen JH7100_CLK_DISP_AXI>, <&clkgen JH7100_CLK_VOUT_SRC>;
+			clock-names = "disp_axi", "vout_src";
+			resets = <&rstgen JH7100_RSTN_DISP_AXI>, <&rstgen JH7100_RSTN_VOUT_SRC>;
+			reset-names = "disp_axi", "vout_src";
+			interrupts = <101>, <103>;
+			interrupt-names = "lcdc_irq", "vpp1_irq";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+
+			pp1 {
+				pp-id = <1>;
+				fifo-out;
+				//sys-bus-out;
+				src-format = <11>; //<COLOR_RGB565>;
+				src-width = <1920>;
+				src-height = <1080>;
+				dst-format = <7>; //<COLOR_RGB888_ARGB>;
+				dst-width = <1920>;
+				dst-height = <1080>;
+			};
+		};
+
+		spi2: spi@12410000 {
+			compatible = "snps,dw-apb-ssi";
+			reg = <0x0 0x12410000 0x0 0x10000>;
+			clocks = <&clkgen JH7100_CLK_SPI2_CORE>,
+				 <&clkgen JH7100_CLK_SPI2_APB>;
+			clock-names = "ssi_clk", "pclk";
+			resets = <&rstgen JH7100_RSTN_SPI2_APB>;
+			reset-names = "spi";
+			interrupts = <70>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
+		spi3: spi@12420000 {
+			compatible = "snps,dw-apb-ssi";
+			reg = <0x0 0x12420000 0x0 0x10000>;
+			clocks = <&clkgen JH7100_CLK_SPI3_CORE>,
+				 <&clkgen JH7100_CLK_SPI3_APB>;
+			clock-names = "ssi_clk", "pclk";
+			resets = <&rstgen JH7100_RSTN_SPI3_APB>;
+			reset-names = "spi";
+			interrupts = <71>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			status = "disabled";
+		};
+
 		uart2: serial@12430000 {
 			compatible = "starfive,jh7100-uart", "snps,dw-apb-uart";
 			reg = <0x0 0x12430000 0x0 0x10000>;
@@ -454,5 +822,26 @@ sfctemp: temperature-sensor@124a0000 {
 			reset-names = "sense", "bus";
 			#thermal-sensor-cells = <0>;
 		};
+
+		xrp@f0000000 {
+			compatible = "cdns,xrp";
+			reg = <0x0  0xf0000000 0x0 0x01ffffff>,
+			      <0x10 0x72000000 0x0 0x00001000>,
+			      <0x10 0x72001000 0x0 0x00fff000>,
+			      <0x0  0x124b0000 0x0 0x00010000>;
+			clocks = <&clkgen JH7100_CLK_VP6_CORE>;
+			interrupts = <27>, <28>;
+			firmware-name = "vp6_elf";
+			dsp-irq = <19 20>;
+			dsp-irq-src = <0x20 0x21>;
+			intc-irq-mode = <1>;
+			intc-irq = <0 1>;
+			#address-cells = <1>;
+			#size-cells = <1>;
+			ranges = <0x40000000 0x0  0x40000000 0x01000000>,
+				 <0xb0000000 0x10 0x70000000 0x3000000>;
+			dsp@0 {
+			};
+		};
 	};
 };
-- 
2.49.0

